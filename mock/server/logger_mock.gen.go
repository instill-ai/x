// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package server

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.uber.org/zap"
)

// LoggerMock implements Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg string, fields ...zap.Field)
	funcDebugOrigin    string
	inspectFuncDebug   func(msg string, fields ...zap.Field)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcError          func(msg string, fields ...zap.Field)
	funcErrorOrigin    string
	inspectFuncError   func(msg string, fields ...zap.Field)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcInfo          func(msg string, fields ...zap.Field)
	funcInfoOrigin    string
	inspectFuncInfo   func(msg string, fields ...zap.Field)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcWarn          func(msg string, fields ...zap.Field)
	funcWarnOrigin    string
	inspectFuncWarn   func(msg string, fields ...zap.Field)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn
}

// NewLoggerMock returns a mock for Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugParams
	paramPtrs          *LoggerMockDebugParamPtrs
	expectationOrigins LoggerMockDebugExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg    string
	fields []zap.Field
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	msg    *string
	fields *[]zap.Field
}

// LoggerMockDebugOrigins contains origins of expectations of the Logger.Debug
type LoggerMockDebugExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg string, fields ...zap.Field) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, fields}
	mmDebug.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMsgParam1(msg string) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg
	mmDebug.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebug
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectFieldsParam2(fields ...zap.Field) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.fields = &fields
	mmDebug.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg string, fields ...zap.Field)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	mmDebug.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg string, fields ...zap.Field)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	mmDebug.mock.funcDebugOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	mmDebug.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements Logger
func (mmDebug *LoggerMock) Debug(msg string, fields ...zap.Field) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	mmDebug.t.Helper()

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, fields...)
	}

	mm_params := LoggerMockDebugParams{msg, fields}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebug.DebugMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, fields...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, fields)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.DebugMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", m.DebugMock.defaultExpectation.expectationOrigins.origin, *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.funcDebugOrigin)
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), m.DebugMock.expectedInvocationsOrigin, afterDebugCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorParams
	paramPtrs          *LoggerMockErrorParamPtrs
	expectationOrigins LoggerMockErrorExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg    string
	fields []zap.Field
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	msg    *string
	fields *[]zap.Field
}

// LoggerMockErrorOrigins contains origins of expectations of the Logger.Error
type LoggerMockErrorExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg string, fields ...zap.Field) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, fields}
	mmError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for Logger.Error
func (mmError *mLoggerMockError) ExpectMsgParam1(msg string) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg
	mmError.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmError
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Error
func (mmError *mLoggerMockError) ExpectFieldsParam2(fields ...zap.Field) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.fields = &fields
	mmError.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg string, fields ...zap.Field)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	mmError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg string, fields ...zap.Field)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	mmError.mock.funcErrorOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	mmError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements Logger
func (mmError *LoggerMock) Error(msg string, fields ...zap.Field) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	mmError.t.Helper()

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, fields...)
	}

	mm_params := LoggerMockErrorParams{msg, fields}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmError.ErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, fields...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, fields)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.ErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", m.ErrorMock.defaultExpectation.expectationOrigins.origin, *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.funcErrorOrigin)
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), m.ErrorMock.expectedInvocationsOrigin, afterErrorCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfoParams
	paramPtrs          *LoggerMockInfoParamPtrs
	expectationOrigins LoggerMockInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg    string
	fields []zap.Field
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	msg    *string
	fields *[]zap.Field
}

// LoggerMockInfoOrigins contains origins of expectations of the Logger.Info
type LoggerMockInfoExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg string, fields ...zap.Field) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, fields}
	mmInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMsgParam1(msg string) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg
	mmInfo.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfo
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectFieldsParam2(fields ...zap.Field) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.fields = &fields
	mmInfo.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg string, fields ...zap.Field)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	mmInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg string, fields ...zap.Field)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	mmInfo.mock.funcInfoOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	mmInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements Logger
func (mmInfo *LoggerMock) Info(msg string, fields ...zap.Field) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	mmInfo.t.Helper()

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, fields...)
	}

	mm_params := LoggerMockInfoParams{msg, fields}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfo.InfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, fields...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, fields)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.InfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", m.InfoMock.defaultExpectation.expectationOrigins.origin, *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.funcInfoOrigin)
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), m.InfoMock.expectedInvocationsOrigin, afterInfoCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnParams
	paramPtrs          *LoggerMockWarnParamPtrs
	expectationOrigins LoggerMockWarnExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg    string
	fields []zap.Field
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	msg    *string
	fields *[]zap.Field
}

// LoggerMockWarnOrigins contains origins of expectations of the Logger.Warn
type LoggerMockWarnExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg string, fields ...zap.Field) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, fields}
	mmWarn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMsgParam1(msg string) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg
	mmWarn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarn
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectFieldsParam2(fields ...zap.Field) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.fields = &fields
	mmWarn.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg string, fields ...zap.Field)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	mmWarn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg string, fields ...zap.Field)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	mmWarn.mock.funcWarnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	mmWarn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements Logger
func (mmWarn *LoggerMock) Warn(msg string, fields ...zap.Field) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	mmWarn.t.Helper()

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, fields...)
	}

	mm_params := LoggerMockWarnParams{msg, fields}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarn.WarnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, fields...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, fields)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.WarnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", m.WarnMock.defaultExpectation.expectationOrigins.origin, *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.funcWarnOrigin)
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), m.WarnMock.expectedInvocationsOrigin, afterWarnCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockErrorInspect()

			m.MinimockInfoInspect()

			m.MinimockWarnInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockErrorDone() &&
		m.MinimockInfoDone() &&
		m.MinimockWarnDone()
}
