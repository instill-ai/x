// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package server

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// ProtoMessageMock implements ProtoMessage
type ProtoMessageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcProtoMessage          func()
	funcProtoMessageOrigin    string
	inspectFuncProtoMessage   func()
	afterProtoMessageCounter  uint64
	beforeProtoMessageCounter uint64
	ProtoMessageMock          mProtoMessageMockProtoMessage

	funcProtoReflect          func() (m1 protoreflect.Message)
	funcProtoReflectOrigin    string
	inspectFuncProtoReflect   func()
	afterProtoReflectCounter  uint64
	beforeProtoReflectCounter uint64
	ProtoReflectMock          mProtoMessageMockProtoReflect

	funcReset          func()
	funcResetOrigin    string
	inspectFuncReset   func()
	afterResetCounter  uint64
	beforeResetCounter uint64
	ResetMock          mProtoMessageMockReset

	funcString          func() (s1 string)
	funcStringOrigin    string
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mProtoMessageMockString
}

// NewProtoMessageMock returns a mock for ProtoMessage
func NewProtoMessageMock(t minimock.Tester) *ProtoMessageMock {
	m := &ProtoMessageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ProtoMessageMock = mProtoMessageMockProtoMessage{mock: m}

	m.ProtoReflectMock = mProtoMessageMockProtoReflect{mock: m}

	m.ResetMock = mProtoMessageMockReset{mock: m}

	m.StringMock = mProtoMessageMockString{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProtoMessageMockProtoMessage struct {
	optional           bool
	mock               *ProtoMessageMock
	defaultExpectation *ProtoMessageMockProtoMessageExpectation
	expectations       []*ProtoMessageMockProtoMessageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProtoMessageMockProtoMessageExpectation specifies expectation struct of the ProtoMessage.ProtoMessage
type ProtoMessageMockProtoMessageExpectation struct {
	mock *ProtoMessageMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProtoMessage *mProtoMessageMockProtoMessage) Optional() *mProtoMessageMockProtoMessage {
	mmProtoMessage.optional = true
	return mmProtoMessage
}

// Expect sets up expected params for ProtoMessage.ProtoMessage
func (mmProtoMessage *mProtoMessageMockProtoMessage) Expect() *mProtoMessageMockProtoMessage {
	if mmProtoMessage.mock.funcProtoMessage != nil {
		mmProtoMessage.mock.t.Fatalf("ProtoMessageMock.ProtoMessage mock is already set by Set")
	}

	if mmProtoMessage.defaultExpectation == nil {
		mmProtoMessage.defaultExpectation = &ProtoMessageMockProtoMessageExpectation{}
	}

	return mmProtoMessage
}

// Inspect accepts an inspector function that has same arguments as the ProtoMessage.ProtoMessage
func (mmProtoMessage *mProtoMessageMockProtoMessage) Inspect(f func()) *mProtoMessageMockProtoMessage {
	if mmProtoMessage.mock.inspectFuncProtoMessage != nil {
		mmProtoMessage.mock.t.Fatalf("Inspect function is already set for ProtoMessageMock.ProtoMessage")
	}

	mmProtoMessage.mock.inspectFuncProtoMessage = f

	return mmProtoMessage
}

// Return sets up results that will be returned by ProtoMessage.ProtoMessage
func (mmProtoMessage *mProtoMessageMockProtoMessage) Return() *ProtoMessageMock {
	if mmProtoMessage.mock.funcProtoMessage != nil {
		mmProtoMessage.mock.t.Fatalf("ProtoMessageMock.ProtoMessage mock is already set by Set")
	}

	if mmProtoMessage.defaultExpectation == nil {
		mmProtoMessage.defaultExpectation = &ProtoMessageMockProtoMessageExpectation{mock: mmProtoMessage.mock}
	}

	mmProtoMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProtoMessage.mock
}

// Set uses given function f to mock the ProtoMessage.ProtoMessage method
func (mmProtoMessage *mProtoMessageMockProtoMessage) Set(f func()) *ProtoMessageMock {
	if mmProtoMessage.defaultExpectation != nil {
		mmProtoMessage.mock.t.Fatalf("Default expectation is already set for the ProtoMessage.ProtoMessage method")
	}

	if len(mmProtoMessage.expectations) > 0 {
		mmProtoMessage.mock.t.Fatalf("Some expectations are already set for the ProtoMessage.ProtoMessage method")
	}

	mmProtoMessage.mock.funcProtoMessage = f
	mmProtoMessage.mock.funcProtoMessageOrigin = minimock.CallerInfo(1)
	return mmProtoMessage.mock
}

// Times sets number of times ProtoMessage.ProtoMessage should be invoked
func (mmProtoMessage *mProtoMessageMockProtoMessage) Times(n uint64) *mProtoMessageMockProtoMessage {
	if n == 0 {
		mmProtoMessage.mock.t.Fatalf("Times of ProtoMessageMock.ProtoMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProtoMessage.expectedInvocations, n)
	mmProtoMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProtoMessage
}

func (mmProtoMessage *mProtoMessageMockProtoMessage) invocationsDone() bool {
	if len(mmProtoMessage.expectations) == 0 && mmProtoMessage.defaultExpectation == nil && mmProtoMessage.mock.funcProtoMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProtoMessage.mock.afterProtoMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProtoMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProtoMessage implements ProtoMessage
func (mmProtoMessage *ProtoMessageMock) ProtoMessage() {
	mm_atomic.AddUint64(&mmProtoMessage.beforeProtoMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmProtoMessage.afterProtoMessageCounter, 1)

	mmProtoMessage.t.Helper()

	if mmProtoMessage.inspectFuncProtoMessage != nil {
		mmProtoMessage.inspectFuncProtoMessage()
	}

	if mmProtoMessage.ProtoMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProtoMessage.ProtoMessageMock.defaultExpectation.Counter, 1)

		return

	}
	if mmProtoMessage.funcProtoMessage != nil {
		mmProtoMessage.funcProtoMessage()
		return
	}
	mmProtoMessage.t.Fatalf("Unexpected call to ProtoMessageMock.ProtoMessage.")

}

// ProtoMessageAfterCounter returns a count of finished ProtoMessageMock.ProtoMessage invocations
func (mmProtoMessage *ProtoMessageMock) ProtoMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProtoMessage.afterProtoMessageCounter)
}

// ProtoMessageBeforeCounter returns a count of ProtoMessageMock.ProtoMessage invocations
func (mmProtoMessage *ProtoMessageMock) ProtoMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProtoMessage.beforeProtoMessageCounter)
}

// MinimockProtoMessageDone returns true if the count of the ProtoMessage invocations corresponds
// the number of defined expectations
func (m *ProtoMessageMock) MinimockProtoMessageDone() bool {
	if m.ProtoMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProtoMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProtoMessageMock.invocationsDone()
}

// MinimockProtoMessageInspect logs each unmet expectation
func (m *ProtoMessageMock) MinimockProtoMessageInspect() {
	for _, e := range m.ProtoMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProtoMessageMock.ProtoMessage")
		}
	}

	afterProtoMessageCounter := mm_atomic.LoadUint64(&m.afterProtoMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProtoMessageMock.defaultExpectation != nil && afterProtoMessageCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.ProtoMessage at\n%s", m.ProtoMessageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProtoMessage != nil && afterProtoMessageCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.ProtoMessage at\n%s", m.funcProtoMessageOrigin)
	}

	if !m.ProtoMessageMock.invocationsDone() && afterProtoMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ProtoMessageMock.ProtoMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProtoMessageMock.expectedInvocations), m.ProtoMessageMock.expectedInvocationsOrigin, afterProtoMessageCounter)
	}
}

type mProtoMessageMockProtoReflect struct {
	optional           bool
	mock               *ProtoMessageMock
	defaultExpectation *ProtoMessageMockProtoReflectExpectation
	expectations       []*ProtoMessageMockProtoReflectExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProtoMessageMockProtoReflectExpectation specifies expectation struct of the ProtoMessage.ProtoReflect
type ProtoMessageMockProtoReflectExpectation struct {
	mock *ProtoMessageMock

	results      *ProtoMessageMockProtoReflectResults
	returnOrigin string
	Counter      uint64
}

// ProtoMessageMockProtoReflectResults contains results of the ProtoMessage.ProtoReflect
type ProtoMessageMockProtoReflectResults struct {
	m1 protoreflect.Message
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProtoReflect *mProtoMessageMockProtoReflect) Optional() *mProtoMessageMockProtoReflect {
	mmProtoReflect.optional = true
	return mmProtoReflect
}

// Expect sets up expected params for ProtoMessage.ProtoReflect
func (mmProtoReflect *mProtoMessageMockProtoReflect) Expect() *mProtoMessageMockProtoReflect {
	if mmProtoReflect.mock.funcProtoReflect != nil {
		mmProtoReflect.mock.t.Fatalf("ProtoMessageMock.ProtoReflect mock is already set by Set")
	}

	if mmProtoReflect.defaultExpectation == nil {
		mmProtoReflect.defaultExpectation = &ProtoMessageMockProtoReflectExpectation{}
	}

	return mmProtoReflect
}

// Inspect accepts an inspector function that has same arguments as the ProtoMessage.ProtoReflect
func (mmProtoReflect *mProtoMessageMockProtoReflect) Inspect(f func()) *mProtoMessageMockProtoReflect {
	if mmProtoReflect.mock.inspectFuncProtoReflect != nil {
		mmProtoReflect.mock.t.Fatalf("Inspect function is already set for ProtoMessageMock.ProtoReflect")
	}

	mmProtoReflect.mock.inspectFuncProtoReflect = f

	return mmProtoReflect
}

// Return sets up results that will be returned by ProtoMessage.ProtoReflect
func (mmProtoReflect *mProtoMessageMockProtoReflect) Return(m1 protoreflect.Message) *ProtoMessageMock {
	if mmProtoReflect.mock.funcProtoReflect != nil {
		mmProtoReflect.mock.t.Fatalf("ProtoMessageMock.ProtoReflect mock is already set by Set")
	}

	if mmProtoReflect.defaultExpectation == nil {
		mmProtoReflect.defaultExpectation = &ProtoMessageMockProtoReflectExpectation{mock: mmProtoReflect.mock}
	}
	mmProtoReflect.defaultExpectation.results = &ProtoMessageMockProtoReflectResults{m1}
	mmProtoReflect.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProtoReflect.mock
}

// Set uses given function f to mock the ProtoMessage.ProtoReflect method
func (mmProtoReflect *mProtoMessageMockProtoReflect) Set(f func() (m1 protoreflect.Message)) *ProtoMessageMock {
	if mmProtoReflect.defaultExpectation != nil {
		mmProtoReflect.mock.t.Fatalf("Default expectation is already set for the ProtoMessage.ProtoReflect method")
	}

	if len(mmProtoReflect.expectations) > 0 {
		mmProtoReflect.mock.t.Fatalf("Some expectations are already set for the ProtoMessage.ProtoReflect method")
	}

	mmProtoReflect.mock.funcProtoReflect = f
	mmProtoReflect.mock.funcProtoReflectOrigin = minimock.CallerInfo(1)
	return mmProtoReflect.mock
}

// Times sets number of times ProtoMessage.ProtoReflect should be invoked
func (mmProtoReflect *mProtoMessageMockProtoReflect) Times(n uint64) *mProtoMessageMockProtoReflect {
	if n == 0 {
		mmProtoReflect.mock.t.Fatalf("Times of ProtoMessageMock.ProtoReflect mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProtoReflect.expectedInvocations, n)
	mmProtoReflect.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProtoReflect
}

func (mmProtoReflect *mProtoMessageMockProtoReflect) invocationsDone() bool {
	if len(mmProtoReflect.expectations) == 0 && mmProtoReflect.defaultExpectation == nil && mmProtoReflect.mock.funcProtoReflect == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProtoReflect.mock.afterProtoReflectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProtoReflect.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProtoReflect implements ProtoMessage
func (mmProtoReflect *ProtoMessageMock) ProtoReflect() (m1 protoreflect.Message) {
	mm_atomic.AddUint64(&mmProtoReflect.beforeProtoReflectCounter, 1)
	defer mm_atomic.AddUint64(&mmProtoReflect.afterProtoReflectCounter, 1)

	mmProtoReflect.t.Helper()

	if mmProtoReflect.inspectFuncProtoReflect != nil {
		mmProtoReflect.inspectFuncProtoReflect()
	}

	if mmProtoReflect.ProtoReflectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProtoReflect.ProtoReflectMock.defaultExpectation.Counter, 1)

		mm_results := mmProtoReflect.ProtoReflectMock.defaultExpectation.results
		if mm_results == nil {
			mmProtoReflect.t.Fatal("No results are set for the ProtoMessageMock.ProtoReflect")
		}
		return (*mm_results).m1
	}
	if mmProtoReflect.funcProtoReflect != nil {
		return mmProtoReflect.funcProtoReflect()
	}
	mmProtoReflect.t.Fatalf("Unexpected call to ProtoMessageMock.ProtoReflect.")
	return
}

// ProtoReflectAfterCounter returns a count of finished ProtoMessageMock.ProtoReflect invocations
func (mmProtoReflect *ProtoMessageMock) ProtoReflectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProtoReflect.afterProtoReflectCounter)
}

// ProtoReflectBeforeCounter returns a count of ProtoMessageMock.ProtoReflect invocations
func (mmProtoReflect *ProtoMessageMock) ProtoReflectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProtoReflect.beforeProtoReflectCounter)
}

// MinimockProtoReflectDone returns true if the count of the ProtoReflect invocations corresponds
// the number of defined expectations
func (m *ProtoMessageMock) MinimockProtoReflectDone() bool {
	if m.ProtoReflectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProtoReflectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProtoReflectMock.invocationsDone()
}

// MinimockProtoReflectInspect logs each unmet expectation
func (m *ProtoMessageMock) MinimockProtoReflectInspect() {
	for _, e := range m.ProtoReflectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProtoMessageMock.ProtoReflect")
		}
	}

	afterProtoReflectCounter := mm_atomic.LoadUint64(&m.afterProtoReflectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProtoReflectMock.defaultExpectation != nil && afterProtoReflectCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.ProtoReflect at\n%s", m.ProtoReflectMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProtoReflect != nil && afterProtoReflectCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.ProtoReflect at\n%s", m.funcProtoReflectOrigin)
	}

	if !m.ProtoReflectMock.invocationsDone() && afterProtoReflectCounter > 0 {
		m.t.Errorf("Expected %d calls to ProtoMessageMock.ProtoReflect at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProtoReflectMock.expectedInvocations), m.ProtoReflectMock.expectedInvocationsOrigin, afterProtoReflectCounter)
	}
}

type mProtoMessageMockReset struct {
	optional           bool
	mock               *ProtoMessageMock
	defaultExpectation *ProtoMessageMockResetExpectation
	expectations       []*ProtoMessageMockResetExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProtoMessageMockResetExpectation specifies expectation struct of the ProtoMessage.Reset
type ProtoMessageMockResetExpectation struct {
	mock *ProtoMessageMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReset *mProtoMessageMockReset) Optional() *mProtoMessageMockReset {
	mmReset.optional = true
	return mmReset
}

// Expect sets up expected params for ProtoMessage.Reset
func (mmReset *mProtoMessageMockReset) Expect() *mProtoMessageMockReset {
	if mmReset.mock.funcReset != nil {
		mmReset.mock.t.Fatalf("ProtoMessageMock.Reset mock is already set by Set")
	}

	if mmReset.defaultExpectation == nil {
		mmReset.defaultExpectation = &ProtoMessageMockResetExpectation{}
	}

	return mmReset
}

// Inspect accepts an inspector function that has same arguments as the ProtoMessage.Reset
func (mmReset *mProtoMessageMockReset) Inspect(f func()) *mProtoMessageMockReset {
	if mmReset.mock.inspectFuncReset != nil {
		mmReset.mock.t.Fatalf("Inspect function is already set for ProtoMessageMock.Reset")
	}

	mmReset.mock.inspectFuncReset = f

	return mmReset
}

// Return sets up results that will be returned by ProtoMessage.Reset
func (mmReset *mProtoMessageMockReset) Return() *ProtoMessageMock {
	if mmReset.mock.funcReset != nil {
		mmReset.mock.t.Fatalf("ProtoMessageMock.Reset mock is already set by Set")
	}

	if mmReset.defaultExpectation == nil {
		mmReset.defaultExpectation = &ProtoMessageMockResetExpectation{mock: mmReset.mock}
	}

	mmReset.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReset.mock
}

// Set uses given function f to mock the ProtoMessage.Reset method
func (mmReset *mProtoMessageMockReset) Set(f func()) *ProtoMessageMock {
	if mmReset.defaultExpectation != nil {
		mmReset.mock.t.Fatalf("Default expectation is already set for the ProtoMessage.Reset method")
	}

	if len(mmReset.expectations) > 0 {
		mmReset.mock.t.Fatalf("Some expectations are already set for the ProtoMessage.Reset method")
	}

	mmReset.mock.funcReset = f
	mmReset.mock.funcResetOrigin = minimock.CallerInfo(1)
	return mmReset.mock
}

// Times sets number of times ProtoMessage.Reset should be invoked
func (mmReset *mProtoMessageMockReset) Times(n uint64) *mProtoMessageMockReset {
	if n == 0 {
		mmReset.mock.t.Fatalf("Times of ProtoMessageMock.Reset mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReset.expectedInvocations, n)
	mmReset.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReset
}

func (mmReset *mProtoMessageMockReset) invocationsDone() bool {
	if len(mmReset.expectations) == 0 && mmReset.defaultExpectation == nil && mmReset.mock.funcReset == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReset.mock.afterResetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReset.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reset implements ProtoMessage
func (mmReset *ProtoMessageMock) Reset() {
	mm_atomic.AddUint64(&mmReset.beforeResetCounter, 1)
	defer mm_atomic.AddUint64(&mmReset.afterResetCounter, 1)

	mmReset.t.Helper()

	if mmReset.inspectFuncReset != nil {
		mmReset.inspectFuncReset()
	}

	if mmReset.ResetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReset.ResetMock.defaultExpectation.Counter, 1)

		return

	}
	if mmReset.funcReset != nil {
		mmReset.funcReset()
		return
	}
	mmReset.t.Fatalf("Unexpected call to ProtoMessageMock.Reset.")

}

// ResetAfterCounter returns a count of finished ProtoMessageMock.Reset invocations
func (mmReset *ProtoMessageMock) ResetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReset.afterResetCounter)
}

// ResetBeforeCounter returns a count of ProtoMessageMock.Reset invocations
func (mmReset *ProtoMessageMock) ResetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReset.beforeResetCounter)
}

// MinimockResetDone returns true if the count of the Reset invocations corresponds
// the number of defined expectations
func (m *ProtoMessageMock) MinimockResetDone() bool {
	if m.ResetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ResetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ResetMock.invocationsDone()
}

// MinimockResetInspect logs each unmet expectation
func (m *ProtoMessageMock) MinimockResetInspect() {
	for _, e := range m.ResetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProtoMessageMock.Reset")
		}
	}

	afterResetCounter := mm_atomic.LoadUint64(&m.afterResetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ResetMock.defaultExpectation != nil && afterResetCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.Reset at\n%s", m.ResetMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReset != nil && afterResetCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.Reset at\n%s", m.funcResetOrigin)
	}

	if !m.ResetMock.invocationsDone() && afterResetCounter > 0 {
		m.t.Errorf("Expected %d calls to ProtoMessageMock.Reset at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ResetMock.expectedInvocations), m.ResetMock.expectedInvocationsOrigin, afterResetCounter)
	}
}

type mProtoMessageMockString struct {
	optional           bool
	mock               *ProtoMessageMock
	defaultExpectation *ProtoMessageMockStringExpectation
	expectations       []*ProtoMessageMockStringExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProtoMessageMockStringExpectation specifies expectation struct of the ProtoMessage.String
type ProtoMessageMockStringExpectation struct {
	mock *ProtoMessageMock

	results      *ProtoMessageMockStringResults
	returnOrigin string
	Counter      uint64
}

// ProtoMessageMockStringResults contains results of the ProtoMessage.String
type ProtoMessageMockStringResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmString *mProtoMessageMockString) Optional() *mProtoMessageMockString {
	mmString.optional = true
	return mmString
}

// Expect sets up expected params for ProtoMessage.String
func (mmString *mProtoMessageMockString) Expect() *mProtoMessageMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("ProtoMessageMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &ProtoMessageMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the ProtoMessage.String
func (mmString *mProtoMessageMockString) Inspect(f func()) *mProtoMessageMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for ProtoMessageMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by ProtoMessage.String
func (mmString *mProtoMessageMockString) Return(s1 string) *ProtoMessageMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("ProtoMessageMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &ProtoMessageMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &ProtoMessageMockStringResults{s1}
	mmString.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Set uses given function f to mock the ProtoMessage.String method
func (mmString *mProtoMessageMockString) Set(f func() (s1 string)) *ProtoMessageMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the ProtoMessage.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the ProtoMessage.String method")
	}

	mmString.mock.funcString = f
	mmString.mock.funcStringOrigin = minimock.CallerInfo(1)
	return mmString.mock
}

// Times sets number of times ProtoMessage.String should be invoked
func (mmString *mProtoMessageMockString) Times(n uint64) *mProtoMessageMockString {
	if n == 0 {
		mmString.mock.t.Fatalf("Times of ProtoMessageMock.String mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmString.expectedInvocations, n)
	mmString.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmString
}

func (mmString *mProtoMessageMockString) invocationsDone() bool {
	if len(mmString.expectations) == 0 && mmString.defaultExpectation == nil && mmString.mock.funcString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmString.mock.afterStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// String implements ProtoMessage
func (mmString *ProtoMessageMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	mmString.t.Helper()

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the ProtoMessageMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to ProtoMessageMock.String.")
	return
}

// StringAfterCounter returns a count of finished ProtoMessageMock.String invocations
func (mmString *ProtoMessageMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of ProtoMessageMock.String invocations
func (mmString *ProtoMessageMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *ProtoMessageMock) MinimockStringDone() bool {
	if m.StringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StringMock.invocationsDone()
}

// MinimockStringInspect logs each unmet expectation
func (m *ProtoMessageMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProtoMessageMock.String")
		}
	}

	afterStringCounter := mm_atomic.LoadUint64(&m.afterStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.String at\n%s", m.StringMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && afterStringCounter < 1 {
		m.t.Errorf("Expected call to ProtoMessageMock.String at\n%s", m.funcStringOrigin)
	}

	if !m.StringMock.invocationsDone() && afterStringCounter > 0 {
		m.t.Errorf("Expected %d calls to ProtoMessageMock.String at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StringMock.expectedInvocations), m.StringMock.expectedInvocationsOrigin, afterStringCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProtoMessageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockProtoMessageInspect()

			m.MinimockProtoReflectInspect()

			m.MinimockResetInspect()

			m.MinimockStringInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProtoMessageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProtoMessageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockProtoMessageDone() &&
		m.MinimockProtoReflectDone() &&
		m.MinimockResetDone() &&
		m.MinimockStringDone()
}
