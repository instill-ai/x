// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package server

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MarshalerMock implements Marshaler
type MarshalerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcContentType          func(a1 any) (s1 string)
	funcContentTypeOrigin    string
	inspectFuncContentType   func(a1 any)
	afterContentTypeCounter  uint64
	beforeContentTypeCounter uint64
	ContentTypeMock          mMarshalerMockContentType

	funcMarshal          func(a1 any) (ba1 []byte, err error)
	funcMarshalOrigin    string
	inspectFuncMarshal   func(a1 any)
	afterMarshalCounter  uint64
	beforeMarshalCounter uint64
	MarshalMock          mMarshalerMockMarshal

	funcNewDecoder          func(r io.Reader) (d1 Decoder)
	funcNewDecoderOrigin    string
	inspectFuncNewDecoder   func(r io.Reader)
	afterNewDecoderCounter  uint64
	beforeNewDecoderCounter uint64
	NewDecoderMock          mMarshalerMockNewDecoder

	funcNewEncoder          func(w io.Writer) (e1 Encoder)
	funcNewEncoderOrigin    string
	inspectFuncNewEncoder   func(w io.Writer)
	afterNewEncoderCounter  uint64
	beforeNewEncoderCounter uint64
	NewEncoderMock          mMarshalerMockNewEncoder

	funcUnmarshal          func(ba1 []byte, a1 any) (err error)
	funcUnmarshalOrigin    string
	inspectFuncUnmarshal   func(ba1 []byte, a1 any)
	afterUnmarshalCounter  uint64
	beforeUnmarshalCounter uint64
	UnmarshalMock          mMarshalerMockUnmarshal
}

// NewMarshalerMock returns a mock for Marshaler
func NewMarshalerMock(t minimock.Tester) *MarshalerMock {
	m := &MarshalerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContentTypeMock = mMarshalerMockContentType{mock: m}
	m.ContentTypeMock.callArgs = []*MarshalerMockContentTypeParams{}

	m.MarshalMock = mMarshalerMockMarshal{mock: m}
	m.MarshalMock.callArgs = []*MarshalerMockMarshalParams{}

	m.NewDecoderMock = mMarshalerMockNewDecoder{mock: m}
	m.NewDecoderMock.callArgs = []*MarshalerMockNewDecoderParams{}

	m.NewEncoderMock = mMarshalerMockNewEncoder{mock: m}
	m.NewEncoderMock.callArgs = []*MarshalerMockNewEncoderParams{}

	m.UnmarshalMock = mMarshalerMockUnmarshal{mock: m}
	m.UnmarshalMock.callArgs = []*MarshalerMockUnmarshalParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMarshalerMockContentType struct {
	optional           bool
	mock               *MarshalerMock
	defaultExpectation *MarshalerMockContentTypeExpectation
	expectations       []*MarshalerMockContentTypeExpectation

	callArgs []*MarshalerMockContentTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MarshalerMockContentTypeExpectation specifies expectation struct of the Marshaler.ContentType
type MarshalerMockContentTypeExpectation struct {
	mock               *MarshalerMock
	params             *MarshalerMockContentTypeParams
	paramPtrs          *MarshalerMockContentTypeParamPtrs
	expectationOrigins MarshalerMockContentTypeExpectationOrigins
	results            *MarshalerMockContentTypeResults
	returnOrigin       string
	Counter            uint64
}

// MarshalerMockContentTypeParams contains parameters of the Marshaler.ContentType
type MarshalerMockContentTypeParams struct {
	a1 any
}

// MarshalerMockContentTypeParamPtrs contains pointers to parameters of the Marshaler.ContentType
type MarshalerMockContentTypeParamPtrs struct {
	a1 *any
}

// MarshalerMockContentTypeResults contains results of the Marshaler.ContentType
type MarshalerMockContentTypeResults struct {
	s1 string
}

// MarshalerMockContentTypeOrigins contains origins of expectations of the Marshaler.ContentType
type MarshalerMockContentTypeExpectationOrigins struct {
	origin   string
	originA1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmContentType *mMarshalerMockContentType) Optional() *mMarshalerMockContentType {
	mmContentType.optional = true
	return mmContentType
}

// Expect sets up expected params for Marshaler.ContentType
func (mmContentType *mMarshalerMockContentType) Expect(a1 any) *mMarshalerMockContentType {
	if mmContentType.mock.funcContentType != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by Set")
	}

	if mmContentType.defaultExpectation == nil {
		mmContentType.defaultExpectation = &MarshalerMockContentTypeExpectation{}
	}

	if mmContentType.defaultExpectation.paramPtrs != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by ExpectParams functions")
	}

	mmContentType.defaultExpectation.params = &MarshalerMockContentTypeParams{a1}
	mmContentType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmContentType.expectations {
		if minimock.Equal(e.params, mmContentType.defaultExpectation.params) {
			mmContentType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContentType.defaultExpectation.params)
		}
	}

	return mmContentType
}

// ExpectA1Param1 sets up expected param a1 for Marshaler.ContentType
func (mmContentType *mMarshalerMockContentType) ExpectA1Param1(a1 any) *mMarshalerMockContentType {
	if mmContentType.mock.funcContentType != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by Set")
	}

	if mmContentType.defaultExpectation == nil {
		mmContentType.defaultExpectation = &MarshalerMockContentTypeExpectation{}
	}

	if mmContentType.defaultExpectation.params != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by Expect")
	}

	if mmContentType.defaultExpectation.paramPtrs == nil {
		mmContentType.defaultExpectation.paramPtrs = &MarshalerMockContentTypeParamPtrs{}
	}
	mmContentType.defaultExpectation.paramPtrs.a1 = &a1
	mmContentType.defaultExpectation.expectationOrigins.originA1 = minimock.CallerInfo(1)

	return mmContentType
}

// Inspect accepts an inspector function that has same arguments as the Marshaler.ContentType
func (mmContentType *mMarshalerMockContentType) Inspect(f func(a1 any)) *mMarshalerMockContentType {
	if mmContentType.mock.inspectFuncContentType != nil {
		mmContentType.mock.t.Fatalf("Inspect function is already set for MarshalerMock.ContentType")
	}

	mmContentType.mock.inspectFuncContentType = f

	return mmContentType
}

// Return sets up results that will be returned by Marshaler.ContentType
func (mmContentType *mMarshalerMockContentType) Return(s1 string) *MarshalerMock {
	if mmContentType.mock.funcContentType != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by Set")
	}

	if mmContentType.defaultExpectation == nil {
		mmContentType.defaultExpectation = &MarshalerMockContentTypeExpectation{mock: mmContentType.mock}
	}
	mmContentType.defaultExpectation.results = &MarshalerMockContentTypeResults{s1}
	mmContentType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmContentType.mock
}

// Set uses given function f to mock the Marshaler.ContentType method
func (mmContentType *mMarshalerMockContentType) Set(f func(a1 any) (s1 string)) *MarshalerMock {
	if mmContentType.defaultExpectation != nil {
		mmContentType.mock.t.Fatalf("Default expectation is already set for the Marshaler.ContentType method")
	}

	if len(mmContentType.expectations) > 0 {
		mmContentType.mock.t.Fatalf("Some expectations are already set for the Marshaler.ContentType method")
	}

	mmContentType.mock.funcContentType = f
	mmContentType.mock.funcContentTypeOrigin = minimock.CallerInfo(1)
	return mmContentType.mock
}

// When sets expectation for the Marshaler.ContentType which will trigger the result defined by the following
// Then helper
func (mmContentType *mMarshalerMockContentType) When(a1 any) *MarshalerMockContentTypeExpectation {
	if mmContentType.mock.funcContentType != nil {
		mmContentType.mock.t.Fatalf("MarshalerMock.ContentType mock is already set by Set")
	}

	expectation := &MarshalerMockContentTypeExpectation{
		mock:               mmContentType.mock,
		params:             &MarshalerMockContentTypeParams{a1},
		expectationOrigins: MarshalerMockContentTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmContentType.expectations = append(mmContentType.expectations, expectation)
	return expectation
}

// Then sets up Marshaler.ContentType return parameters for the expectation previously defined by the When method
func (e *MarshalerMockContentTypeExpectation) Then(s1 string) *MarshalerMock {
	e.results = &MarshalerMockContentTypeResults{s1}
	return e.mock
}

// Times sets number of times Marshaler.ContentType should be invoked
func (mmContentType *mMarshalerMockContentType) Times(n uint64) *mMarshalerMockContentType {
	if n == 0 {
		mmContentType.mock.t.Fatalf("Times of MarshalerMock.ContentType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmContentType.expectedInvocations, n)
	mmContentType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmContentType
}

func (mmContentType *mMarshalerMockContentType) invocationsDone() bool {
	if len(mmContentType.expectations) == 0 && mmContentType.defaultExpectation == nil && mmContentType.mock.funcContentType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmContentType.mock.afterContentTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmContentType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ContentType implements Marshaler
func (mmContentType *MarshalerMock) ContentType(a1 any) (s1 string) {
	mm_atomic.AddUint64(&mmContentType.beforeContentTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmContentType.afterContentTypeCounter, 1)

	mmContentType.t.Helper()

	if mmContentType.inspectFuncContentType != nil {
		mmContentType.inspectFuncContentType(a1)
	}

	mm_params := MarshalerMockContentTypeParams{a1}

	// Record call args
	mmContentType.ContentTypeMock.mutex.Lock()
	mmContentType.ContentTypeMock.callArgs = append(mmContentType.ContentTypeMock.callArgs, &mm_params)
	mmContentType.ContentTypeMock.mutex.Unlock()

	for _, e := range mmContentType.ContentTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmContentType.ContentTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContentType.ContentTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmContentType.ContentTypeMock.defaultExpectation.params
		mm_want_ptrs := mmContentType.ContentTypeMock.defaultExpectation.paramPtrs

		mm_got := MarshalerMockContentTypeParams{a1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.a1 != nil && !minimock.Equal(*mm_want_ptrs.a1, mm_got.a1) {
				mmContentType.t.Errorf("MarshalerMock.ContentType got unexpected parameter a1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmContentType.ContentTypeMock.defaultExpectation.expectationOrigins.originA1, *mm_want_ptrs.a1, mm_got.a1, minimock.Diff(*mm_want_ptrs.a1, mm_got.a1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContentType.t.Errorf("MarshalerMock.ContentType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmContentType.ContentTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContentType.ContentTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmContentType.t.Fatal("No results are set for the MarshalerMock.ContentType")
		}
		return (*mm_results).s1
	}
	if mmContentType.funcContentType != nil {
		return mmContentType.funcContentType(a1)
	}
	mmContentType.t.Fatalf("Unexpected call to MarshalerMock.ContentType. %v", a1)
	return
}

// ContentTypeAfterCounter returns a count of finished MarshalerMock.ContentType invocations
func (mmContentType *MarshalerMock) ContentTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContentType.afterContentTypeCounter)
}

// ContentTypeBeforeCounter returns a count of MarshalerMock.ContentType invocations
func (mmContentType *MarshalerMock) ContentTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContentType.beforeContentTypeCounter)
}

// Calls returns a list of arguments used in each call to MarshalerMock.ContentType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContentType *mMarshalerMockContentType) Calls() []*MarshalerMockContentTypeParams {
	mmContentType.mutex.RLock()

	argCopy := make([]*MarshalerMockContentTypeParams, len(mmContentType.callArgs))
	copy(argCopy, mmContentType.callArgs)

	mmContentType.mutex.RUnlock()

	return argCopy
}

// MinimockContentTypeDone returns true if the count of the ContentType invocations corresponds
// the number of defined expectations
func (m *MarshalerMock) MinimockContentTypeDone() bool {
	if m.ContentTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ContentTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ContentTypeMock.invocationsDone()
}

// MinimockContentTypeInspect logs each unmet expectation
func (m *MarshalerMock) MinimockContentTypeInspect() {
	for _, e := range m.ContentTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarshalerMock.ContentType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterContentTypeCounter := mm_atomic.LoadUint64(&m.afterContentTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ContentTypeMock.defaultExpectation != nil && afterContentTypeCounter < 1 {
		if m.ContentTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MarshalerMock.ContentType at\n%s", m.ContentTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MarshalerMock.ContentType at\n%s with params: %#v", m.ContentTypeMock.defaultExpectation.expectationOrigins.origin, *m.ContentTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContentType != nil && afterContentTypeCounter < 1 {
		m.t.Errorf("Expected call to MarshalerMock.ContentType at\n%s", m.funcContentTypeOrigin)
	}

	if !m.ContentTypeMock.invocationsDone() && afterContentTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to MarshalerMock.ContentType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ContentTypeMock.expectedInvocations), m.ContentTypeMock.expectedInvocationsOrigin, afterContentTypeCounter)
	}
}

type mMarshalerMockMarshal struct {
	optional           bool
	mock               *MarshalerMock
	defaultExpectation *MarshalerMockMarshalExpectation
	expectations       []*MarshalerMockMarshalExpectation

	callArgs []*MarshalerMockMarshalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MarshalerMockMarshalExpectation specifies expectation struct of the Marshaler.Marshal
type MarshalerMockMarshalExpectation struct {
	mock               *MarshalerMock
	params             *MarshalerMockMarshalParams
	paramPtrs          *MarshalerMockMarshalParamPtrs
	expectationOrigins MarshalerMockMarshalExpectationOrigins
	results            *MarshalerMockMarshalResults
	returnOrigin       string
	Counter            uint64
}

// MarshalerMockMarshalParams contains parameters of the Marshaler.Marshal
type MarshalerMockMarshalParams struct {
	a1 any
}

// MarshalerMockMarshalParamPtrs contains pointers to parameters of the Marshaler.Marshal
type MarshalerMockMarshalParamPtrs struct {
	a1 *any
}

// MarshalerMockMarshalResults contains results of the Marshaler.Marshal
type MarshalerMockMarshalResults struct {
	ba1 []byte
	err error
}

// MarshalerMockMarshalOrigins contains origins of expectations of the Marshaler.Marshal
type MarshalerMockMarshalExpectationOrigins struct {
	origin   string
	originA1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarshal *mMarshalerMockMarshal) Optional() *mMarshalerMockMarshal {
	mmMarshal.optional = true
	return mmMarshal
}

// Expect sets up expected params for Marshaler.Marshal
func (mmMarshal *mMarshalerMockMarshal) Expect(a1 any) *mMarshalerMockMarshal {
	if mmMarshal.mock.funcMarshal != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by Set")
	}

	if mmMarshal.defaultExpectation == nil {
		mmMarshal.defaultExpectation = &MarshalerMockMarshalExpectation{}
	}

	if mmMarshal.defaultExpectation.paramPtrs != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by ExpectParams functions")
	}

	mmMarshal.defaultExpectation.params = &MarshalerMockMarshalParams{a1}
	mmMarshal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarshal.expectations {
		if minimock.Equal(e.params, mmMarshal.defaultExpectation.params) {
			mmMarshal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarshal.defaultExpectation.params)
		}
	}

	return mmMarshal
}

// ExpectA1Param1 sets up expected param a1 for Marshaler.Marshal
func (mmMarshal *mMarshalerMockMarshal) ExpectA1Param1(a1 any) *mMarshalerMockMarshal {
	if mmMarshal.mock.funcMarshal != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by Set")
	}

	if mmMarshal.defaultExpectation == nil {
		mmMarshal.defaultExpectation = &MarshalerMockMarshalExpectation{}
	}

	if mmMarshal.defaultExpectation.params != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by Expect")
	}

	if mmMarshal.defaultExpectation.paramPtrs == nil {
		mmMarshal.defaultExpectation.paramPtrs = &MarshalerMockMarshalParamPtrs{}
	}
	mmMarshal.defaultExpectation.paramPtrs.a1 = &a1
	mmMarshal.defaultExpectation.expectationOrigins.originA1 = minimock.CallerInfo(1)

	return mmMarshal
}

// Inspect accepts an inspector function that has same arguments as the Marshaler.Marshal
func (mmMarshal *mMarshalerMockMarshal) Inspect(f func(a1 any)) *mMarshalerMockMarshal {
	if mmMarshal.mock.inspectFuncMarshal != nil {
		mmMarshal.mock.t.Fatalf("Inspect function is already set for MarshalerMock.Marshal")
	}

	mmMarshal.mock.inspectFuncMarshal = f

	return mmMarshal
}

// Return sets up results that will be returned by Marshaler.Marshal
func (mmMarshal *mMarshalerMockMarshal) Return(ba1 []byte, err error) *MarshalerMock {
	if mmMarshal.mock.funcMarshal != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by Set")
	}

	if mmMarshal.defaultExpectation == nil {
		mmMarshal.defaultExpectation = &MarshalerMockMarshalExpectation{mock: mmMarshal.mock}
	}
	mmMarshal.defaultExpectation.results = &MarshalerMockMarshalResults{ba1, err}
	mmMarshal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarshal.mock
}

// Set uses given function f to mock the Marshaler.Marshal method
func (mmMarshal *mMarshalerMockMarshal) Set(f func(a1 any) (ba1 []byte, err error)) *MarshalerMock {
	if mmMarshal.defaultExpectation != nil {
		mmMarshal.mock.t.Fatalf("Default expectation is already set for the Marshaler.Marshal method")
	}

	if len(mmMarshal.expectations) > 0 {
		mmMarshal.mock.t.Fatalf("Some expectations are already set for the Marshaler.Marshal method")
	}

	mmMarshal.mock.funcMarshal = f
	mmMarshal.mock.funcMarshalOrigin = minimock.CallerInfo(1)
	return mmMarshal.mock
}

// When sets expectation for the Marshaler.Marshal which will trigger the result defined by the following
// Then helper
func (mmMarshal *mMarshalerMockMarshal) When(a1 any) *MarshalerMockMarshalExpectation {
	if mmMarshal.mock.funcMarshal != nil {
		mmMarshal.mock.t.Fatalf("MarshalerMock.Marshal mock is already set by Set")
	}

	expectation := &MarshalerMockMarshalExpectation{
		mock:               mmMarshal.mock,
		params:             &MarshalerMockMarshalParams{a1},
		expectationOrigins: MarshalerMockMarshalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarshal.expectations = append(mmMarshal.expectations, expectation)
	return expectation
}

// Then sets up Marshaler.Marshal return parameters for the expectation previously defined by the When method
func (e *MarshalerMockMarshalExpectation) Then(ba1 []byte, err error) *MarshalerMock {
	e.results = &MarshalerMockMarshalResults{ba1, err}
	return e.mock
}

// Times sets number of times Marshaler.Marshal should be invoked
func (mmMarshal *mMarshalerMockMarshal) Times(n uint64) *mMarshalerMockMarshal {
	if n == 0 {
		mmMarshal.mock.t.Fatalf("Times of MarshalerMock.Marshal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarshal.expectedInvocations, n)
	mmMarshal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarshal
}

func (mmMarshal *mMarshalerMockMarshal) invocationsDone() bool {
	if len(mmMarshal.expectations) == 0 && mmMarshal.defaultExpectation == nil && mmMarshal.mock.funcMarshal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarshal.mock.afterMarshalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarshal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Marshal implements Marshaler
func (mmMarshal *MarshalerMock) Marshal(a1 any) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmMarshal.beforeMarshalCounter, 1)
	defer mm_atomic.AddUint64(&mmMarshal.afterMarshalCounter, 1)

	mmMarshal.t.Helper()

	if mmMarshal.inspectFuncMarshal != nil {
		mmMarshal.inspectFuncMarshal(a1)
	}

	mm_params := MarshalerMockMarshalParams{a1}

	// Record call args
	mmMarshal.MarshalMock.mutex.Lock()
	mmMarshal.MarshalMock.callArgs = append(mmMarshal.MarshalMock.callArgs, &mm_params)
	mmMarshal.MarshalMock.mutex.Unlock()

	for _, e := range mmMarshal.MarshalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmMarshal.MarshalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarshal.MarshalMock.defaultExpectation.Counter, 1)
		mm_want := mmMarshal.MarshalMock.defaultExpectation.params
		mm_want_ptrs := mmMarshal.MarshalMock.defaultExpectation.paramPtrs

		mm_got := MarshalerMockMarshalParams{a1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.a1 != nil && !minimock.Equal(*mm_want_ptrs.a1, mm_got.a1) {
				mmMarshal.t.Errorf("MarshalerMock.Marshal got unexpected parameter a1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarshal.MarshalMock.defaultExpectation.expectationOrigins.originA1, *mm_want_ptrs.a1, mm_got.a1, minimock.Diff(*mm_want_ptrs.a1, mm_got.a1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarshal.t.Errorf("MarshalerMock.Marshal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarshal.MarshalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarshal.MarshalMock.defaultExpectation.results
		if mm_results == nil {
			mmMarshal.t.Fatal("No results are set for the MarshalerMock.Marshal")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmMarshal.funcMarshal != nil {
		return mmMarshal.funcMarshal(a1)
	}
	mmMarshal.t.Fatalf("Unexpected call to MarshalerMock.Marshal. %v", a1)
	return
}

// MarshalAfterCounter returns a count of finished MarshalerMock.Marshal invocations
func (mmMarshal *MarshalerMock) MarshalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarshal.afterMarshalCounter)
}

// MarshalBeforeCounter returns a count of MarshalerMock.Marshal invocations
func (mmMarshal *MarshalerMock) MarshalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarshal.beforeMarshalCounter)
}

// Calls returns a list of arguments used in each call to MarshalerMock.Marshal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarshal *mMarshalerMockMarshal) Calls() []*MarshalerMockMarshalParams {
	mmMarshal.mutex.RLock()

	argCopy := make([]*MarshalerMockMarshalParams, len(mmMarshal.callArgs))
	copy(argCopy, mmMarshal.callArgs)

	mmMarshal.mutex.RUnlock()

	return argCopy
}

// MinimockMarshalDone returns true if the count of the Marshal invocations corresponds
// the number of defined expectations
func (m *MarshalerMock) MinimockMarshalDone() bool {
	if m.MarshalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarshalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarshalMock.invocationsDone()
}

// MinimockMarshalInspect logs each unmet expectation
func (m *MarshalerMock) MinimockMarshalInspect() {
	for _, e := range m.MarshalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarshalerMock.Marshal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarshalCounter := mm_atomic.LoadUint64(&m.afterMarshalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarshalMock.defaultExpectation != nil && afterMarshalCounter < 1 {
		if m.MarshalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MarshalerMock.Marshal at\n%s", m.MarshalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MarshalerMock.Marshal at\n%s with params: %#v", m.MarshalMock.defaultExpectation.expectationOrigins.origin, *m.MarshalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarshal != nil && afterMarshalCounter < 1 {
		m.t.Errorf("Expected call to MarshalerMock.Marshal at\n%s", m.funcMarshalOrigin)
	}

	if !m.MarshalMock.invocationsDone() && afterMarshalCounter > 0 {
		m.t.Errorf("Expected %d calls to MarshalerMock.Marshal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarshalMock.expectedInvocations), m.MarshalMock.expectedInvocationsOrigin, afterMarshalCounter)
	}
}

type mMarshalerMockNewDecoder struct {
	optional           bool
	mock               *MarshalerMock
	defaultExpectation *MarshalerMockNewDecoderExpectation
	expectations       []*MarshalerMockNewDecoderExpectation

	callArgs []*MarshalerMockNewDecoderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MarshalerMockNewDecoderExpectation specifies expectation struct of the Marshaler.NewDecoder
type MarshalerMockNewDecoderExpectation struct {
	mock               *MarshalerMock
	params             *MarshalerMockNewDecoderParams
	paramPtrs          *MarshalerMockNewDecoderParamPtrs
	expectationOrigins MarshalerMockNewDecoderExpectationOrigins
	results            *MarshalerMockNewDecoderResults
	returnOrigin       string
	Counter            uint64
}

// MarshalerMockNewDecoderParams contains parameters of the Marshaler.NewDecoder
type MarshalerMockNewDecoderParams struct {
	r io.Reader
}

// MarshalerMockNewDecoderParamPtrs contains pointers to parameters of the Marshaler.NewDecoder
type MarshalerMockNewDecoderParamPtrs struct {
	r *io.Reader
}

// MarshalerMockNewDecoderResults contains results of the Marshaler.NewDecoder
type MarshalerMockNewDecoderResults struct {
	d1 Decoder
}

// MarshalerMockNewDecoderOrigins contains origins of expectations of the Marshaler.NewDecoder
type MarshalerMockNewDecoderExpectationOrigins struct {
	origin  string
	originR string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewDecoder *mMarshalerMockNewDecoder) Optional() *mMarshalerMockNewDecoder {
	mmNewDecoder.optional = true
	return mmNewDecoder
}

// Expect sets up expected params for Marshaler.NewDecoder
func (mmNewDecoder *mMarshalerMockNewDecoder) Expect(r io.Reader) *mMarshalerMockNewDecoder {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by Set")
	}

	if mmNewDecoder.defaultExpectation == nil {
		mmNewDecoder.defaultExpectation = &MarshalerMockNewDecoderExpectation{}
	}

	if mmNewDecoder.defaultExpectation.paramPtrs != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by ExpectParams functions")
	}

	mmNewDecoder.defaultExpectation.params = &MarshalerMockNewDecoderParams{r}
	mmNewDecoder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewDecoder.expectations {
		if minimock.Equal(e.params, mmNewDecoder.defaultExpectation.params) {
			mmNewDecoder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewDecoder.defaultExpectation.params)
		}
	}

	return mmNewDecoder
}

// ExpectRParam1 sets up expected param r for Marshaler.NewDecoder
func (mmNewDecoder *mMarshalerMockNewDecoder) ExpectRParam1(r io.Reader) *mMarshalerMockNewDecoder {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by Set")
	}

	if mmNewDecoder.defaultExpectation == nil {
		mmNewDecoder.defaultExpectation = &MarshalerMockNewDecoderExpectation{}
	}

	if mmNewDecoder.defaultExpectation.params != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by Expect")
	}

	if mmNewDecoder.defaultExpectation.paramPtrs == nil {
		mmNewDecoder.defaultExpectation.paramPtrs = &MarshalerMockNewDecoderParamPtrs{}
	}
	mmNewDecoder.defaultExpectation.paramPtrs.r = &r
	mmNewDecoder.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmNewDecoder
}

// Inspect accepts an inspector function that has same arguments as the Marshaler.NewDecoder
func (mmNewDecoder *mMarshalerMockNewDecoder) Inspect(f func(r io.Reader)) *mMarshalerMockNewDecoder {
	if mmNewDecoder.mock.inspectFuncNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("Inspect function is already set for MarshalerMock.NewDecoder")
	}

	mmNewDecoder.mock.inspectFuncNewDecoder = f

	return mmNewDecoder
}

// Return sets up results that will be returned by Marshaler.NewDecoder
func (mmNewDecoder *mMarshalerMockNewDecoder) Return(d1 Decoder) *MarshalerMock {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by Set")
	}

	if mmNewDecoder.defaultExpectation == nil {
		mmNewDecoder.defaultExpectation = &MarshalerMockNewDecoderExpectation{mock: mmNewDecoder.mock}
	}
	mmNewDecoder.defaultExpectation.results = &MarshalerMockNewDecoderResults{d1}
	mmNewDecoder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewDecoder.mock
}

// Set uses given function f to mock the Marshaler.NewDecoder method
func (mmNewDecoder *mMarshalerMockNewDecoder) Set(f func(r io.Reader) (d1 Decoder)) *MarshalerMock {
	if mmNewDecoder.defaultExpectation != nil {
		mmNewDecoder.mock.t.Fatalf("Default expectation is already set for the Marshaler.NewDecoder method")
	}

	if len(mmNewDecoder.expectations) > 0 {
		mmNewDecoder.mock.t.Fatalf("Some expectations are already set for the Marshaler.NewDecoder method")
	}

	mmNewDecoder.mock.funcNewDecoder = f
	mmNewDecoder.mock.funcNewDecoderOrigin = minimock.CallerInfo(1)
	return mmNewDecoder.mock
}

// When sets expectation for the Marshaler.NewDecoder which will trigger the result defined by the following
// Then helper
func (mmNewDecoder *mMarshalerMockNewDecoder) When(r io.Reader) *MarshalerMockNewDecoderExpectation {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("MarshalerMock.NewDecoder mock is already set by Set")
	}

	expectation := &MarshalerMockNewDecoderExpectation{
		mock:               mmNewDecoder.mock,
		params:             &MarshalerMockNewDecoderParams{r},
		expectationOrigins: MarshalerMockNewDecoderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewDecoder.expectations = append(mmNewDecoder.expectations, expectation)
	return expectation
}

// Then sets up Marshaler.NewDecoder return parameters for the expectation previously defined by the When method
func (e *MarshalerMockNewDecoderExpectation) Then(d1 Decoder) *MarshalerMock {
	e.results = &MarshalerMockNewDecoderResults{d1}
	return e.mock
}

// Times sets number of times Marshaler.NewDecoder should be invoked
func (mmNewDecoder *mMarshalerMockNewDecoder) Times(n uint64) *mMarshalerMockNewDecoder {
	if n == 0 {
		mmNewDecoder.mock.t.Fatalf("Times of MarshalerMock.NewDecoder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewDecoder.expectedInvocations, n)
	mmNewDecoder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewDecoder
}

func (mmNewDecoder *mMarshalerMockNewDecoder) invocationsDone() bool {
	if len(mmNewDecoder.expectations) == 0 && mmNewDecoder.defaultExpectation == nil && mmNewDecoder.mock.funcNewDecoder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewDecoder.mock.afterNewDecoderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewDecoder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewDecoder implements Marshaler
func (mmNewDecoder *MarshalerMock) NewDecoder(r io.Reader) (d1 Decoder) {
	mm_atomic.AddUint64(&mmNewDecoder.beforeNewDecoderCounter, 1)
	defer mm_atomic.AddUint64(&mmNewDecoder.afterNewDecoderCounter, 1)

	mmNewDecoder.t.Helper()

	if mmNewDecoder.inspectFuncNewDecoder != nil {
		mmNewDecoder.inspectFuncNewDecoder(r)
	}

	mm_params := MarshalerMockNewDecoderParams{r}

	// Record call args
	mmNewDecoder.NewDecoderMock.mutex.Lock()
	mmNewDecoder.NewDecoderMock.callArgs = append(mmNewDecoder.NewDecoderMock.callArgs, &mm_params)
	mmNewDecoder.NewDecoderMock.mutex.Unlock()

	for _, e := range mmNewDecoder.NewDecoderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmNewDecoder.NewDecoderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewDecoder.NewDecoderMock.defaultExpectation.Counter, 1)
		mm_want := mmNewDecoder.NewDecoderMock.defaultExpectation.params
		mm_want_ptrs := mmNewDecoder.NewDecoderMock.defaultExpectation.paramPtrs

		mm_got := MarshalerMockNewDecoderParams{r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmNewDecoder.t.Errorf("MarshalerMock.NewDecoder got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewDecoder.NewDecoderMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewDecoder.t.Errorf("MarshalerMock.NewDecoder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewDecoder.NewDecoderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewDecoder.NewDecoderMock.defaultExpectation.results
		if mm_results == nil {
			mmNewDecoder.t.Fatal("No results are set for the MarshalerMock.NewDecoder")
		}
		return (*mm_results).d1
	}
	if mmNewDecoder.funcNewDecoder != nil {
		return mmNewDecoder.funcNewDecoder(r)
	}
	mmNewDecoder.t.Fatalf("Unexpected call to MarshalerMock.NewDecoder. %v", r)
	return
}

// NewDecoderAfterCounter returns a count of finished MarshalerMock.NewDecoder invocations
func (mmNewDecoder *MarshalerMock) NewDecoderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewDecoder.afterNewDecoderCounter)
}

// NewDecoderBeforeCounter returns a count of MarshalerMock.NewDecoder invocations
func (mmNewDecoder *MarshalerMock) NewDecoderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewDecoder.beforeNewDecoderCounter)
}

// Calls returns a list of arguments used in each call to MarshalerMock.NewDecoder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewDecoder *mMarshalerMockNewDecoder) Calls() []*MarshalerMockNewDecoderParams {
	mmNewDecoder.mutex.RLock()

	argCopy := make([]*MarshalerMockNewDecoderParams, len(mmNewDecoder.callArgs))
	copy(argCopy, mmNewDecoder.callArgs)

	mmNewDecoder.mutex.RUnlock()

	return argCopy
}

// MinimockNewDecoderDone returns true if the count of the NewDecoder invocations corresponds
// the number of defined expectations
func (m *MarshalerMock) MinimockNewDecoderDone() bool {
	if m.NewDecoderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewDecoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewDecoderMock.invocationsDone()
}

// MinimockNewDecoderInspect logs each unmet expectation
func (m *MarshalerMock) MinimockNewDecoderInspect() {
	for _, e := range m.NewDecoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarshalerMock.NewDecoder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewDecoderCounter := mm_atomic.LoadUint64(&m.afterNewDecoderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewDecoderMock.defaultExpectation != nil && afterNewDecoderCounter < 1 {
		if m.NewDecoderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MarshalerMock.NewDecoder at\n%s", m.NewDecoderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MarshalerMock.NewDecoder at\n%s with params: %#v", m.NewDecoderMock.defaultExpectation.expectationOrigins.origin, *m.NewDecoderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewDecoder != nil && afterNewDecoderCounter < 1 {
		m.t.Errorf("Expected call to MarshalerMock.NewDecoder at\n%s", m.funcNewDecoderOrigin)
	}

	if !m.NewDecoderMock.invocationsDone() && afterNewDecoderCounter > 0 {
		m.t.Errorf("Expected %d calls to MarshalerMock.NewDecoder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewDecoderMock.expectedInvocations), m.NewDecoderMock.expectedInvocationsOrigin, afterNewDecoderCounter)
	}
}

type mMarshalerMockNewEncoder struct {
	optional           bool
	mock               *MarshalerMock
	defaultExpectation *MarshalerMockNewEncoderExpectation
	expectations       []*MarshalerMockNewEncoderExpectation

	callArgs []*MarshalerMockNewEncoderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MarshalerMockNewEncoderExpectation specifies expectation struct of the Marshaler.NewEncoder
type MarshalerMockNewEncoderExpectation struct {
	mock               *MarshalerMock
	params             *MarshalerMockNewEncoderParams
	paramPtrs          *MarshalerMockNewEncoderParamPtrs
	expectationOrigins MarshalerMockNewEncoderExpectationOrigins
	results            *MarshalerMockNewEncoderResults
	returnOrigin       string
	Counter            uint64
}

// MarshalerMockNewEncoderParams contains parameters of the Marshaler.NewEncoder
type MarshalerMockNewEncoderParams struct {
	w io.Writer
}

// MarshalerMockNewEncoderParamPtrs contains pointers to parameters of the Marshaler.NewEncoder
type MarshalerMockNewEncoderParamPtrs struct {
	w *io.Writer
}

// MarshalerMockNewEncoderResults contains results of the Marshaler.NewEncoder
type MarshalerMockNewEncoderResults struct {
	e1 Encoder
}

// MarshalerMockNewEncoderOrigins contains origins of expectations of the Marshaler.NewEncoder
type MarshalerMockNewEncoderExpectationOrigins struct {
	origin  string
	originW string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewEncoder *mMarshalerMockNewEncoder) Optional() *mMarshalerMockNewEncoder {
	mmNewEncoder.optional = true
	return mmNewEncoder
}

// Expect sets up expected params for Marshaler.NewEncoder
func (mmNewEncoder *mMarshalerMockNewEncoder) Expect(w io.Writer) *mMarshalerMockNewEncoder {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by Set")
	}

	if mmNewEncoder.defaultExpectation == nil {
		mmNewEncoder.defaultExpectation = &MarshalerMockNewEncoderExpectation{}
	}

	if mmNewEncoder.defaultExpectation.paramPtrs != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by ExpectParams functions")
	}

	mmNewEncoder.defaultExpectation.params = &MarshalerMockNewEncoderParams{w}
	mmNewEncoder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewEncoder.expectations {
		if minimock.Equal(e.params, mmNewEncoder.defaultExpectation.params) {
			mmNewEncoder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewEncoder.defaultExpectation.params)
		}
	}

	return mmNewEncoder
}

// ExpectWParam1 sets up expected param w for Marshaler.NewEncoder
func (mmNewEncoder *mMarshalerMockNewEncoder) ExpectWParam1(w io.Writer) *mMarshalerMockNewEncoder {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by Set")
	}

	if mmNewEncoder.defaultExpectation == nil {
		mmNewEncoder.defaultExpectation = &MarshalerMockNewEncoderExpectation{}
	}

	if mmNewEncoder.defaultExpectation.params != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by Expect")
	}

	if mmNewEncoder.defaultExpectation.paramPtrs == nil {
		mmNewEncoder.defaultExpectation.paramPtrs = &MarshalerMockNewEncoderParamPtrs{}
	}
	mmNewEncoder.defaultExpectation.paramPtrs.w = &w
	mmNewEncoder.defaultExpectation.expectationOrigins.originW = minimock.CallerInfo(1)

	return mmNewEncoder
}

// Inspect accepts an inspector function that has same arguments as the Marshaler.NewEncoder
func (mmNewEncoder *mMarshalerMockNewEncoder) Inspect(f func(w io.Writer)) *mMarshalerMockNewEncoder {
	if mmNewEncoder.mock.inspectFuncNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("Inspect function is already set for MarshalerMock.NewEncoder")
	}

	mmNewEncoder.mock.inspectFuncNewEncoder = f

	return mmNewEncoder
}

// Return sets up results that will be returned by Marshaler.NewEncoder
func (mmNewEncoder *mMarshalerMockNewEncoder) Return(e1 Encoder) *MarshalerMock {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by Set")
	}

	if mmNewEncoder.defaultExpectation == nil {
		mmNewEncoder.defaultExpectation = &MarshalerMockNewEncoderExpectation{mock: mmNewEncoder.mock}
	}
	mmNewEncoder.defaultExpectation.results = &MarshalerMockNewEncoderResults{e1}
	mmNewEncoder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewEncoder.mock
}

// Set uses given function f to mock the Marshaler.NewEncoder method
func (mmNewEncoder *mMarshalerMockNewEncoder) Set(f func(w io.Writer) (e1 Encoder)) *MarshalerMock {
	if mmNewEncoder.defaultExpectation != nil {
		mmNewEncoder.mock.t.Fatalf("Default expectation is already set for the Marshaler.NewEncoder method")
	}

	if len(mmNewEncoder.expectations) > 0 {
		mmNewEncoder.mock.t.Fatalf("Some expectations are already set for the Marshaler.NewEncoder method")
	}

	mmNewEncoder.mock.funcNewEncoder = f
	mmNewEncoder.mock.funcNewEncoderOrigin = minimock.CallerInfo(1)
	return mmNewEncoder.mock
}

// When sets expectation for the Marshaler.NewEncoder which will trigger the result defined by the following
// Then helper
func (mmNewEncoder *mMarshalerMockNewEncoder) When(w io.Writer) *MarshalerMockNewEncoderExpectation {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("MarshalerMock.NewEncoder mock is already set by Set")
	}

	expectation := &MarshalerMockNewEncoderExpectation{
		mock:               mmNewEncoder.mock,
		params:             &MarshalerMockNewEncoderParams{w},
		expectationOrigins: MarshalerMockNewEncoderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewEncoder.expectations = append(mmNewEncoder.expectations, expectation)
	return expectation
}

// Then sets up Marshaler.NewEncoder return parameters for the expectation previously defined by the When method
func (e *MarshalerMockNewEncoderExpectation) Then(e1 Encoder) *MarshalerMock {
	e.results = &MarshalerMockNewEncoderResults{e1}
	return e.mock
}

// Times sets number of times Marshaler.NewEncoder should be invoked
func (mmNewEncoder *mMarshalerMockNewEncoder) Times(n uint64) *mMarshalerMockNewEncoder {
	if n == 0 {
		mmNewEncoder.mock.t.Fatalf("Times of MarshalerMock.NewEncoder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewEncoder.expectedInvocations, n)
	mmNewEncoder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewEncoder
}

func (mmNewEncoder *mMarshalerMockNewEncoder) invocationsDone() bool {
	if len(mmNewEncoder.expectations) == 0 && mmNewEncoder.defaultExpectation == nil && mmNewEncoder.mock.funcNewEncoder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewEncoder.mock.afterNewEncoderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewEncoder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewEncoder implements Marshaler
func (mmNewEncoder *MarshalerMock) NewEncoder(w io.Writer) (e1 Encoder) {
	mm_atomic.AddUint64(&mmNewEncoder.beforeNewEncoderCounter, 1)
	defer mm_atomic.AddUint64(&mmNewEncoder.afterNewEncoderCounter, 1)

	mmNewEncoder.t.Helper()

	if mmNewEncoder.inspectFuncNewEncoder != nil {
		mmNewEncoder.inspectFuncNewEncoder(w)
	}

	mm_params := MarshalerMockNewEncoderParams{w}

	// Record call args
	mmNewEncoder.NewEncoderMock.mutex.Lock()
	mmNewEncoder.NewEncoderMock.callArgs = append(mmNewEncoder.NewEncoderMock.callArgs, &mm_params)
	mmNewEncoder.NewEncoderMock.mutex.Unlock()

	for _, e := range mmNewEncoder.NewEncoderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmNewEncoder.NewEncoderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewEncoder.NewEncoderMock.defaultExpectation.Counter, 1)
		mm_want := mmNewEncoder.NewEncoderMock.defaultExpectation.params
		mm_want_ptrs := mmNewEncoder.NewEncoderMock.defaultExpectation.paramPtrs

		mm_got := MarshalerMockNewEncoderParams{w}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.w != nil && !minimock.Equal(*mm_want_ptrs.w, mm_got.w) {
				mmNewEncoder.t.Errorf("MarshalerMock.NewEncoder got unexpected parameter w, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewEncoder.NewEncoderMock.defaultExpectation.expectationOrigins.originW, *mm_want_ptrs.w, mm_got.w, minimock.Diff(*mm_want_ptrs.w, mm_got.w))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewEncoder.t.Errorf("MarshalerMock.NewEncoder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewEncoder.NewEncoderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewEncoder.NewEncoderMock.defaultExpectation.results
		if mm_results == nil {
			mmNewEncoder.t.Fatal("No results are set for the MarshalerMock.NewEncoder")
		}
		return (*mm_results).e1
	}
	if mmNewEncoder.funcNewEncoder != nil {
		return mmNewEncoder.funcNewEncoder(w)
	}
	mmNewEncoder.t.Fatalf("Unexpected call to MarshalerMock.NewEncoder. %v", w)
	return
}

// NewEncoderAfterCounter returns a count of finished MarshalerMock.NewEncoder invocations
func (mmNewEncoder *MarshalerMock) NewEncoderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEncoder.afterNewEncoderCounter)
}

// NewEncoderBeforeCounter returns a count of MarshalerMock.NewEncoder invocations
func (mmNewEncoder *MarshalerMock) NewEncoderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEncoder.beforeNewEncoderCounter)
}

// Calls returns a list of arguments used in each call to MarshalerMock.NewEncoder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewEncoder *mMarshalerMockNewEncoder) Calls() []*MarshalerMockNewEncoderParams {
	mmNewEncoder.mutex.RLock()

	argCopy := make([]*MarshalerMockNewEncoderParams, len(mmNewEncoder.callArgs))
	copy(argCopy, mmNewEncoder.callArgs)

	mmNewEncoder.mutex.RUnlock()

	return argCopy
}

// MinimockNewEncoderDone returns true if the count of the NewEncoder invocations corresponds
// the number of defined expectations
func (m *MarshalerMock) MinimockNewEncoderDone() bool {
	if m.NewEncoderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewEncoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewEncoderMock.invocationsDone()
}

// MinimockNewEncoderInspect logs each unmet expectation
func (m *MarshalerMock) MinimockNewEncoderInspect() {
	for _, e := range m.NewEncoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarshalerMock.NewEncoder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewEncoderCounter := mm_atomic.LoadUint64(&m.afterNewEncoderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewEncoderMock.defaultExpectation != nil && afterNewEncoderCounter < 1 {
		if m.NewEncoderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MarshalerMock.NewEncoder at\n%s", m.NewEncoderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MarshalerMock.NewEncoder at\n%s with params: %#v", m.NewEncoderMock.defaultExpectation.expectationOrigins.origin, *m.NewEncoderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEncoder != nil && afterNewEncoderCounter < 1 {
		m.t.Errorf("Expected call to MarshalerMock.NewEncoder at\n%s", m.funcNewEncoderOrigin)
	}

	if !m.NewEncoderMock.invocationsDone() && afterNewEncoderCounter > 0 {
		m.t.Errorf("Expected %d calls to MarshalerMock.NewEncoder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewEncoderMock.expectedInvocations), m.NewEncoderMock.expectedInvocationsOrigin, afterNewEncoderCounter)
	}
}

type mMarshalerMockUnmarshal struct {
	optional           bool
	mock               *MarshalerMock
	defaultExpectation *MarshalerMockUnmarshalExpectation
	expectations       []*MarshalerMockUnmarshalExpectation

	callArgs []*MarshalerMockUnmarshalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MarshalerMockUnmarshalExpectation specifies expectation struct of the Marshaler.Unmarshal
type MarshalerMockUnmarshalExpectation struct {
	mock               *MarshalerMock
	params             *MarshalerMockUnmarshalParams
	paramPtrs          *MarshalerMockUnmarshalParamPtrs
	expectationOrigins MarshalerMockUnmarshalExpectationOrigins
	results            *MarshalerMockUnmarshalResults
	returnOrigin       string
	Counter            uint64
}

// MarshalerMockUnmarshalParams contains parameters of the Marshaler.Unmarshal
type MarshalerMockUnmarshalParams struct {
	ba1 []byte
	a1  any
}

// MarshalerMockUnmarshalParamPtrs contains pointers to parameters of the Marshaler.Unmarshal
type MarshalerMockUnmarshalParamPtrs struct {
	ba1 *[]byte
	a1  *any
}

// MarshalerMockUnmarshalResults contains results of the Marshaler.Unmarshal
type MarshalerMockUnmarshalResults struct {
	err error
}

// MarshalerMockUnmarshalOrigins contains origins of expectations of the Marshaler.Unmarshal
type MarshalerMockUnmarshalExpectationOrigins struct {
	origin    string
	originBa1 string
	originA1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnmarshal *mMarshalerMockUnmarshal) Optional() *mMarshalerMockUnmarshal {
	mmUnmarshal.optional = true
	return mmUnmarshal
}

// Expect sets up expected params for Marshaler.Unmarshal
func (mmUnmarshal *mMarshalerMockUnmarshal) Expect(ba1 []byte, a1 any) *mMarshalerMockUnmarshal {
	if mmUnmarshal.mock.funcUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Set")
	}

	if mmUnmarshal.defaultExpectation == nil {
		mmUnmarshal.defaultExpectation = &MarshalerMockUnmarshalExpectation{}
	}

	if mmUnmarshal.defaultExpectation.paramPtrs != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by ExpectParams functions")
	}

	mmUnmarshal.defaultExpectation.params = &MarshalerMockUnmarshalParams{ba1, a1}
	mmUnmarshal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUnmarshal.expectations {
		if minimock.Equal(e.params, mmUnmarshal.defaultExpectation.params) {
			mmUnmarshal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnmarshal.defaultExpectation.params)
		}
	}

	return mmUnmarshal
}

// ExpectBa1Param1 sets up expected param ba1 for Marshaler.Unmarshal
func (mmUnmarshal *mMarshalerMockUnmarshal) ExpectBa1Param1(ba1 []byte) *mMarshalerMockUnmarshal {
	if mmUnmarshal.mock.funcUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Set")
	}

	if mmUnmarshal.defaultExpectation == nil {
		mmUnmarshal.defaultExpectation = &MarshalerMockUnmarshalExpectation{}
	}

	if mmUnmarshal.defaultExpectation.params != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Expect")
	}

	if mmUnmarshal.defaultExpectation.paramPtrs == nil {
		mmUnmarshal.defaultExpectation.paramPtrs = &MarshalerMockUnmarshalParamPtrs{}
	}
	mmUnmarshal.defaultExpectation.paramPtrs.ba1 = &ba1
	mmUnmarshal.defaultExpectation.expectationOrigins.originBa1 = minimock.CallerInfo(1)

	return mmUnmarshal
}

// ExpectA1Param2 sets up expected param a1 for Marshaler.Unmarshal
func (mmUnmarshal *mMarshalerMockUnmarshal) ExpectA1Param2(a1 any) *mMarshalerMockUnmarshal {
	if mmUnmarshal.mock.funcUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Set")
	}

	if mmUnmarshal.defaultExpectation == nil {
		mmUnmarshal.defaultExpectation = &MarshalerMockUnmarshalExpectation{}
	}

	if mmUnmarshal.defaultExpectation.params != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Expect")
	}

	if mmUnmarshal.defaultExpectation.paramPtrs == nil {
		mmUnmarshal.defaultExpectation.paramPtrs = &MarshalerMockUnmarshalParamPtrs{}
	}
	mmUnmarshal.defaultExpectation.paramPtrs.a1 = &a1
	mmUnmarshal.defaultExpectation.expectationOrigins.originA1 = minimock.CallerInfo(1)

	return mmUnmarshal
}

// Inspect accepts an inspector function that has same arguments as the Marshaler.Unmarshal
func (mmUnmarshal *mMarshalerMockUnmarshal) Inspect(f func(ba1 []byte, a1 any)) *mMarshalerMockUnmarshal {
	if mmUnmarshal.mock.inspectFuncUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("Inspect function is already set for MarshalerMock.Unmarshal")
	}

	mmUnmarshal.mock.inspectFuncUnmarshal = f

	return mmUnmarshal
}

// Return sets up results that will be returned by Marshaler.Unmarshal
func (mmUnmarshal *mMarshalerMockUnmarshal) Return(err error) *MarshalerMock {
	if mmUnmarshal.mock.funcUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Set")
	}

	if mmUnmarshal.defaultExpectation == nil {
		mmUnmarshal.defaultExpectation = &MarshalerMockUnmarshalExpectation{mock: mmUnmarshal.mock}
	}
	mmUnmarshal.defaultExpectation.results = &MarshalerMockUnmarshalResults{err}
	mmUnmarshal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUnmarshal.mock
}

// Set uses given function f to mock the Marshaler.Unmarshal method
func (mmUnmarshal *mMarshalerMockUnmarshal) Set(f func(ba1 []byte, a1 any) (err error)) *MarshalerMock {
	if mmUnmarshal.defaultExpectation != nil {
		mmUnmarshal.mock.t.Fatalf("Default expectation is already set for the Marshaler.Unmarshal method")
	}

	if len(mmUnmarshal.expectations) > 0 {
		mmUnmarshal.mock.t.Fatalf("Some expectations are already set for the Marshaler.Unmarshal method")
	}

	mmUnmarshal.mock.funcUnmarshal = f
	mmUnmarshal.mock.funcUnmarshalOrigin = minimock.CallerInfo(1)
	return mmUnmarshal.mock
}

// When sets expectation for the Marshaler.Unmarshal which will trigger the result defined by the following
// Then helper
func (mmUnmarshal *mMarshalerMockUnmarshal) When(ba1 []byte, a1 any) *MarshalerMockUnmarshalExpectation {
	if mmUnmarshal.mock.funcUnmarshal != nil {
		mmUnmarshal.mock.t.Fatalf("MarshalerMock.Unmarshal mock is already set by Set")
	}

	expectation := &MarshalerMockUnmarshalExpectation{
		mock:               mmUnmarshal.mock,
		params:             &MarshalerMockUnmarshalParams{ba1, a1},
		expectationOrigins: MarshalerMockUnmarshalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUnmarshal.expectations = append(mmUnmarshal.expectations, expectation)
	return expectation
}

// Then sets up Marshaler.Unmarshal return parameters for the expectation previously defined by the When method
func (e *MarshalerMockUnmarshalExpectation) Then(err error) *MarshalerMock {
	e.results = &MarshalerMockUnmarshalResults{err}
	return e.mock
}

// Times sets number of times Marshaler.Unmarshal should be invoked
func (mmUnmarshal *mMarshalerMockUnmarshal) Times(n uint64) *mMarshalerMockUnmarshal {
	if n == 0 {
		mmUnmarshal.mock.t.Fatalf("Times of MarshalerMock.Unmarshal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnmarshal.expectedInvocations, n)
	mmUnmarshal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUnmarshal
}

func (mmUnmarshal *mMarshalerMockUnmarshal) invocationsDone() bool {
	if len(mmUnmarshal.expectations) == 0 && mmUnmarshal.defaultExpectation == nil && mmUnmarshal.mock.funcUnmarshal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnmarshal.mock.afterUnmarshalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnmarshal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Unmarshal implements Marshaler
func (mmUnmarshal *MarshalerMock) Unmarshal(ba1 []byte, a1 any) (err error) {
	mm_atomic.AddUint64(&mmUnmarshal.beforeUnmarshalCounter, 1)
	defer mm_atomic.AddUint64(&mmUnmarshal.afterUnmarshalCounter, 1)

	mmUnmarshal.t.Helper()

	if mmUnmarshal.inspectFuncUnmarshal != nil {
		mmUnmarshal.inspectFuncUnmarshal(ba1, a1)
	}

	mm_params := MarshalerMockUnmarshalParams{ba1, a1}

	// Record call args
	mmUnmarshal.UnmarshalMock.mutex.Lock()
	mmUnmarshal.UnmarshalMock.callArgs = append(mmUnmarshal.UnmarshalMock.callArgs, &mm_params)
	mmUnmarshal.UnmarshalMock.mutex.Unlock()

	for _, e := range mmUnmarshal.UnmarshalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnmarshal.UnmarshalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnmarshal.UnmarshalMock.defaultExpectation.Counter, 1)
		mm_want := mmUnmarshal.UnmarshalMock.defaultExpectation.params
		mm_want_ptrs := mmUnmarshal.UnmarshalMock.defaultExpectation.paramPtrs

		mm_got := MarshalerMockUnmarshalParams{ba1, a1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ba1 != nil && !minimock.Equal(*mm_want_ptrs.ba1, mm_got.ba1) {
				mmUnmarshal.t.Errorf("MarshalerMock.Unmarshal got unexpected parameter ba1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUnmarshal.UnmarshalMock.defaultExpectation.expectationOrigins.originBa1, *mm_want_ptrs.ba1, mm_got.ba1, minimock.Diff(*mm_want_ptrs.ba1, mm_got.ba1))
			}

			if mm_want_ptrs.a1 != nil && !minimock.Equal(*mm_want_ptrs.a1, mm_got.a1) {
				mmUnmarshal.t.Errorf("MarshalerMock.Unmarshal got unexpected parameter a1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUnmarshal.UnmarshalMock.defaultExpectation.expectationOrigins.originA1, *mm_want_ptrs.a1, mm_got.a1, minimock.Diff(*mm_want_ptrs.a1, mm_got.a1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnmarshal.t.Errorf("MarshalerMock.Unmarshal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUnmarshal.UnmarshalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnmarshal.UnmarshalMock.defaultExpectation.results
		if mm_results == nil {
			mmUnmarshal.t.Fatal("No results are set for the MarshalerMock.Unmarshal")
		}
		return (*mm_results).err
	}
	if mmUnmarshal.funcUnmarshal != nil {
		return mmUnmarshal.funcUnmarshal(ba1, a1)
	}
	mmUnmarshal.t.Fatalf("Unexpected call to MarshalerMock.Unmarshal. %v %v", ba1, a1)
	return
}

// UnmarshalAfterCounter returns a count of finished MarshalerMock.Unmarshal invocations
func (mmUnmarshal *MarshalerMock) UnmarshalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarshal.afterUnmarshalCounter)
}

// UnmarshalBeforeCounter returns a count of MarshalerMock.Unmarshal invocations
func (mmUnmarshal *MarshalerMock) UnmarshalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnmarshal.beforeUnmarshalCounter)
}

// Calls returns a list of arguments used in each call to MarshalerMock.Unmarshal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnmarshal *mMarshalerMockUnmarshal) Calls() []*MarshalerMockUnmarshalParams {
	mmUnmarshal.mutex.RLock()

	argCopy := make([]*MarshalerMockUnmarshalParams, len(mmUnmarshal.callArgs))
	copy(argCopy, mmUnmarshal.callArgs)

	mmUnmarshal.mutex.RUnlock()

	return argCopy
}

// MinimockUnmarshalDone returns true if the count of the Unmarshal invocations corresponds
// the number of defined expectations
func (m *MarshalerMock) MinimockUnmarshalDone() bool {
	if m.UnmarshalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnmarshalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnmarshalMock.invocationsDone()
}

// MinimockUnmarshalInspect logs each unmet expectation
func (m *MarshalerMock) MinimockUnmarshalInspect() {
	for _, e := range m.UnmarshalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarshalerMock.Unmarshal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUnmarshalCounter := mm_atomic.LoadUint64(&m.afterUnmarshalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnmarshalMock.defaultExpectation != nil && afterUnmarshalCounter < 1 {
		if m.UnmarshalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MarshalerMock.Unmarshal at\n%s", m.UnmarshalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MarshalerMock.Unmarshal at\n%s with params: %#v", m.UnmarshalMock.defaultExpectation.expectationOrigins.origin, *m.UnmarshalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnmarshal != nil && afterUnmarshalCounter < 1 {
		m.t.Errorf("Expected call to MarshalerMock.Unmarshal at\n%s", m.funcUnmarshalOrigin)
	}

	if !m.UnmarshalMock.invocationsDone() && afterUnmarshalCounter > 0 {
		m.t.Errorf("Expected %d calls to MarshalerMock.Unmarshal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UnmarshalMock.expectedInvocations), m.UnmarshalMock.expectedInvocationsOrigin, afterUnmarshalCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MarshalerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockContentTypeInspect()

			m.MinimockMarshalInspect()

			m.MinimockNewDecoderInspect()

			m.MinimockNewEncoderInspect()

			m.MinimockUnmarshalInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MarshalerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MarshalerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContentTypeDone() &&
		m.MinimockMarshalDone() &&
		m.MinimockNewDecoderDone() &&
		m.MinimockNewEncoderDone() &&
		m.MinimockUnmarshalDone()
}
