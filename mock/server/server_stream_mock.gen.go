// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package server

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/grpc/metadata"
)

// ServerStreamMock implements ServerStream
type ServerStreamMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcContext          func() (c1 context.Context)
	funcContextOrigin    string
	inspectFuncContext   func()
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mServerStreamMockContext

	funcRecvMsg          func(msg any) (err error)
	funcRecvMsgOrigin    string
	inspectFuncRecvMsg   func(msg any)
	afterRecvMsgCounter  uint64
	beforeRecvMsgCounter uint64
	RecvMsgMock          mServerStreamMockRecvMsg

	funcSendHeader          func(md metadata.MD) (err error)
	funcSendHeaderOrigin    string
	inspectFuncSendHeader   func(md metadata.MD)
	afterSendHeaderCounter  uint64
	beforeSendHeaderCounter uint64
	SendHeaderMock          mServerStreamMockSendHeader

	funcSendMsg          func(msg any) (err error)
	funcSendMsgOrigin    string
	inspectFuncSendMsg   func(msg any)
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mServerStreamMockSendMsg

	funcSetHeader          func(md metadata.MD) (err error)
	funcSetHeaderOrigin    string
	inspectFuncSetHeader   func(md metadata.MD)
	afterSetHeaderCounter  uint64
	beforeSetHeaderCounter uint64
	SetHeaderMock          mServerStreamMockSetHeader

	funcSetTrailer          func(md metadata.MD)
	funcSetTrailerOrigin    string
	inspectFuncSetTrailer   func(md metadata.MD)
	afterSetTrailerCounter  uint64
	beforeSetTrailerCounter uint64
	SetTrailerMock          mServerStreamMockSetTrailer
}

// NewServerStreamMock returns a mock for ServerStream
func NewServerStreamMock(t minimock.Tester) *ServerStreamMock {
	m := &ServerStreamMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContextMock = mServerStreamMockContext{mock: m}

	m.RecvMsgMock = mServerStreamMockRecvMsg{mock: m}
	m.RecvMsgMock.callArgs = []*ServerStreamMockRecvMsgParams{}

	m.SendHeaderMock = mServerStreamMockSendHeader{mock: m}
	m.SendHeaderMock.callArgs = []*ServerStreamMockSendHeaderParams{}

	m.SendMsgMock = mServerStreamMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*ServerStreamMockSendMsgParams{}

	m.SetHeaderMock = mServerStreamMockSetHeader{mock: m}
	m.SetHeaderMock.callArgs = []*ServerStreamMockSetHeaderParams{}

	m.SetTrailerMock = mServerStreamMockSetTrailer{mock: m}
	m.SetTrailerMock.callArgs = []*ServerStreamMockSetTrailerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServerStreamMockContext struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockContextExpectation
	expectations       []*ServerStreamMockContextExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockContextExpectation specifies expectation struct of the ServerStream.Context
type ServerStreamMockContextExpectation struct {
	mock *ServerStreamMock

	results      *ServerStreamMockContextResults
	returnOrigin string
	Counter      uint64
}

// ServerStreamMockContextResults contains results of the ServerStream.Context
type ServerStreamMockContextResults struct {
	c1 context.Context
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmContext *mServerStreamMockContext) Optional() *mServerStreamMockContext {
	mmContext.optional = true
	return mmContext
}

// Expect sets up expected params for ServerStream.Context
func (mmContext *mServerStreamMockContext) Expect() *mServerStreamMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ServerStreamMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ServerStreamMockContextExpectation{}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.Context
func (mmContext *mServerStreamMockContext) Inspect(f func()) *mServerStreamMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by ServerStream.Context
func (mmContext *mServerStreamMockContext) Return(c1 context.Context) *ServerStreamMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ServerStreamMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ServerStreamMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &ServerStreamMockContextResults{c1}
	mmContext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmContext.mock
}

// Set uses given function f to mock the ServerStream.Context method
func (mmContext *mServerStreamMockContext) Set(f func() (c1 context.Context)) *ServerStreamMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the ServerStream.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the ServerStream.Context method")
	}

	mmContext.mock.funcContext = f
	mmContext.mock.funcContextOrigin = minimock.CallerInfo(1)
	return mmContext.mock
}

// Times sets number of times ServerStream.Context should be invoked
func (mmContext *mServerStreamMockContext) Times(n uint64) *mServerStreamMockContext {
	if n == 0 {
		mmContext.mock.t.Fatalf("Times of ServerStreamMock.Context mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmContext.expectedInvocations, n)
	mmContext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmContext
}

func (mmContext *mServerStreamMockContext) invocationsDone() bool {
	if len(mmContext.expectations) == 0 && mmContext.defaultExpectation == nil && mmContext.mock.funcContext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmContext.mock.afterContextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmContext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Context implements ServerStream
func (mmContext *ServerStreamMock) Context() (c1 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	mmContext.t.Helper()

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext()
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)

		mm_results := mmContext.ContextMock.defaultExpectation.results
		if mm_results == nil {
			mmContext.t.Fatal("No results are set for the ServerStreamMock.Context")
		}
		return (*mm_results).c1
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext()
	}
	mmContext.t.Fatalf("Unexpected call to ServerStreamMock.Context.")
	return
}

// ContextAfterCounter returns a count of finished ServerStreamMock.Context invocations
func (mmContext *ServerStreamMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of ServerStreamMock.Context invocations
func (mmContext *ServerStreamMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockContextDone() bool {
	if m.ContextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ContextMock.invocationsDone()
}

// MinimockContextInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServerStreamMock.Context")
		}
	}

	afterContextCounter := mm_atomic.LoadUint64(&m.afterContextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && afterContextCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.Context at\n%s", m.ContextMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && afterContextCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.Context at\n%s", m.funcContextOrigin)
	}

	if !m.ContextMock.invocationsDone() && afterContextCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.Context at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ContextMock.expectedInvocations), m.ContextMock.expectedInvocationsOrigin, afterContextCounter)
	}
}

type mServerStreamMockRecvMsg struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockRecvMsgExpectation
	expectations       []*ServerStreamMockRecvMsgExpectation

	callArgs []*ServerStreamMockRecvMsgParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockRecvMsgExpectation specifies expectation struct of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgExpectation struct {
	mock               *ServerStreamMock
	params             *ServerStreamMockRecvMsgParams
	paramPtrs          *ServerStreamMockRecvMsgParamPtrs
	expectationOrigins ServerStreamMockRecvMsgExpectationOrigins
	results            *ServerStreamMockRecvMsgResults
	returnOrigin       string
	Counter            uint64
}

// ServerStreamMockRecvMsgParams contains parameters of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgParams struct {
	msg any
}

// ServerStreamMockRecvMsgParamPtrs contains pointers to parameters of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgParamPtrs struct {
	msg *any
}

// ServerStreamMockRecvMsgResults contains results of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgResults struct {
	err error
}

// ServerStreamMockRecvMsgOrigins contains origins of expectations of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgExpectationOrigins struct {
	origin    string
	originMsg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecvMsg *mServerStreamMockRecvMsg) Optional() *mServerStreamMockRecvMsg {
	mmRecvMsg.optional = true
	return mmRecvMsg
}

// Expect sets up expected params for ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Expect(msg any) *mServerStreamMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ServerStreamMockRecvMsgExpectation{}
	}

	if mmRecvMsg.defaultExpectation.paramPtrs != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by ExpectParams functions")
	}

	mmRecvMsg.defaultExpectation.params = &ServerStreamMockRecvMsgParams{msg}
	mmRecvMsg.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRecvMsg.expectations {
		if minimock.Equal(e.params, mmRecvMsg.defaultExpectation.params) {
			mmRecvMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecvMsg.defaultExpectation.params)
		}
	}

	return mmRecvMsg
}

// ExpectMsgParam1 sets up expected param msg for ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) ExpectMsgParam1(msg any) *mServerStreamMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ServerStreamMockRecvMsgExpectation{}
	}

	if mmRecvMsg.defaultExpectation.params != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Expect")
	}

	if mmRecvMsg.defaultExpectation.paramPtrs == nil {
		mmRecvMsg.defaultExpectation.paramPtrs = &ServerStreamMockRecvMsgParamPtrs{}
	}
	mmRecvMsg.defaultExpectation.paramPtrs.msg = &msg
	mmRecvMsg.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmRecvMsg
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Inspect(f func(msg any)) *mServerStreamMockRecvMsg {
	if mmRecvMsg.mock.inspectFuncRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.RecvMsg")
	}

	mmRecvMsg.mock.inspectFuncRecvMsg = f

	return mmRecvMsg
}

// Return sets up results that will be returned by ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Return(err error) *ServerStreamMock {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ServerStreamMockRecvMsgExpectation{mock: mmRecvMsg.mock}
	}
	mmRecvMsg.defaultExpectation.results = &ServerStreamMockRecvMsgResults{err}
	mmRecvMsg.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecvMsg.mock
}

// Set uses given function f to mock the ServerStream.RecvMsg method
func (mmRecvMsg *mServerStreamMockRecvMsg) Set(f func(msg any) (err error)) *ServerStreamMock {
	if mmRecvMsg.defaultExpectation != nil {
		mmRecvMsg.mock.t.Fatalf("Default expectation is already set for the ServerStream.RecvMsg method")
	}

	if len(mmRecvMsg.expectations) > 0 {
		mmRecvMsg.mock.t.Fatalf("Some expectations are already set for the ServerStream.RecvMsg method")
	}

	mmRecvMsg.mock.funcRecvMsg = f
	mmRecvMsg.mock.funcRecvMsgOrigin = minimock.CallerInfo(1)
	return mmRecvMsg.mock
}

// When sets expectation for the ServerStream.RecvMsg which will trigger the result defined by the following
// Then helper
func (mmRecvMsg *mServerStreamMockRecvMsg) When(msg any) *ServerStreamMockRecvMsgExpectation {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	expectation := &ServerStreamMockRecvMsgExpectation{
		mock:               mmRecvMsg.mock,
		params:             &ServerStreamMockRecvMsgParams{msg},
		expectationOrigins: ServerStreamMockRecvMsgExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRecvMsg.expectations = append(mmRecvMsg.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.RecvMsg return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockRecvMsgExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockRecvMsgResults{err}
	return e.mock
}

// Times sets number of times ServerStream.RecvMsg should be invoked
func (mmRecvMsg *mServerStreamMockRecvMsg) Times(n uint64) *mServerStreamMockRecvMsg {
	if n == 0 {
		mmRecvMsg.mock.t.Fatalf("Times of ServerStreamMock.RecvMsg mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecvMsg.expectedInvocations, n)
	mmRecvMsg.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecvMsg
}

func (mmRecvMsg *mServerStreamMockRecvMsg) invocationsDone() bool {
	if len(mmRecvMsg.expectations) == 0 && mmRecvMsg.defaultExpectation == nil && mmRecvMsg.mock.funcRecvMsg == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecvMsg.mock.afterRecvMsgCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecvMsg.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RecvMsg implements ServerStream
func (mmRecvMsg *ServerStreamMock) RecvMsg(msg any) (err error) {
	mm_atomic.AddUint64(&mmRecvMsg.beforeRecvMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmRecvMsg.afterRecvMsgCounter, 1)

	mmRecvMsg.t.Helper()

	if mmRecvMsg.inspectFuncRecvMsg != nil {
		mmRecvMsg.inspectFuncRecvMsg(msg)
	}

	mm_params := ServerStreamMockRecvMsgParams{msg}

	// Record call args
	mmRecvMsg.RecvMsgMock.mutex.Lock()
	mmRecvMsg.RecvMsgMock.callArgs = append(mmRecvMsg.RecvMsgMock.callArgs, &mm_params)
	mmRecvMsg.RecvMsgMock.mutex.Unlock()

	for _, e := range mmRecvMsg.RecvMsgMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRecvMsg.RecvMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecvMsg.RecvMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmRecvMsg.RecvMsgMock.defaultExpectation.params
		mm_want_ptrs := mmRecvMsg.RecvMsgMock.defaultExpectation.paramPtrs

		mm_got := ServerStreamMockRecvMsgParams{msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmRecvMsg.t.Errorf("ServerStreamMock.RecvMsg got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecvMsg.RecvMsgMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecvMsg.t.Errorf("ServerStreamMock.RecvMsg got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRecvMsg.RecvMsgMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecvMsg.RecvMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmRecvMsg.t.Fatal("No results are set for the ServerStreamMock.RecvMsg")
		}
		return (*mm_results).err
	}
	if mmRecvMsg.funcRecvMsg != nil {
		return mmRecvMsg.funcRecvMsg(msg)
	}
	mmRecvMsg.t.Fatalf("Unexpected call to ServerStreamMock.RecvMsg. %v", msg)
	return
}

// RecvMsgAfterCounter returns a count of finished ServerStreamMock.RecvMsg invocations
func (mmRecvMsg *ServerStreamMock) RecvMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.afterRecvMsgCounter)
}

// RecvMsgBeforeCounter returns a count of ServerStreamMock.RecvMsg invocations
func (mmRecvMsg *ServerStreamMock) RecvMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.beforeRecvMsgCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.RecvMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecvMsg *mServerStreamMockRecvMsg) Calls() []*ServerStreamMockRecvMsgParams {
	mmRecvMsg.mutex.RLock()

	argCopy := make([]*ServerStreamMockRecvMsgParams, len(mmRecvMsg.callArgs))
	copy(argCopy, mmRecvMsg.callArgs)

	mmRecvMsg.mutex.RUnlock()

	return argCopy
}

// MinimockRecvMsgDone returns true if the count of the RecvMsg invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockRecvMsgDone() bool {
	if m.RecvMsgMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecvMsgMock.invocationsDone()
}

// MinimockRecvMsgInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockRecvMsgInspect() {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.RecvMsg at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRecvMsgCounter := mm_atomic.LoadUint64(&m.afterRecvMsgCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && afterRecvMsgCounter < 1 {
		if m.RecvMsgMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServerStreamMock.RecvMsg at\n%s", m.RecvMsgMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.RecvMsg at\n%s with params: %#v", m.RecvMsgMock.defaultExpectation.expectationOrigins.origin, *m.RecvMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && afterRecvMsgCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.RecvMsg at\n%s", m.funcRecvMsgOrigin)
	}

	if !m.RecvMsgMock.invocationsDone() && afterRecvMsgCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.RecvMsg at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecvMsgMock.expectedInvocations), m.RecvMsgMock.expectedInvocationsOrigin, afterRecvMsgCounter)
	}
}

type mServerStreamMockSendHeader struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSendHeaderExpectation
	expectations       []*ServerStreamMockSendHeaderExpectation

	callArgs []*ServerStreamMockSendHeaderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockSendHeaderExpectation specifies expectation struct of the ServerStream.SendHeader
type ServerStreamMockSendHeaderExpectation struct {
	mock               *ServerStreamMock
	params             *ServerStreamMockSendHeaderParams
	paramPtrs          *ServerStreamMockSendHeaderParamPtrs
	expectationOrigins ServerStreamMockSendHeaderExpectationOrigins
	results            *ServerStreamMockSendHeaderResults
	returnOrigin       string
	Counter            uint64
}

// ServerStreamMockSendHeaderParams contains parameters of the ServerStream.SendHeader
type ServerStreamMockSendHeaderParams struct {
	md metadata.MD
}

// ServerStreamMockSendHeaderParamPtrs contains pointers to parameters of the ServerStream.SendHeader
type ServerStreamMockSendHeaderParamPtrs struct {
	md *metadata.MD
}

// ServerStreamMockSendHeaderResults contains results of the ServerStream.SendHeader
type ServerStreamMockSendHeaderResults struct {
	err error
}

// ServerStreamMockSendHeaderOrigins contains origins of expectations of the ServerStream.SendHeader
type ServerStreamMockSendHeaderExpectationOrigins struct {
	origin   string
	originMd string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendHeader *mServerStreamMockSendHeader) Optional() *mServerStreamMockSendHeader {
	mmSendHeader.optional = true
	return mmSendHeader
}

// Expect sets up expected params for ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Expect(md metadata.MD) *mServerStreamMockSendHeader {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ServerStreamMockSendHeaderExpectation{}
	}

	if mmSendHeader.defaultExpectation.paramPtrs != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by ExpectParams functions")
	}

	mmSendHeader.defaultExpectation.params = &ServerStreamMockSendHeaderParams{md}
	mmSendHeader.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendHeader.expectations {
		if minimock.Equal(e.params, mmSendHeader.defaultExpectation.params) {
			mmSendHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendHeader.defaultExpectation.params)
		}
	}

	return mmSendHeader
}

// ExpectMdParam1 sets up expected param md for ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) ExpectMdParam1(md metadata.MD) *mServerStreamMockSendHeader {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ServerStreamMockSendHeaderExpectation{}
	}

	if mmSendHeader.defaultExpectation.params != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Expect")
	}

	if mmSendHeader.defaultExpectation.paramPtrs == nil {
		mmSendHeader.defaultExpectation.paramPtrs = &ServerStreamMockSendHeaderParamPtrs{}
	}
	mmSendHeader.defaultExpectation.paramPtrs.md = &md
	mmSendHeader.defaultExpectation.expectationOrigins.originMd = minimock.CallerInfo(1)

	return mmSendHeader
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Inspect(f func(md metadata.MD)) *mServerStreamMockSendHeader {
	if mmSendHeader.mock.inspectFuncSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SendHeader")
	}

	mmSendHeader.mock.inspectFuncSendHeader = f

	return mmSendHeader
}

// Return sets up results that will be returned by ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Return(err error) *ServerStreamMock {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ServerStreamMockSendHeaderExpectation{mock: mmSendHeader.mock}
	}
	mmSendHeader.defaultExpectation.results = &ServerStreamMockSendHeaderResults{err}
	mmSendHeader.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendHeader.mock
}

// Set uses given function f to mock the ServerStream.SendHeader method
func (mmSendHeader *mServerStreamMockSendHeader) Set(f func(md metadata.MD) (err error)) *ServerStreamMock {
	if mmSendHeader.defaultExpectation != nil {
		mmSendHeader.mock.t.Fatalf("Default expectation is already set for the ServerStream.SendHeader method")
	}

	if len(mmSendHeader.expectations) > 0 {
		mmSendHeader.mock.t.Fatalf("Some expectations are already set for the ServerStream.SendHeader method")
	}

	mmSendHeader.mock.funcSendHeader = f
	mmSendHeader.mock.funcSendHeaderOrigin = minimock.CallerInfo(1)
	return mmSendHeader.mock
}

// When sets expectation for the ServerStream.SendHeader which will trigger the result defined by the following
// Then helper
func (mmSendHeader *mServerStreamMockSendHeader) When(md metadata.MD) *ServerStreamMockSendHeaderExpectation {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	expectation := &ServerStreamMockSendHeaderExpectation{
		mock:               mmSendHeader.mock,
		params:             &ServerStreamMockSendHeaderParams{md},
		expectationOrigins: ServerStreamMockSendHeaderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendHeader.expectations = append(mmSendHeader.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SendHeader return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSendHeaderExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSendHeaderResults{err}
	return e.mock
}

// Times sets number of times ServerStream.SendHeader should be invoked
func (mmSendHeader *mServerStreamMockSendHeader) Times(n uint64) *mServerStreamMockSendHeader {
	if n == 0 {
		mmSendHeader.mock.t.Fatalf("Times of ServerStreamMock.SendHeader mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendHeader.expectedInvocations, n)
	mmSendHeader.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendHeader
}

func (mmSendHeader *mServerStreamMockSendHeader) invocationsDone() bool {
	if len(mmSendHeader.expectations) == 0 && mmSendHeader.defaultExpectation == nil && mmSendHeader.mock.funcSendHeader == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendHeader.mock.afterSendHeaderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendHeader.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendHeader implements ServerStream
func (mmSendHeader *ServerStreamMock) SendHeader(md metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSendHeader.beforeSendHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSendHeader.afterSendHeaderCounter, 1)

	mmSendHeader.t.Helper()

	if mmSendHeader.inspectFuncSendHeader != nil {
		mmSendHeader.inspectFuncSendHeader(md)
	}

	mm_params := ServerStreamMockSendHeaderParams{md}

	// Record call args
	mmSendHeader.SendHeaderMock.mutex.Lock()
	mmSendHeader.SendHeaderMock.callArgs = append(mmSendHeader.SendHeaderMock.callArgs, &mm_params)
	mmSendHeader.SendHeaderMock.mutex.Unlock()

	for _, e := range mmSendHeader.SendHeaderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendHeader.SendHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendHeader.SendHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSendHeader.SendHeaderMock.defaultExpectation.params
		mm_want_ptrs := mmSendHeader.SendHeaderMock.defaultExpectation.paramPtrs

		mm_got := ServerStreamMockSendHeaderParams{md}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.md != nil && !minimock.Equal(*mm_want_ptrs.md, mm_got.md) {
				mmSendHeader.t.Errorf("ServerStreamMock.SendHeader got unexpected parameter md, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendHeader.SendHeaderMock.defaultExpectation.expectationOrigins.originMd, *mm_want_ptrs.md, mm_got.md, minimock.Diff(*mm_want_ptrs.md, mm_got.md))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendHeader.t.Errorf("ServerStreamMock.SendHeader got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendHeader.SendHeaderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendHeader.SendHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSendHeader.t.Fatal("No results are set for the ServerStreamMock.SendHeader")
		}
		return (*mm_results).err
	}
	if mmSendHeader.funcSendHeader != nil {
		return mmSendHeader.funcSendHeader(md)
	}
	mmSendHeader.t.Fatalf("Unexpected call to ServerStreamMock.SendHeader. %v", md)
	return
}

// SendHeaderAfterCounter returns a count of finished ServerStreamMock.SendHeader invocations
func (mmSendHeader *ServerStreamMock) SendHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.afterSendHeaderCounter)
}

// SendHeaderBeforeCounter returns a count of ServerStreamMock.SendHeader invocations
func (mmSendHeader *ServerStreamMock) SendHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.beforeSendHeaderCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SendHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendHeader *mServerStreamMockSendHeader) Calls() []*ServerStreamMockSendHeaderParams {
	mmSendHeader.mutex.RLock()

	argCopy := make([]*ServerStreamMockSendHeaderParams, len(mmSendHeader.callArgs))
	copy(argCopy, mmSendHeader.callArgs)

	mmSendHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSendHeaderDone returns true if the count of the SendHeader invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSendHeaderDone() bool {
	if m.SendHeaderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendHeaderMock.invocationsDone()
}

// MinimockSendHeaderInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSendHeaderInspect() {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SendHeader at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendHeaderCounter := mm_atomic.LoadUint64(&m.afterSendHeaderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && afterSendHeaderCounter < 1 {
		if m.SendHeaderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServerStreamMock.SendHeader at\n%s", m.SendHeaderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SendHeader at\n%s with params: %#v", m.SendHeaderMock.defaultExpectation.expectationOrigins.origin, *m.SendHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && afterSendHeaderCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.SendHeader at\n%s", m.funcSendHeaderOrigin)
	}

	if !m.SendHeaderMock.invocationsDone() && afterSendHeaderCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.SendHeader at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendHeaderMock.expectedInvocations), m.SendHeaderMock.expectedInvocationsOrigin, afterSendHeaderCounter)
	}
}

type mServerStreamMockSendMsg struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSendMsgExpectation
	expectations       []*ServerStreamMockSendMsgExpectation

	callArgs []*ServerStreamMockSendMsgParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockSendMsgExpectation specifies expectation struct of the ServerStream.SendMsg
type ServerStreamMockSendMsgExpectation struct {
	mock               *ServerStreamMock
	params             *ServerStreamMockSendMsgParams
	paramPtrs          *ServerStreamMockSendMsgParamPtrs
	expectationOrigins ServerStreamMockSendMsgExpectationOrigins
	results            *ServerStreamMockSendMsgResults
	returnOrigin       string
	Counter            uint64
}

// ServerStreamMockSendMsgParams contains parameters of the ServerStream.SendMsg
type ServerStreamMockSendMsgParams struct {
	msg any
}

// ServerStreamMockSendMsgParamPtrs contains pointers to parameters of the ServerStream.SendMsg
type ServerStreamMockSendMsgParamPtrs struct {
	msg *any
}

// ServerStreamMockSendMsgResults contains results of the ServerStream.SendMsg
type ServerStreamMockSendMsgResults struct {
	err error
}

// ServerStreamMockSendMsgOrigins contains origins of expectations of the ServerStream.SendMsg
type ServerStreamMockSendMsgExpectationOrigins struct {
	origin    string
	originMsg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMsg *mServerStreamMockSendMsg) Optional() *mServerStreamMockSendMsg {
	mmSendMsg.optional = true
	return mmSendMsg
}

// Expect sets up expected params for ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Expect(msg any) *mServerStreamMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ServerStreamMockSendMsgExpectation{}
	}

	if mmSendMsg.defaultExpectation.paramPtrs != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by ExpectParams functions")
	}

	mmSendMsg.defaultExpectation.params = &ServerStreamMockSendMsgParams{msg}
	mmSendMsg.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// ExpectMsgParam1 sets up expected param msg for ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) ExpectMsgParam1(msg any) *mServerStreamMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ServerStreamMockSendMsgExpectation{}
	}

	if mmSendMsg.defaultExpectation.params != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Expect")
	}

	if mmSendMsg.defaultExpectation.paramPtrs == nil {
		mmSendMsg.defaultExpectation.paramPtrs = &ServerStreamMockSendMsgParamPtrs{}
	}
	mmSendMsg.defaultExpectation.paramPtrs.msg = &msg
	mmSendMsg.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Inspect(f func(msg any)) *mServerStreamMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Return(err error) *ServerStreamMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ServerStreamMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &ServerStreamMockSendMsgResults{err}
	mmSendMsg.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMsg.mock
}

// Set uses given function f to mock the ServerStream.SendMsg method
func (mmSendMsg *mServerStreamMockSendMsg) Set(f func(msg any) (err error)) *ServerStreamMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the ServerStream.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the ServerStream.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	mmSendMsg.mock.funcSendMsgOrigin = minimock.CallerInfo(1)
	return mmSendMsg.mock
}

// When sets expectation for the ServerStream.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mServerStreamMockSendMsg) When(msg any) *ServerStreamMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	expectation := &ServerStreamMockSendMsgExpectation{
		mock:               mmSendMsg.mock,
		params:             &ServerStreamMockSendMsgParams{msg},
		expectationOrigins: ServerStreamMockSendMsgExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SendMsg return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSendMsgExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSendMsgResults{err}
	return e.mock
}

// Times sets number of times ServerStream.SendMsg should be invoked
func (mmSendMsg *mServerStreamMockSendMsg) Times(n uint64) *mServerStreamMockSendMsg {
	if n == 0 {
		mmSendMsg.mock.t.Fatalf("Times of ServerStreamMock.SendMsg mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMsg.expectedInvocations, n)
	mmSendMsg.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMsg
}

func (mmSendMsg *mServerStreamMockSendMsg) invocationsDone() bool {
	if len(mmSendMsg.expectations) == 0 && mmSendMsg.defaultExpectation == nil && mmSendMsg.mock.funcSendMsg == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMsg.mock.afterSendMsgCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMsg.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMsg implements ServerStream
func (mmSendMsg *ServerStreamMock) SendMsg(msg any) (err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	mmSendMsg.t.Helper()

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(msg)
	}

	mm_params := ServerStreamMockSendMsgParams{msg}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, &mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_want_ptrs := mmSendMsg.SendMsgMock.defaultExpectation.paramPtrs

		mm_got := ServerStreamMockSendMsgParams{msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmSendMsg.t.Errorf("ServerStreamMock.SendMsg got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMsg.SendMsgMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("ServerStreamMock.SendMsg got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMsg.SendMsgMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the ServerStreamMock.SendMsg")
		}
		return (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(msg)
	}
	mmSendMsg.t.Fatalf("Unexpected call to ServerStreamMock.SendMsg. %v", msg)
	return
}

// SendMsgAfterCounter returns a count of finished ServerStreamMock.SendMsg invocations
func (mmSendMsg *ServerStreamMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of ServerStreamMock.SendMsg invocations
func (mmSendMsg *ServerStreamMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mServerStreamMockSendMsg) Calls() []*ServerStreamMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*ServerStreamMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSendMsgDone() bool {
	if m.SendMsgMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMsgMock.invocationsDone()
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SendMsg at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMsgCounter := mm_atomic.LoadUint64(&m.afterSendMsgCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && afterSendMsgCounter < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServerStreamMock.SendMsg at\n%s", m.SendMsgMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SendMsg at\n%s with params: %#v", m.SendMsgMock.defaultExpectation.expectationOrigins.origin, *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && afterSendMsgCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.SendMsg at\n%s", m.funcSendMsgOrigin)
	}

	if !m.SendMsgMock.invocationsDone() && afterSendMsgCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.SendMsg at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMsgMock.expectedInvocations), m.SendMsgMock.expectedInvocationsOrigin, afterSendMsgCounter)
	}
}

type mServerStreamMockSetHeader struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSetHeaderExpectation
	expectations       []*ServerStreamMockSetHeaderExpectation

	callArgs []*ServerStreamMockSetHeaderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockSetHeaderExpectation specifies expectation struct of the ServerStream.SetHeader
type ServerStreamMockSetHeaderExpectation struct {
	mock               *ServerStreamMock
	params             *ServerStreamMockSetHeaderParams
	paramPtrs          *ServerStreamMockSetHeaderParamPtrs
	expectationOrigins ServerStreamMockSetHeaderExpectationOrigins
	results            *ServerStreamMockSetHeaderResults
	returnOrigin       string
	Counter            uint64
}

// ServerStreamMockSetHeaderParams contains parameters of the ServerStream.SetHeader
type ServerStreamMockSetHeaderParams struct {
	md metadata.MD
}

// ServerStreamMockSetHeaderParamPtrs contains pointers to parameters of the ServerStream.SetHeader
type ServerStreamMockSetHeaderParamPtrs struct {
	md *metadata.MD
}

// ServerStreamMockSetHeaderResults contains results of the ServerStream.SetHeader
type ServerStreamMockSetHeaderResults struct {
	err error
}

// ServerStreamMockSetHeaderOrigins contains origins of expectations of the ServerStream.SetHeader
type ServerStreamMockSetHeaderExpectationOrigins struct {
	origin   string
	originMd string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetHeader *mServerStreamMockSetHeader) Optional() *mServerStreamMockSetHeader {
	mmSetHeader.optional = true
	return mmSetHeader
}

// Expect sets up expected params for ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Expect(md metadata.MD) *mServerStreamMockSetHeader {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ServerStreamMockSetHeaderExpectation{}
	}

	if mmSetHeader.defaultExpectation.paramPtrs != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by ExpectParams functions")
	}

	mmSetHeader.defaultExpectation.params = &ServerStreamMockSetHeaderParams{md}
	mmSetHeader.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetHeader.expectations {
		if minimock.Equal(e.params, mmSetHeader.defaultExpectation.params) {
			mmSetHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetHeader.defaultExpectation.params)
		}
	}

	return mmSetHeader
}

// ExpectMdParam1 sets up expected param md for ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) ExpectMdParam1(md metadata.MD) *mServerStreamMockSetHeader {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ServerStreamMockSetHeaderExpectation{}
	}

	if mmSetHeader.defaultExpectation.params != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Expect")
	}

	if mmSetHeader.defaultExpectation.paramPtrs == nil {
		mmSetHeader.defaultExpectation.paramPtrs = &ServerStreamMockSetHeaderParamPtrs{}
	}
	mmSetHeader.defaultExpectation.paramPtrs.md = &md
	mmSetHeader.defaultExpectation.expectationOrigins.originMd = minimock.CallerInfo(1)

	return mmSetHeader
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Inspect(f func(md metadata.MD)) *mServerStreamMockSetHeader {
	if mmSetHeader.mock.inspectFuncSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SetHeader")
	}

	mmSetHeader.mock.inspectFuncSetHeader = f

	return mmSetHeader
}

// Return sets up results that will be returned by ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Return(err error) *ServerStreamMock {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ServerStreamMockSetHeaderExpectation{mock: mmSetHeader.mock}
	}
	mmSetHeader.defaultExpectation.results = &ServerStreamMockSetHeaderResults{err}
	mmSetHeader.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetHeader.mock
}

// Set uses given function f to mock the ServerStream.SetHeader method
func (mmSetHeader *mServerStreamMockSetHeader) Set(f func(md metadata.MD) (err error)) *ServerStreamMock {
	if mmSetHeader.defaultExpectation != nil {
		mmSetHeader.mock.t.Fatalf("Default expectation is already set for the ServerStream.SetHeader method")
	}

	if len(mmSetHeader.expectations) > 0 {
		mmSetHeader.mock.t.Fatalf("Some expectations are already set for the ServerStream.SetHeader method")
	}

	mmSetHeader.mock.funcSetHeader = f
	mmSetHeader.mock.funcSetHeaderOrigin = minimock.CallerInfo(1)
	return mmSetHeader.mock
}

// When sets expectation for the ServerStream.SetHeader which will trigger the result defined by the following
// Then helper
func (mmSetHeader *mServerStreamMockSetHeader) When(md metadata.MD) *ServerStreamMockSetHeaderExpectation {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	expectation := &ServerStreamMockSetHeaderExpectation{
		mock:               mmSetHeader.mock,
		params:             &ServerStreamMockSetHeaderParams{md},
		expectationOrigins: ServerStreamMockSetHeaderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetHeader.expectations = append(mmSetHeader.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SetHeader return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSetHeaderExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSetHeaderResults{err}
	return e.mock
}

// Times sets number of times ServerStream.SetHeader should be invoked
func (mmSetHeader *mServerStreamMockSetHeader) Times(n uint64) *mServerStreamMockSetHeader {
	if n == 0 {
		mmSetHeader.mock.t.Fatalf("Times of ServerStreamMock.SetHeader mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetHeader.expectedInvocations, n)
	mmSetHeader.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetHeader
}

func (mmSetHeader *mServerStreamMockSetHeader) invocationsDone() bool {
	if len(mmSetHeader.expectations) == 0 && mmSetHeader.defaultExpectation == nil && mmSetHeader.mock.funcSetHeader == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetHeader.mock.afterSetHeaderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetHeader.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetHeader implements ServerStream
func (mmSetHeader *ServerStreamMock) SetHeader(md metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSetHeader.beforeSetHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetHeader.afterSetHeaderCounter, 1)

	mmSetHeader.t.Helper()

	if mmSetHeader.inspectFuncSetHeader != nil {
		mmSetHeader.inspectFuncSetHeader(md)
	}

	mm_params := ServerStreamMockSetHeaderParams{md}

	// Record call args
	mmSetHeader.SetHeaderMock.mutex.Lock()
	mmSetHeader.SetHeaderMock.callArgs = append(mmSetHeader.SetHeaderMock.callArgs, &mm_params)
	mmSetHeader.SetHeaderMock.mutex.Unlock()

	for _, e := range mmSetHeader.SetHeaderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetHeader.SetHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetHeader.SetHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetHeader.SetHeaderMock.defaultExpectation.params
		mm_want_ptrs := mmSetHeader.SetHeaderMock.defaultExpectation.paramPtrs

		mm_got := ServerStreamMockSetHeaderParams{md}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.md != nil && !minimock.Equal(*mm_want_ptrs.md, mm_got.md) {
				mmSetHeader.t.Errorf("ServerStreamMock.SetHeader got unexpected parameter md, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetHeader.SetHeaderMock.defaultExpectation.expectationOrigins.originMd, *mm_want_ptrs.md, mm_got.md, minimock.Diff(*mm_want_ptrs.md, mm_got.md))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetHeader.t.Errorf("ServerStreamMock.SetHeader got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetHeader.SetHeaderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetHeader.SetHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetHeader.t.Fatal("No results are set for the ServerStreamMock.SetHeader")
		}
		return (*mm_results).err
	}
	if mmSetHeader.funcSetHeader != nil {
		return mmSetHeader.funcSetHeader(md)
	}
	mmSetHeader.t.Fatalf("Unexpected call to ServerStreamMock.SetHeader. %v", md)
	return
}

// SetHeaderAfterCounter returns a count of finished ServerStreamMock.SetHeader invocations
func (mmSetHeader *ServerStreamMock) SetHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.afterSetHeaderCounter)
}

// SetHeaderBeforeCounter returns a count of ServerStreamMock.SetHeader invocations
func (mmSetHeader *ServerStreamMock) SetHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.beforeSetHeaderCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SetHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetHeader *mServerStreamMockSetHeader) Calls() []*ServerStreamMockSetHeaderParams {
	mmSetHeader.mutex.RLock()

	argCopy := make([]*ServerStreamMockSetHeaderParams, len(mmSetHeader.callArgs))
	copy(argCopy, mmSetHeader.callArgs)

	mmSetHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSetHeaderDone returns true if the count of the SetHeader invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSetHeaderDone() bool {
	if m.SetHeaderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetHeaderMock.invocationsDone()
}

// MinimockSetHeaderInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSetHeaderInspect() {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SetHeader at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetHeaderCounter := mm_atomic.LoadUint64(&m.afterSetHeaderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && afterSetHeaderCounter < 1 {
		if m.SetHeaderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServerStreamMock.SetHeader at\n%s", m.SetHeaderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SetHeader at\n%s with params: %#v", m.SetHeaderMock.defaultExpectation.expectationOrigins.origin, *m.SetHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && afterSetHeaderCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.SetHeader at\n%s", m.funcSetHeaderOrigin)
	}

	if !m.SetHeaderMock.invocationsDone() && afterSetHeaderCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.SetHeader at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetHeaderMock.expectedInvocations), m.SetHeaderMock.expectedInvocationsOrigin, afterSetHeaderCounter)
	}
}

type mServerStreamMockSetTrailer struct {
	optional           bool
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSetTrailerExpectation
	expectations       []*ServerStreamMockSetTrailerExpectation

	callArgs []*ServerStreamMockSetTrailerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServerStreamMockSetTrailerExpectation specifies expectation struct of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerExpectation struct {
	mock               *ServerStreamMock
	params             *ServerStreamMockSetTrailerParams
	paramPtrs          *ServerStreamMockSetTrailerParamPtrs
	expectationOrigins ServerStreamMockSetTrailerExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ServerStreamMockSetTrailerParams contains parameters of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerParams struct {
	md metadata.MD
}

// ServerStreamMockSetTrailerParamPtrs contains pointers to parameters of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerParamPtrs struct {
	md *metadata.MD
}

// ServerStreamMockSetTrailerOrigins contains origins of expectations of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerExpectationOrigins struct {
	origin   string
	originMd string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetTrailer *mServerStreamMockSetTrailer) Optional() *mServerStreamMockSetTrailer {
	mmSetTrailer.optional = true
	return mmSetTrailer
}

// Expect sets up expected params for ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Expect(md metadata.MD) *mServerStreamMockSetTrailer {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ServerStreamMockSetTrailerExpectation{}
	}

	if mmSetTrailer.defaultExpectation.paramPtrs != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by ExpectParams functions")
	}

	mmSetTrailer.defaultExpectation.params = &ServerStreamMockSetTrailerParams{md}
	mmSetTrailer.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetTrailer.expectations {
		if minimock.Equal(e.params, mmSetTrailer.defaultExpectation.params) {
			mmSetTrailer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTrailer.defaultExpectation.params)
		}
	}

	return mmSetTrailer
}

// ExpectMdParam1 sets up expected param md for ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) ExpectMdParam1(md metadata.MD) *mServerStreamMockSetTrailer {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ServerStreamMockSetTrailerExpectation{}
	}

	if mmSetTrailer.defaultExpectation.params != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Expect")
	}

	if mmSetTrailer.defaultExpectation.paramPtrs == nil {
		mmSetTrailer.defaultExpectation.paramPtrs = &ServerStreamMockSetTrailerParamPtrs{}
	}
	mmSetTrailer.defaultExpectation.paramPtrs.md = &md
	mmSetTrailer.defaultExpectation.expectationOrigins.originMd = minimock.CallerInfo(1)

	return mmSetTrailer
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Inspect(f func(md metadata.MD)) *mServerStreamMockSetTrailer {
	if mmSetTrailer.mock.inspectFuncSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SetTrailer")
	}

	mmSetTrailer.mock.inspectFuncSetTrailer = f

	return mmSetTrailer
}

// Return sets up results that will be returned by ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Return() *ServerStreamMock {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ServerStreamMockSetTrailerExpectation{mock: mmSetTrailer.mock}
	}

	mmSetTrailer.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetTrailer.mock
}

// Set uses given function f to mock the ServerStream.SetTrailer method
func (mmSetTrailer *mServerStreamMockSetTrailer) Set(f func(md metadata.MD)) *ServerStreamMock {
	if mmSetTrailer.defaultExpectation != nil {
		mmSetTrailer.mock.t.Fatalf("Default expectation is already set for the ServerStream.SetTrailer method")
	}

	if len(mmSetTrailer.expectations) > 0 {
		mmSetTrailer.mock.t.Fatalf("Some expectations are already set for the ServerStream.SetTrailer method")
	}

	mmSetTrailer.mock.funcSetTrailer = f
	mmSetTrailer.mock.funcSetTrailerOrigin = minimock.CallerInfo(1)
	return mmSetTrailer.mock
}

// Times sets number of times ServerStream.SetTrailer should be invoked
func (mmSetTrailer *mServerStreamMockSetTrailer) Times(n uint64) *mServerStreamMockSetTrailer {
	if n == 0 {
		mmSetTrailer.mock.t.Fatalf("Times of ServerStreamMock.SetTrailer mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetTrailer.expectedInvocations, n)
	mmSetTrailer.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetTrailer
}

func (mmSetTrailer *mServerStreamMockSetTrailer) invocationsDone() bool {
	if len(mmSetTrailer.expectations) == 0 && mmSetTrailer.defaultExpectation == nil && mmSetTrailer.mock.funcSetTrailer == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetTrailer.mock.afterSetTrailerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetTrailer.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetTrailer implements ServerStream
func (mmSetTrailer *ServerStreamMock) SetTrailer(md metadata.MD) {
	mm_atomic.AddUint64(&mmSetTrailer.beforeSetTrailerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTrailer.afterSetTrailerCounter, 1)

	mmSetTrailer.t.Helper()

	if mmSetTrailer.inspectFuncSetTrailer != nil {
		mmSetTrailer.inspectFuncSetTrailer(md)
	}

	mm_params := ServerStreamMockSetTrailerParams{md}

	// Record call args
	mmSetTrailer.SetTrailerMock.mutex.Lock()
	mmSetTrailer.SetTrailerMock.callArgs = append(mmSetTrailer.SetTrailerMock.callArgs, &mm_params)
	mmSetTrailer.SetTrailerMock.mutex.Unlock()

	for _, e := range mmSetTrailer.SetTrailerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTrailer.SetTrailerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTrailer.SetTrailerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTrailer.SetTrailerMock.defaultExpectation.params
		mm_want_ptrs := mmSetTrailer.SetTrailerMock.defaultExpectation.paramPtrs

		mm_got := ServerStreamMockSetTrailerParams{md}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.md != nil && !minimock.Equal(*mm_want_ptrs.md, mm_got.md) {
				mmSetTrailer.t.Errorf("ServerStreamMock.SetTrailer got unexpected parameter md, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetTrailer.SetTrailerMock.defaultExpectation.expectationOrigins.originMd, *mm_want_ptrs.md, mm_got.md, minimock.Diff(*mm_want_ptrs.md, mm_got.md))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTrailer.t.Errorf("ServerStreamMock.SetTrailer got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetTrailer.SetTrailerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTrailer.funcSetTrailer != nil {
		mmSetTrailer.funcSetTrailer(md)
		return
	}
	mmSetTrailer.t.Fatalf("Unexpected call to ServerStreamMock.SetTrailer. %v", md)

}

// SetTrailerAfterCounter returns a count of finished ServerStreamMock.SetTrailer invocations
func (mmSetTrailer *ServerStreamMock) SetTrailerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.afterSetTrailerCounter)
}

// SetTrailerBeforeCounter returns a count of ServerStreamMock.SetTrailer invocations
func (mmSetTrailer *ServerStreamMock) SetTrailerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.beforeSetTrailerCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SetTrailer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTrailer *mServerStreamMockSetTrailer) Calls() []*ServerStreamMockSetTrailerParams {
	mmSetTrailer.mutex.RLock()

	argCopy := make([]*ServerStreamMockSetTrailerParams, len(mmSetTrailer.callArgs))
	copy(argCopy, mmSetTrailer.callArgs)

	mmSetTrailer.mutex.RUnlock()

	return argCopy
}

// MinimockSetTrailerDone returns true if the count of the SetTrailer invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSetTrailerDone() bool {
	if m.SetTrailerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetTrailerMock.invocationsDone()
}

// MinimockSetTrailerInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSetTrailerInspect() {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SetTrailer at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetTrailerCounter := mm_atomic.LoadUint64(&m.afterSetTrailerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && afterSetTrailerCounter < 1 {
		if m.SetTrailerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServerStreamMock.SetTrailer at\n%s", m.SetTrailerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SetTrailer at\n%s with params: %#v", m.SetTrailerMock.defaultExpectation.expectationOrigins.origin, *m.SetTrailerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && afterSetTrailerCounter < 1 {
		m.t.Errorf("Expected call to ServerStreamMock.SetTrailer at\n%s", m.funcSetTrailerOrigin)
	}

	if !m.SetTrailerMock.invocationsDone() && afterSetTrailerCounter > 0 {
		m.t.Errorf("Expected %d calls to ServerStreamMock.SetTrailer at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetTrailerMock.expectedInvocations), m.SetTrailerMock.expectedInvocationsOrigin, afterSetTrailerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServerStreamMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockContextInspect()

			m.MinimockRecvMsgInspect()

			m.MinimockSendHeaderInspect()

			m.MinimockSendMsgInspect()

			m.MinimockSetHeaderInspect()

			m.MinimockSetTrailerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServerStreamMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServerStreamMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContextDone() &&
		m.MinimockRecvMsgDone() &&
		m.MinimockSendHeaderDone() &&
		m.MinimockSendMsgDone() &&
		m.MinimockSetHeaderDone() &&
		m.MinimockSetTrailerDone()
}
