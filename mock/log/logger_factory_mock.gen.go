// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package log

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.uber.org/zap"
)

// LoggerFactoryMock implements LoggerFactory
type LoggerFactoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetZapLogger          func(ctx context.Context) (lp1 *zap.Logger, err error)
	funcGetZapLoggerOrigin    string
	inspectFuncGetZapLogger   func(ctx context.Context)
	afterGetZapLoggerCounter  uint64
	beforeGetZapLoggerCounter uint64
	GetZapLoggerMock          mLoggerFactoryMockGetZapLogger
}

// NewLoggerFactoryMock returns a mock for LoggerFactory
func NewLoggerFactoryMock(t minimock.Tester) *LoggerFactoryMock {
	m := &LoggerFactoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetZapLoggerMock = mLoggerFactoryMockGetZapLogger{mock: m}
	m.GetZapLoggerMock.callArgs = []*LoggerFactoryMockGetZapLoggerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerFactoryMockGetZapLogger struct {
	optional           bool
	mock               *LoggerFactoryMock
	defaultExpectation *LoggerFactoryMockGetZapLoggerExpectation
	expectations       []*LoggerFactoryMockGetZapLoggerExpectation

	callArgs []*LoggerFactoryMockGetZapLoggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFactoryMockGetZapLoggerExpectation specifies expectation struct of the LoggerFactory.GetZapLogger
type LoggerFactoryMockGetZapLoggerExpectation struct {
	mock               *LoggerFactoryMock
	params             *LoggerFactoryMockGetZapLoggerParams
	paramPtrs          *LoggerFactoryMockGetZapLoggerParamPtrs
	expectationOrigins LoggerFactoryMockGetZapLoggerExpectationOrigins
	results            *LoggerFactoryMockGetZapLoggerResults
	returnOrigin       string
	Counter            uint64
}

// LoggerFactoryMockGetZapLoggerParams contains parameters of the LoggerFactory.GetZapLogger
type LoggerFactoryMockGetZapLoggerParams struct {
	ctx context.Context
}

// LoggerFactoryMockGetZapLoggerParamPtrs contains pointers to parameters of the LoggerFactory.GetZapLogger
type LoggerFactoryMockGetZapLoggerParamPtrs struct {
	ctx *context.Context
}

// LoggerFactoryMockGetZapLoggerResults contains results of the LoggerFactory.GetZapLogger
type LoggerFactoryMockGetZapLoggerResults struct {
	lp1 *zap.Logger
	err error
}

// LoggerFactoryMockGetZapLoggerOrigins contains origins of expectations of the LoggerFactory.GetZapLogger
type LoggerFactoryMockGetZapLoggerExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Optional() *mLoggerFactoryMockGetZapLogger {
	mmGetZapLogger.optional = true
	return mmGetZapLogger
}

// Expect sets up expected params for LoggerFactory.GetZapLogger
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Expect(ctx context.Context) *mLoggerFactoryMockGetZapLogger {
	if mmGetZapLogger.mock.funcGetZapLogger != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by Set")
	}

	if mmGetZapLogger.defaultExpectation == nil {
		mmGetZapLogger.defaultExpectation = &LoggerFactoryMockGetZapLoggerExpectation{}
	}

	if mmGetZapLogger.defaultExpectation.paramPtrs != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by ExpectParams functions")
	}

	mmGetZapLogger.defaultExpectation.params = &LoggerFactoryMockGetZapLoggerParams{ctx}
	mmGetZapLogger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetZapLogger.expectations {
		if minimock.Equal(e.params, mmGetZapLogger.defaultExpectation.params) {
			mmGetZapLogger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetZapLogger.defaultExpectation.params)
		}
	}

	return mmGetZapLogger
}

// ExpectCtxParam1 sets up expected param ctx for LoggerFactory.GetZapLogger
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) ExpectCtxParam1(ctx context.Context) *mLoggerFactoryMockGetZapLogger {
	if mmGetZapLogger.mock.funcGetZapLogger != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by Set")
	}

	if mmGetZapLogger.defaultExpectation == nil {
		mmGetZapLogger.defaultExpectation = &LoggerFactoryMockGetZapLoggerExpectation{}
	}

	if mmGetZapLogger.defaultExpectation.params != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by Expect")
	}

	if mmGetZapLogger.defaultExpectation.paramPtrs == nil {
		mmGetZapLogger.defaultExpectation.paramPtrs = &LoggerFactoryMockGetZapLoggerParamPtrs{}
	}
	mmGetZapLogger.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetZapLogger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetZapLogger
}

// Inspect accepts an inspector function that has same arguments as the LoggerFactory.GetZapLogger
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Inspect(f func(ctx context.Context)) *mLoggerFactoryMockGetZapLogger {
	if mmGetZapLogger.mock.inspectFuncGetZapLogger != nil {
		mmGetZapLogger.mock.t.Fatalf("Inspect function is already set for LoggerFactoryMock.GetZapLogger")
	}

	mmGetZapLogger.mock.inspectFuncGetZapLogger = f

	return mmGetZapLogger
}

// Return sets up results that will be returned by LoggerFactory.GetZapLogger
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Return(lp1 *zap.Logger, err error) *LoggerFactoryMock {
	if mmGetZapLogger.mock.funcGetZapLogger != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by Set")
	}

	if mmGetZapLogger.defaultExpectation == nil {
		mmGetZapLogger.defaultExpectation = &LoggerFactoryMockGetZapLoggerExpectation{mock: mmGetZapLogger.mock}
	}
	mmGetZapLogger.defaultExpectation.results = &LoggerFactoryMockGetZapLoggerResults{lp1, err}
	mmGetZapLogger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetZapLogger.mock
}

// Set uses given function f to mock the LoggerFactory.GetZapLogger method
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Set(f func(ctx context.Context) (lp1 *zap.Logger, err error)) *LoggerFactoryMock {
	if mmGetZapLogger.defaultExpectation != nil {
		mmGetZapLogger.mock.t.Fatalf("Default expectation is already set for the LoggerFactory.GetZapLogger method")
	}

	if len(mmGetZapLogger.expectations) > 0 {
		mmGetZapLogger.mock.t.Fatalf("Some expectations are already set for the LoggerFactory.GetZapLogger method")
	}

	mmGetZapLogger.mock.funcGetZapLogger = f
	mmGetZapLogger.mock.funcGetZapLoggerOrigin = minimock.CallerInfo(1)
	return mmGetZapLogger.mock
}

// When sets expectation for the LoggerFactory.GetZapLogger which will trigger the result defined by the following
// Then helper
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) When(ctx context.Context) *LoggerFactoryMockGetZapLoggerExpectation {
	if mmGetZapLogger.mock.funcGetZapLogger != nil {
		mmGetZapLogger.mock.t.Fatalf("LoggerFactoryMock.GetZapLogger mock is already set by Set")
	}

	expectation := &LoggerFactoryMockGetZapLoggerExpectation{
		mock:               mmGetZapLogger.mock,
		params:             &LoggerFactoryMockGetZapLoggerParams{ctx},
		expectationOrigins: LoggerFactoryMockGetZapLoggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetZapLogger.expectations = append(mmGetZapLogger.expectations, expectation)
	return expectation
}

// Then sets up LoggerFactory.GetZapLogger return parameters for the expectation previously defined by the When method
func (e *LoggerFactoryMockGetZapLoggerExpectation) Then(lp1 *zap.Logger, err error) *LoggerFactoryMock {
	e.results = &LoggerFactoryMockGetZapLoggerResults{lp1, err}
	return e.mock
}

// Times sets number of times LoggerFactory.GetZapLogger should be invoked
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Times(n uint64) *mLoggerFactoryMockGetZapLogger {
	if n == 0 {
		mmGetZapLogger.mock.t.Fatalf("Times of LoggerFactoryMock.GetZapLogger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetZapLogger.expectedInvocations, n)
	mmGetZapLogger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetZapLogger
}

func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) invocationsDone() bool {
	if len(mmGetZapLogger.expectations) == 0 && mmGetZapLogger.defaultExpectation == nil && mmGetZapLogger.mock.funcGetZapLogger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetZapLogger.mock.afterGetZapLoggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetZapLogger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetZapLogger implements LoggerFactory
func (mmGetZapLogger *LoggerFactoryMock) GetZapLogger(ctx context.Context) (lp1 *zap.Logger, err error) {
	mm_atomic.AddUint64(&mmGetZapLogger.beforeGetZapLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetZapLogger.afterGetZapLoggerCounter, 1)

	mmGetZapLogger.t.Helper()

	if mmGetZapLogger.inspectFuncGetZapLogger != nil {
		mmGetZapLogger.inspectFuncGetZapLogger(ctx)
	}

	mm_params := LoggerFactoryMockGetZapLoggerParams{ctx}

	// Record call args
	mmGetZapLogger.GetZapLoggerMock.mutex.Lock()
	mmGetZapLogger.GetZapLoggerMock.callArgs = append(mmGetZapLogger.GetZapLoggerMock.callArgs, &mm_params)
	mmGetZapLogger.GetZapLoggerMock.mutex.Unlock()

	for _, e := range mmGetZapLogger.GetZapLoggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetZapLogger.GetZapLoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetZapLogger.GetZapLoggerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetZapLogger.GetZapLoggerMock.defaultExpectation.params
		mm_want_ptrs := mmGetZapLogger.GetZapLoggerMock.defaultExpectation.paramPtrs

		mm_got := LoggerFactoryMockGetZapLoggerParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetZapLogger.t.Errorf("LoggerFactoryMock.GetZapLogger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetZapLogger.GetZapLoggerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetZapLogger.t.Errorf("LoggerFactoryMock.GetZapLogger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetZapLogger.GetZapLoggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetZapLogger.GetZapLoggerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetZapLogger.t.Fatal("No results are set for the LoggerFactoryMock.GetZapLogger")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetZapLogger.funcGetZapLogger != nil {
		return mmGetZapLogger.funcGetZapLogger(ctx)
	}
	mmGetZapLogger.t.Fatalf("Unexpected call to LoggerFactoryMock.GetZapLogger. %v", ctx)
	return
}

// GetZapLoggerAfterCounter returns a count of finished LoggerFactoryMock.GetZapLogger invocations
func (mmGetZapLogger *LoggerFactoryMock) GetZapLoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetZapLogger.afterGetZapLoggerCounter)
}

// GetZapLoggerBeforeCounter returns a count of LoggerFactoryMock.GetZapLogger invocations
func (mmGetZapLogger *LoggerFactoryMock) GetZapLoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetZapLogger.beforeGetZapLoggerCounter)
}

// Calls returns a list of arguments used in each call to LoggerFactoryMock.GetZapLogger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetZapLogger *mLoggerFactoryMockGetZapLogger) Calls() []*LoggerFactoryMockGetZapLoggerParams {
	mmGetZapLogger.mutex.RLock()

	argCopy := make([]*LoggerFactoryMockGetZapLoggerParams, len(mmGetZapLogger.callArgs))
	copy(argCopy, mmGetZapLogger.callArgs)

	mmGetZapLogger.mutex.RUnlock()

	return argCopy
}

// MinimockGetZapLoggerDone returns true if the count of the GetZapLogger invocations corresponds
// the number of defined expectations
func (m *LoggerFactoryMock) MinimockGetZapLoggerDone() bool {
	if m.GetZapLoggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetZapLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetZapLoggerMock.invocationsDone()
}

// MinimockGetZapLoggerInspect logs each unmet expectation
func (m *LoggerFactoryMock) MinimockGetZapLoggerInspect() {
	for _, e := range m.GetZapLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFactoryMock.GetZapLogger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetZapLoggerCounter := mm_atomic.LoadUint64(&m.afterGetZapLoggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetZapLoggerMock.defaultExpectation != nil && afterGetZapLoggerCounter < 1 {
		if m.GetZapLoggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFactoryMock.GetZapLogger at\n%s", m.GetZapLoggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFactoryMock.GetZapLogger at\n%s with params: %#v", m.GetZapLoggerMock.defaultExpectation.expectationOrigins.origin, *m.GetZapLoggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetZapLogger != nil && afterGetZapLoggerCounter < 1 {
		m.t.Errorf("Expected call to LoggerFactoryMock.GetZapLogger at\n%s", m.funcGetZapLoggerOrigin)
	}

	if !m.GetZapLoggerMock.invocationsDone() && afterGetZapLoggerCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFactoryMock.GetZapLogger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetZapLoggerMock.expectedInvocations), m.GetZapLoggerMock.expectedInvocationsOrigin, afterGetZapLoggerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerFactoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetZapLoggerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerFactoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerFactoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetZapLoggerDone()
}
