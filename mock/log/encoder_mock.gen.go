// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package log

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.uber.org/zap/buffer"
	"go.uber.org/zap/zapcore"
)

// EncoderMock implements Encoder
type EncoderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddArray          func(key string, marshaler zapcore.ArrayMarshaler) (err error)
	funcAddArrayOrigin    string
	inspectFuncAddArray   func(key string, marshaler zapcore.ArrayMarshaler)
	afterAddArrayCounter  uint64
	beforeAddArrayCounter uint64
	AddArrayMock          mEncoderMockAddArray

	funcAddBinary          func(key string, value []byte)
	funcAddBinaryOrigin    string
	inspectFuncAddBinary   func(key string, value []byte)
	afterAddBinaryCounter  uint64
	beforeAddBinaryCounter uint64
	AddBinaryMock          mEncoderMockAddBinary

	funcAddBool          func(key string, value bool)
	funcAddBoolOrigin    string
	inspectFuncAddBool   func(key string, value bool)
	afterAddBoolCounter  uint64
	beforeAddBoolCounter uint64
	AddBoolMock          mEncoderMockAddBool

	funcAddByteString          func(key string, value []byte)
	funcAddByteStringOrigin    string
	inspectFuncAddByteString   func(key string, value []byte)
	afterAddByteStringCounter  uint64
	beforeAddByteStringCounter uint64
	AddByteStringMock          mEncoderMockAddByteString

	funcAddComplex128          func(key string, value complex128)
	funcAddComplex128Origin    string
	inspectFuncAddComplex128   func(key string, value complex128)
	afterAddComplex128Counter  uint64
	beforeAddComplex128Counter uint64
	AddComplex128Mock          mEncoderMockAddComplex128

	funcAddComplex64          func(key string, value complex64)
	funcAddComplex64Origin    string
	inspectFuncAddComplex64   func(key string, value complex64)
	afterAddComplex64Counter  uint64
	beforeAddComplex64Counter uint64
	AddComplex64Mock          mEncoderMockAddComplex64

	funcAddDuration          func(key string, value time.Duration)
	funcAddDurationOrigin    string
	inspectFuncAddDuration   func(key string, value time.Duration)
	afterAddDurationCounter  uint64
	beforeAddDurationCounter uint64
	AddDurationMock          mEncoderMockAddDuration

	funcAddFloat32          func(key string, value float32)
	funcAddFloat32Origin    string
	inspectFuncAddFloat32   func(key string, value float32)
	afterAddFloat32Counter  uint64
	beforeAddFloat32Counter uint64
	AddFloat32Mock          mEncoderMockAddFloat32

	funcAddFloat64          func(key string, value float64)
	funcAddFloat64Origin    string
	inspectFuncAddFloat64   func(key string, value float64)
	afterAddFloat64Counter  uint64
	beforeAddFloat64Counter uint64
	AddFloat64Mock          mEncoderMockAddFloat64

	funcAddInt          func(key string, value int)
	funcAddIntOrigin    string
	inspectFuncAddInt   func(key string, value int)
	afterAddIntCounter  uint64
	beforeAddIntCounter uint64
	AddIntMock          mEncoderMockAddInt

	funcAddInt16          func(key string, value int16)
	funcAddInt16Origin    string
	inspectFuncAddInt16   func(key string, value int16)
	afterAddInt16Counter  uint64
	beforeAddInt16Counter uint64
	AddInt16Mock          mEncoderMockAddInt16

	funcAddInt32          func(key string, value int32)
	funcAddInt32Origin    string
	inspectFuncAddInt32   func(key string, value int32)
	afterAddInt32Counter  uint64
	beforeAddInt32Counter uint64
	AddInt32Mock          mEncoderMockAddInt32

	funcAddInt64          func(key string, value int64)
	funcAddInt64Origin    string
	inspectFuncAddInt64   func(key string, value int64)
	afterAddInt64Counter  uint64
	beforeAddInt64Counter uint64
	AddInt64Mock          mEncoderMockAddInt64

	funcAddInt8          func(key string, value int8)
	funcAddInt8Origin    string
	inspectFuncAddInt8   func(key string, value int8)
	afterAddInt8Counter  uint64
	beforeAddInt8Counter uint64
	AddInt8Mock          mEncoderMockAddInt8

	funcAddObject          func(key string, marshaler zapcore.ObjectMarshaler) (err error)
	funcAddObjectOrigin    string
	inspectFuncAddObject   func(key string, marshaler zapcore.ObjectMarshaler)
	afterAddObjectCounter  uint64
	beforeAddObjectCounter uint64
	AddObjectMock          mEncoderMockAddObject

	funcAddReflected          func(key string, value interface{}) (err error)
	funcAddReflectedOrigin    string
	inspectFuncAddReflected   func(key string, value interface{})
	afterAddReflectedCounter  uint64
	beforeAddReflectedCounter uint64
	AddReflectedMock          mEncoderMockAddReflected

	funcAddString          func(key string, value string)
	funcAddStringOrigin    string
	inspectFuncAddString   func(key string, value string)
	afterAddStringCounter  uint64
	beforeAddStringCounter uint64
	AddStringMock          mEncoderMockAddString

	funcAddTime          func(key string, value time.Time)
	funcAddTimeOrigin    string
	inspectFuncAddTime   func(key string, value time.Time)
	afterAddTimeCounter  uint64
	beforeAddTimeCounter uint64
	AddTimeMock          mEncoderMockAddTime

	funcAddUint          func(key string, value uint)
	funcAddUintOrigin    string
	inspectFuncAddUint   func(key string, value uint)
	afterAddUintCounter  uint64
	beforeAddUintCounter uint64
	AddUintMock          mEncoderMockAddUint

	funcAddUint16          func(key string, value uint16)
	funcAddUint16Origin    string
	inspectFuncAddUint16   func(key string, value uint16)
	afterAddUint16Counter  uint64
	beforeAddUint16Counter uint64
	AddUint16Mock          mEncoderMockAddUint16

	funcAddUint32          func(key string, value uint32)
	funcAddUint32Origin    string
	inspectFuncAddUint32   func(key string, value uint32)
	afterAddUint32Counter  uint64
	beforeAddUint32Counter uint64
	AddUint32Mock          mEncoderMockAddUint32

	funcAddUint64          func(key string, value uint64)
	funcAddUint64Origin    string
	inspectFuncAddUint64   func(key string, value uint64)
	afterAddUint64Counter  uint64
	beforeAddUint64Counter uint64
	AddUint64Mock          mEncoderMockAddUint64

	funcAddUint8          func(key string, value uint8)
	funcAddUint8Origin    string
	inspectFuncAddUint8   func(key string, value uint8)
	afterAddUint8Counter  uint64
	beforeAddUint8Counter uint64
	AddUint8Mock          mEncoderMockAddUint8

	funcAddUintptr          func(key string, value uintptr)
	funcAddUintptrOrigin    string
	inspectFuncAddUintptr   func(key string, value uintptr)
	afterAddUintptrCounter  uint64
	beforeAddUintptrCounter uint64
	AddUintptrMock          mEncoderMockAddUintptr

	funcClone          func() (e1 zapcore.Encoder)
	funcCloneOrigin    string
	inspectFuncClone   func()
	afterCloneCounter  uint64
	beforeCloneCounter uint64
	CloneMock          mEncoderMockClone

	funcEncodeEntry          func(entry zapcore.Entry, fields []zapcore.Field) (bp1 *buffer.Buffer, err error)
	funcEncodeEntryOrigin    string
	inspectFuncEncodeEntry   func(entry zapcore.Entry, fields []zapcore.Field)
	afterEncodeEntryCounter  uint64
	beforeEncodeEntryCounter uint64
	EncodeEntryMock          mEncoderMockEncodeEntry

	funcOpenNamespace          func(key string)
	funcOpenNamespaceOrigin    string
	inspectFuncOpenNamespace   func(key string)
	afterOpenNamespaceCounter  uint64
	beforeOpenNamespaceCounter uint64
	OpenNamespaceMock          mEncoderMockOpenNamespace
}

// NewEncoderMock returns a mock for Encoder
func NewEncoderMock(t minimock.Tester) *EncoderMock {
	m := &EncoderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddArrayMock = mEncoderMockAddArray{mock: m}
	m.AddArrayMock.callArgs = []*EncoderMockAddArrayParams{}

	m.AddBinaryMock = mEncoderMockAddBinary{mock: m}
	m.AddBinaryMock.callArgs = []*EncoderMockAddBinaryParams{}

	m.AddBoolMock = mEncoderMockAddBool{mock: m}
	m.AddBoolMock.callArgs = []*EncoderMockAddBoolParams{}

	m.AddByteStringMock = mEncoderMockAddByteString{mock: m}
	m.AddByteStringMock.callArgs = []*EncoderMockAddByteStringParams{}

	m.AddComplex128Mock = mEncoderMockAddComplex128{mock: m}
	m.AddComplex128Mock.callArgs = []*EncoderMockAddComplex128Params{}

	m.AddComplex64Mock = mEncoderMockAddComplex64{mock: m}
	m.AddComplex64Mock.callArgs = []*EncoderMockAddComplex64Params{}

	m.AddDurationMock = mEncoderMockAddDuration{mock: m}
	m.AddDurationMock.callArgs = []*EncoderMockAddDurationParams{}

	m.AddFloat32Mock = mEncoderMockAddFloat32{mock: m}
	m.AddFloat32Mock.callArgs = []*EncoderMockAddFloat32Params{}

	m.AddFloat64Mock = mEncoderMockAddFloat64{mock: m}
	m.AddFloat64Mock.callArgs = []*EncoderMockAddFloat64Params{}

	m.AddIntMock = mEncoderMockAddInt{mock: m}
	m.AddIntMock.callArgs = []*EncoderMockAddIntParams{}

	m.AddInt16Mock = mEncoderMockAddInt16{mock: m}
	m.AddInt16Mock.callArgs = []*EncoderMockAddInt16Params{}

	m.AddInt32Mock = mEncoderMockAddInt32{mock: m}
	m.AddInt32Mock.callArgs = []*EncoderMockAddInt32Params{}

	m.AddInt64Mock = mEncoderMockAddInt64{mock: m}
	m.AddInt64Mock.callArgs = []*EncoderMockAddInt64Params{}

	m.AddInt8Mock = mEncoderMockAddInt8{mock: m}
	m.AddInt8Mock.callArgs = []*EncoderMockAddInt8Params{}

	m.AddObjectMock = mEncoderMockAddObject{mock: m}
	m.AddObjectMock.callArgs = []*EncoderMockAddObjectParams{}

	m.AddReflectedMock = mEncoderMockAddReflected{mock: m}
	m.AddReflectedMock.callArgs = []*EncoderMockAddReflectedParams{}

	m.AddStringMock = mEncoderMockAddString{mock: m}
	m.AddStringMock.callArgs = []*EncoderMockAddStringParams{}

	m.AddTimeMock = mEncoderMockAddTime{mock: m}
	m.AddTimeMock.callArgs = []*EncoderMockAddTimeParams{}

	m.AddUintMock = mEncoderMockAddUint{mock: m}
	m.AddUintMock.callArgs = []*EncoderMockAddUintParams{}

	m.AddUint16Mock = mEncoderMockAddUint16{mock: m}
	m.AddUint16Mock.callArgs = []*EncoderMockAddUint16Params{}

	m.AddUint32Mock = mEncoderMockAddUint32{mock: m}
	m.AddUint32Mock.callArgs = []*EncoderMockAddUint32Params{}

	m.AddUint64Mock = mEncoderMockAddUint64{mock: m}
	m.AddUint64Mock.callArgs = []*EncoderMockAddUint64Params{}

	m.AddUint8Mock = mEncoderMockAddUint8{mock: m}
	m.AddUint8Mock.callArgs = []*EncoderMockAddUint8Params{}

	m.AddUintptrMock = mEncoderMockAddUintptr{mock: m}
	m.AddUintptrMock.callArgs = []*EncoderMockAddUintptrParams{}

	m.CloneMock = mEncoderMockClone{mock: m}

	m.EncodeEntryMock = mEncoderMockEncodeEntry{mock: m}
	m.EncodeEntryMock.callArgs = []*EncoderMockEncodeEntryParams{}

	m.OpenNamespaceMock = mEncoderMockOpenNamespace{mock: m}
	m.OpenNamespaceMock.callArgs = []*EncoderMockOpenNamespaceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEncoderMockAddArray struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddArrayExpectation
	expectations       []*EncoderMockAddArrayExpectation

	callArgs []*EncoderMockAddArrayParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddArrayExpectation specifies expectation struct of the Encoder.AddArray
type EncoderMockAddArrayExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddArrayParams
	paramPtrs          *EncoderMockAddArrayParamPtrs
	expectationOrigins EncoderMockAddArrayExpectationOrigins
	results            *EncoderMockAddArrayResults
	returnOrigin       string
	Counter            uint64
}

// EncoderMockAddArrayParams contains parameters of the Encoder.AddArray
type EncoderMockAddArrayParams struct {
	key       string
	marshaler zapcore.ArrayMarshaler
}

// EncoderMockAddArrayParamPtrs contains pointers to parameters of the Encoder.AddArray
type EncoderMockAddArrayParamPtrs struct {
	key       *string
	marshaler *zapcore.ArrayMarshaler
}

// EncoderMockAddArrayResults contains results of the Encoder.AddArray
type EncoderMockAddArrayResults struct {
	err error
}

// EncoderMockAddArrayOrigins contains origins of expectations of the Encoder.AddArray
type EncoderMockAddArrayExpectationOrigins struct {
	origin          string
	originKey       string
	originMarshaler string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddArray *mEncoderMockAddArray) Optional() *mEncoderMockAddArray {
	mmAddArray.optional = true
	return mmAddArray
}

// Expect sets up expected params for Encoder.AddArray
func (mmAddArray *mEncoderMockAddArray) Expect(key string, marshaler zapcore.ArrayMarshaler) *mEncoderMockAddArray {
	if mmAddArray.mock.funcAddArray != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Set")
	}

	if mmAddArray.defaultExpectation == nil {
		mmAddArray.defaultExpectation = &EncoderMockAddArrayExpectation{}
	}

	if mmAddArray.defaultExpectation.paramPtrs != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by ExpectParams functions")
	}

	mmAddArray.defaultExpectation.params = &EncoderMockAddArrayParams{key, marshaler}
	mmAddArray.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddArray.expectations {
		if minimock.Equal(e.params, mmAddArray.defaultExpectation.params) {
			mmAddArray.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddArray.defaultExpectation.params)
		}
	}

	return mmAddArray
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddArray
func (mmAddArray *mEncoderMockAddArray) ExpectKeyParam1(key string) *mEncoderMockAddArray {
	if mmAddArray.mock.funcAddArray != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Set")
	}

	if mmAddArray.defaultExpectation == nil {
		mmAddArray.defaultExpectation = &EncoderMockAddArrayExpectation{}
	}

	if mmAddArray.defaultExpectation.params != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Expect")
	}

	if mmAddArray.defaultExpectation.paramPtrs == nil {
		mmAddArray.defaultExpectation.paramPtrs = &EncoderMockAddArrayParamPtrs{}
	}
	mmAddArray.defaultExpectation.paramPtrs.key = &key
	mmAddArray.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddArray
}

// ExpectMarshalerParam2 sets up expected param marshaler for Encoder.AddArray
func (mmAddArray *mEncoderMockAddArray) ExpectMarshalerParam2(marshaler zapcore.ArrayMarshaler) *mEncoderMockAddArray {
	if mmAddArray.mock.funcAddArray != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Set")
	}

	if mmAddArray.defaultExpectation == nil {
		mmAddArray.defaultExpectation = &EncoderMockAddArrayExpectation{}
	}

	if mmAddArray.defaultExpectation.params != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Expect")
	}

	if mmAddArray.defaultExpectation.paramPtrs == nil {
		mmAddArray.defaultExpectation.paramPtrs = &EncoderMockAddArrayParamPtrs{}
	}
	mmAddArray.defaultExpectation.paramPtrs.marshaler = &marshaler
	mmAddArray.defaultExpectation.expectationOrigins.originMarshaler = minimock.CallerInfo(1)

	return mmAddArray
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddArray
func (mmAddArray *mEncoderMockAddArray) Inspect(f func(key string, marshaler zapcore.ArrayMarshaler)) *mEncoderMockAddArray {
	if mmAddArray.mock.inspectFuncAddArray != nil {
		mmAddArray.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddArray")
	}

	mmAddArray.mock.inspectFuncAddArray = f

	return mmAddArray
}

// Return sets up results that will be returned by Encoder.AddArray
func (mmAddArray *mEncoderMockAddArray) Return(err error) *EncoderMock {
	if mmAddArray.mock.funcAddArray != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Set")
	}

	if mmAddArray.defaultExpectation == nil {
		mmAddArray.defaultExpectation = &EncoderMockAddArrayExpectation{mock: mmAddArray.mock}
	}
	mmAddArray.defaultExpectation.results = &EncoderMockAddArrayResults{err}
	mmAddArray.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddArray.mock
}

// Set uses given function f to mock the Encoder.AddArray method
func (mmAddArray *mEncoderMockAddArray) Set(f func(key string, marshaler zapcore.ArrayMarshaler) (err error)) *EncoderMock {
	if mmAddArray.defaultExpectation != nil {
		mmAddArray.mock.t.Fatalf("Default expectation is already set for the Encoder.AddArray method")
	}

	if len(mmAddArray.expectations) > 0 {
		mmAddArray.mock.t.Fatalf("Some expectations are already set for the Encoder.AddArray method")
	}

	mmAddArray.mock.funcAddArray = f
	mmAddArray.mock.funcAddArrayOrigin = minimock.CallerInfo(1)
	return mmAddArray.mock
}

// When sets expectation for the Encoder.AddArray which will trigger the result defined by the following
// Then helper
func (mmAddArray *mEncoderMockAddArray) When(key string, marshaler zapcore.ArrayMarshaler) *EncoderMockAddArrayExpectation {
	if mmAddArray.mock.funcAddArray != nil {
		mmAddArray.mock.t.Fatalf("EncoderMock.AddArray mock is already set by Set")
	}

	expectation := &EncoderMockAddArrayExpectation{
		mock:               mmAddArray.mock,
		params:             &EncoderMockAddArrayParams{key, marshaler},
		expectationOrigins: EncoderMockAddArrayExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddArray.expectations = append(mmAddArray.expectations, expectation)
	return expectation
}

// Then sets up Encoder.AddArray return parameters for the expectation previously defined by the When method
func (e *EncoderMockAddArrayExpectation) Then(err error) *EncoderMock {
	e.results = &EncoderMockAddArrayResults{err}
	return e.mock
}

// Times sets number of times Encoder.AddArray should be invoked
func (mmAddArray *mEncoderMockAddArray) Times(n uint64) *mEncoderMockAddArray {
	if n == 0 {
		mmAddArray.mock.t.Fatalf("Times of EncoderMock.AddArray mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddArray.expectedInvocations, n)
	mmAddArray.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddArray
}

func (mmAddArray *mEncoderMockAddArray) invocationsDone() bool {
	if len(mmAddArray.expectations) == 0 && mmAddArray.defaultExpectation == nil && mmAddArray.mock.funcAddArray == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddArray.mock.afterAddArrayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddArray.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddArray implements Encoder
func (mmAddArray *EncoderMock) AddArray(key string, marshaler zapcore.ArrayMarshaler) (err error) {
	mm_atomic.AddUint64(&mmAddArray.beforeAddArrayCounter, 1)
	defer mm_atomic.AddUint64(&mmAddArray.afterAddArrayCounter, 1)

	mmAddArray.t.Helper()

	if mmAddArray.inspectFuncAddArray != nil {
		mmAddArray.inspectFuncAddArray(key, marshaler)
	}

	mm_params := EncoderMockAddArrayParams{key, marshaler}

	// Record call args
	mmAddArray.AddArrayMock.mutex.Lock()
	mmAddArray.AddArrayMock.callArgs = append(mmAddArray.AddArrayMock.callArgs, &mm_params)
	mmAddArray.AddArrayMock.mutex.Unlock()

	for _, e := range mmAddArray.AddArrayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddArray.AddArrayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddArray.AddArrayMock.defaultExpectation.Counter, 1)
		mm_want := mmAddArray.AddArrayMock.defaultExpectation.params
		mm_want_ptrs := mmAddArray.AddArrayMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddArrayParams{key, marshaler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddArray.t.Errorf("EncoderMock.AddArray got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddArray.AddArrayMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.marshaler != nil && !minimock.Equal(*mm_want_ptrs.marshaler, mm_got.marshaler) {
				mmAddArray.t.Errorf("EncoderMock.AddArray got unexpected parameter marshaler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddArray.AddArrayMock.defaultExpectation.expectationOrigins.originMarshaler, *mm_want_ptrs.marshaler, mm_got.marshaler, minimock.Diff(*mm_want_ptrs.marshaler, mm_got.marshaler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddArray.t.Errorf("EncoderMock.AddArray got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddArray.AddArrayMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddArray.AddArrayMock.defaultExpectation.results
		if mm_results == nil {
			mmAddArray.t.Fatal("No results are set for the EncoderMock.AddArray")
		}
		return (*mm_results).err
	}
	if mmAddArray.funcAddArray != nil {
		return mmAddArray.funcAddArray(key, marshaler)
	}
	mmAddArray.t.Fatalf("Unexpected call to EncoderMock.AddArray. %v %v", key, marshaler)
	return
}

// AddArrayAfterCounter returns a count of finished EncoderMock.AddArray invocations
func (mmAddArray *EncoderMock) AddArrayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddArray.afterAddArrayCounter)
}

// AddArrayBeforeCounter returns a count of EncoderMock.AddArray invocations
func (mmAddArray *EncoderMock) AddArrayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddArray.beforeAddArrayCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddArray.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddArray *mEncoderMockAddArray) Calls() []*EncoderMockAddArrayParams {
	mmAddArray.mutex.RLock()

	argCopy := make([]*EncoderMockAddArrayParams, len(mmAddArray.callArgs))
	copy(argCopy, mmAddArray.callArgs)

	mmAddArray.mutex.RUnlock()

	return argCopy
}

// MinimockAddArrayDone returns true if the count of the AddArray invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddArrayDone() bool {
	if m.AddArrayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddArrayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddArrayMock.invocationsDone()
}

// MinimockAddArrayInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddArrayInspect() {
	for _, e := range m.AddArrayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddArray at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddArrayCounter := mm_atomic.LoadUint64(&m.afterAddArrayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddArrayMock.defaultExpectation != nil && afterAddArrayCounter < 1 {
		if m.AddArrayMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddArray at\n%s", m.AddArrayMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddArray at\n%s with params: %#v", m.AddArrayMock.defaultExpectation.expectationOrigins.origin, *m.AddArrayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddArray != nil && afterAddArrayCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddArray at\n%s", m.funcAddArrayOrigin)
	}

	if !m.AddArrayMock.invocationsDone() && afterAddArrayCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddArray at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddArrayMock.expectedInvocations), m.AddArrayMock.expectedInvocationsOrigin, afterAddArrayCounter)
	}
}

type mEncoderMockAddBinary struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddBinaryExpectation
	expectations       []*EncoderMockAddBinaryExpectation

	callArgs []*EncoderMockAddBinaryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddBinaryExpectation specifies expectation struct of the Encoder.AddBinary
type EncoderMockAddBinaryExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddBinaryParams
	paramPtrs          *EncoderMockAddBinaryParamPtrs
	expectationOrigins EncoderMockAddBinaryExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddBinaryParams contains parameters of the Encoder.AddBinary
type EncoderMockAddBinaryParams struct {
	key   string
	value []byte
}

// EncoderMockAddBinaryParamPtrs contains pointers to parameters of the Encoder.AddBinary
type EncoderMockAddBinaryParamPtrs struct {
	key   *string
	value *[]byte
}

// EncoderMockAddBinaryOrigins contains origins of expectations of the Encoder.AddBinary
type EncoderMockAddBinaryExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddBinary *mEncoderMockAddBinary) Optional() *mEncoderMockAddBinary {
	mmAddBinary.optional = true
	return mmAddBinary
}

// Expect sets up expected params for Encoder.AddBinary
func (mmAddBinary *mEncoderMockAddBinary) Expect(key string, value []byte) *mEncoderMockAddBinary {
	if mmAddBinary.mock.funcAddBinary != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Set")
	}

	if mmAddBinary.defaultExpectation == nil {
		mmAddBinary.defaultExpectation = &EncoderMockAddBinaryExpectation{}
	}

	if mmAddBinary.defaultExpectation.paramPtrs != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by ExpectParams functions")
	}

	mmAddBinary.defaultExpectation.params = &EncoderMockAddBinaryParams{key, value}
	mmAddBinary.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddBinary.expectations {
		if minimock.Equal(e.params, mmAddBinary.defaultExpectation.params) {
			mmAddBinary.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddBinary.defaultExpectation.params)
		}
	}

	return mmAddBinary
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddBinary
func (mmAddBinary *mEncoderMockAddBinary) ExpectKeyParam1(key string) *mEncoderMockAddBinary {
	if mmAddBinary.mock.funcAddBinary != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Set")
	}

	if mmAddBinary.defaultExpectation == nil {
		mmAddBinary.defaultExpectation = &EncoderMockAddBinaryExpectation{}
	}

	if mmAddBinary.defaultExpectation.params != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Expect")
	}

	if mmAddBinary.defaultExpectation.paramPtrs == nil {
		mmAddBinary.defaultExpectation.paramPtrs = &EncoderMockAddBinaryParamPtrs{}
	}
	mmAddBinary.defaultExpectation.paramPtrs.key = &key
	mmAddBinary.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddBinary
}

// ExpectValueParam2 sets up expected param value for Encoder.AddBinary
func (mmAddBinary *mEncoderMockAddBinary) ExpectValueParam2(value []byte) *mEncoderMockAddBinary {
	if mmAddBinary.mock.funcAddBinary != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Set")
	}

	if mmAddBinary.defaultExpectation == nil {
		mmAddBinary.defaultExpectation = &EncoderMockAddBinaryExpectation{}
	}

	if mmAddBinary.defaultExpectation.params != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Expect")
	}

	if mmAddBinary.defaultExpectation.paramPtrs == nil {
		mmAddBinary.defaultExpectation.paramPtrs = &EncoderMockAddBinaryParamPtrs{}
	}
	mmAddBinary.defaultExpectation.paramPtrs.value = &value
	mmAddBinary.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddBinary
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddBinary
func (mmAddBinary *mEncoderMockAddBinary) Inspect(f func(key string, value []byte)) *mEncoderMockAddBinary {
	if mmAddBinary.mock.inspectFuncAddBinary != nil {
		mmAddBinary.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddBinary")
	}

	mmAddBinary.mock.inspectFuncAddBinary = f

	return mmAddBinary
}

// Return sets up results that will be returned by Encoder.AddBinary
func (mmAddBinary *mEncoderMockAddBinary) Return() *EncoderMock {
	if mmAddBinary.mock.funcAddBinary != nil {
		mmAddBinary.mock.t.Fatalf("EncoderMock.AddBinary mock is already set by Set")
	}

	if mmAddBinary.defaultExpectation == nil {
		mmAddBinary.defaultExpectation = &EncoderMockAddBinaryExpectation{mock: mmAddBinary.mock}
	}

	mmAddBinary.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddBinary.mock
}

// Set uses given function f to mock the Encoder.AddBinary method
func (mmAddBinary *mEncoderMockAddBinary) Set(f func(key string, value []byte)) *EncoderMock {
	if mmAddBinary.defaultExpectation != nil {
		mmAddBinary.mock.t.Fatalf("Default expectation is already set for the Encoder.AddBinary method")
	}

	if len(mmAddBinary.expectations) > 0 {
		mmAddBinary.mock.t.Fatalf("Some expectations are already set for the Encoder.AddBinary method")
	}

	mmAddBinary.mock.funcAddBinary = f
	mmAddBinary.mock.funcAddBinaryOrigin = minimock.CallerInfo(1)
	return mmAddBinary.mock
}

// Times sets number of times Encoder.AddBinary should be invoked
func (mmAddBinary *mEncoderMockAddBinary) Times(n uint64) *mEncoderMockAddBinary {
	if n == 0 {
		mmAddBinary.mock.t.Fatalf("Times of EncoderMock.AddBinary mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddBinary.expectedInvocations, n)
	mmAddBinary.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddBinary
}

func (mmAddBinary *mEncoderMockAddBinary) invocationsDone() bool {
	if len(mmAddBinary.expectations) == 0 && mmAddBinary.defaultExpectation == nil && mmAddBinary.mock.funcAddBinary == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddBinary.mock.afterAddBinaryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddBinary.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddBinary implements Encoder
func (mmAddBinary *EncoderMock) AddBinary(key string, value []byte) {
	mm_atomic.AddUint64(&mmAddBinary.beforeAddBinaryCounter, 1)
	defer mm_atomic.AddUint64(&mmAddBinary.afterAddBinaryCounter, 1)

	mmAddBinary.t.Helper()

	if mmAddBinary.inspectFuncAddBinary != nil {
		mmAddBinary.inspectFuncAddBinary(key, value)
	}

	mm_params := EncoderMockAddBinaryParams{key, value}

	// Record call args
	mmAddBinary.AddBinaryMock.mutex.Lock()
	mmAddBinary.AddBinaryMock.callArgs = append(mmAddBinary.AddBinaryMock.callArgs, &mm_params)
	mmAddBinary.AddBinaryMock.mutex.Unlock()

	for _, e := range mmAddBinary.AddBinaryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddBinary.AddBinaryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddBinary.AddBinaryMock.defaultExpectation.Counter, 1)
		mm_want := mmAddBinary.AddBinaryMock.defaultExpectation.params
		mm_want_ptrs := mmAddBinary.AddBinaryMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddBinaryParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddBinary.t.Errorf("EncoderMock.AddBinary got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddBinary.AddBinaryMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddBinary.t.Errorf("EncoderMock.AddBinary got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddBinary.AddBinaryMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddBinary.t.Errorf("EncoderMock.AddBinary got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddBinary.AddBinaryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddBinary.funcAddBinary != nil {
		mmAddBinary.funcAddBinary(key, value)
		return
	}
	mmAddBinary.t.Fatalf("Unexpected call to EncoderMock.AddBinary. %v %v", key, value)

}

// AddBinaryAfterCounter returns a count of finished EncoderMock.AddBinary invocations
func (mmAddBinary *EncoderMock) AddBinaryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBinary.afterAddBinaryCounter)
}

// AddBinaryBeforeCounter returns a count of EncoderMock.AddBinary invocations
func (mmAddBinary *EncoderMock) AddBinaryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBinary.beforeAddBinaryCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddBinary.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddBinary *mEncoderMockAddBinary) Calls() []*EncoderMockAddBinaryParams {
	mmAddBinary.mutex.RLock()

	argCopy := make([]*EncoderMockAddBinaryParams, len(mmAddBinary.callArgs))
	copy(argCopy, mmAddBinary.callArgs)

	mmAddBinary.mutex.RUnlock()

	return argCopy
}

// MinimockAddBinaryDone returns true if the count of the AddBinary invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddBinaryDone() bool {
	if m.AddBinaryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddBinaryMock.invocationsDone()
}

// MinimockAddBinaryInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddBinaryInspect() {
	for _, e := range m.AddBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddBinary at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddBinaryCounter := mm_atomic.LoadUint64(&m.afterAddBinaryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddBinaryMock.defaultExpectation != nil && afterAddBinaryCounter < 1 {
		if m.AddBinaryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddBinary at\n%s", m.AddBinaryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddBinary at\n%s with params: %#v", m.AddBinaryMock.defaultExpectation.expectationOrigins.origin, *m.AddBinaryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBinary != nil && afterAddBinaryCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddBinary at\n%s", m.funcAddBinaryOrigin)
	}

	if !m.AddBinaryMock.invocationsDone() && afterAddBinaryCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddBinary at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddBinaryMock.expectedInvocations), m.AddBinaryMock.expectedInvocationsOrigin, afterAddBinaryCounter)
	}
}

type mEncoderMockAddBool struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddBoolExpectation
	expectations       []*EncoderMockAddBoolExpectation

	callArgs []*EncoderMockAddBoolParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddBoolExpectation specifies expectation struct of the Encoder.AddBool
type EncoderMockAddBoolExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddBoolParams
	paramPtrs          *EncoderMockAddBoolParamPtrs
	expectationOrigins EncoderMockAddBoolExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddBoolParams contains parameters of the Encoder.AddBool
type EncoderMockAddBoolParams struct {
	key   string
	value bool
}

// EncoderMockAddBoolParamPtrs contains pointers to parameters of the Encoder.AddBool
type EncoderMockAddBoolParamPtrs struct {
	key   *string
	value *bool
}

// EncoderMockAddBoolOrigins contains origins of expectations of the Encoder.AddBool
type EncoderMockAddBoolExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddBool *mEncoderMockAddBool) Optional() *mEncoderMockAddBool {
	mmAddBool.optional = true
	return mmAddBool
}

// Expect sets up expected params for Encoder.AddBool
func (mmAddBool *mEncoderMockAddBool) Expect(key string, value bool) *mEncoderMockAddBool {
	if mmAddBool.mock.funcAddBool != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Set")
	}

	if mmAddBool.defaultExpectation == nil {
		mmAddBool.defaultExpectation = &EncoderMockAddBoolExpectation{}
	}

	if mmAddBool.defaultExpectation.paramPtrs != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by ExpectParams functions")
	}

	mmAddBool.defaultExpectation.params = &EncoderMockAddBoolParams{key, value}
	mmAddBool.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddBool.expectations {
		if minimock.Equal(e.params, mmAddBool.defaultExpectation.params) {
			mmAddBool.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddBool.defaultExpectation.params)
		}
	}

	return mmAddBool
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddBool
func (mmAddBool *mEncoderMockAddBool) ExpectKeyParam1(key string) *mEncoderMockAddBool {
	if mmAddBool.mock.funcAddBool != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Set")
	}

	if mmAddBool.defaultExpectation == nil {
		mmAddBool.defaultExpectation = &EncoderMockAddBoolExpectation{}
	}

	if mmAddBool.defaultExpectation.params != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Expect")
	}

	if mmAddBool.defaultExpectation.paramPtrs == nil {
		mmAddBool.defaultExpectation.paramPtrs = &EncoderMockAddBoolParamPtrs{}
	}
	mmAddBool.defaultExpectation.paramPtrs.key = &key
	mmAddBool.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddBool
}

// ExpectValueParam2 sets up expected param value for Encoder.AddBool
func (mmAddBool *mEncoderMockAddBool) ExpectValueParam2(value bool) *mEncoderMockAddBool {
	if mmAddBool.mock.funcAddBool != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Set")
	}

	if mmAddBool.defaultExpectation == nil {
		mmAddBool.defaultExpectation = &EncoderMockAddBoolExpectation{}
	}

	if mmAddBool.defaultExpectation.params != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Expect")
	}

	if mmAddBool.defaultExpectation.paramPtrs == nil {
		mmAddBool.defaultExpectation.paramPtrs = &EncoderMockAddBoolParamPtrs{}
	}
	mmAddBool.defaultExpectation.paramPtrs.value = &value
	mmAddBool.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddBool
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddBool
func (mmAddBool *mEncoderMockAddBool) Inspect(f func(key string, value bool)) *mEncoderMockAddBool {
	if mmAddBool.mock.inspectFuncAddBool != nil {
		mmAddBool.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddBool")
	}

	mmAddBool.mock.inspectFuncAddBool = f

	return mmAddBool
}

// Return sets up results that will be returned by Encoder.AddBool
func (mmAddBool *mEncoderMockAddBool) Return() *EncoderMock {
	if mmAddBool.mock.funcAddBool != nil {
		mmAddBool.mock.t.Fatalf("EncoderMock.AddBool mock is already set by Set")
	}

	if mmAddBool.defaultExpectation == nil {
		mmAddBool.defaultExpectation = &EncoderMockAddBoolExpectation{mock: mmAddBool.mock}
	}

	mmAddBool.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddBool.mock
}

// Set uses given function f to mock the Encoder.AddBool method
func (mmAddBool *mEncoderMockAddBool) Set(f func(key string, value bool)) *EncoderMock {
	if mmAddBool.defaultExpectation != nil {
		mmAddBool.mock.t.Fatalf("Default expectation is already set for the Encoder.AddBool method")
	}

	if len(mmAddBool.expectations) > 0 {
		mmAddBool.mock.t.Fatalf("Some expectations are already set for the Encoder.AddBool method")
	}

	mmAddBool.mock.funcAddBool = f
	mmAddBool.mock.funcAddBoolOrigin = minimock.CallerInfo(1)
	return mmAddBool.mock
}

// Times sets number of times Encoder.AddBool should be invoked
func (mmAddBool *mEncoderMockAddBool) Times(n uint64) *mEncoderMockAddBool {
	if n == 0 {
		mmAddBool.mock.t.Fatalf("Times of EncoderMock.AddBool mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddBool.expectedInvocations, n)
	mmAddBool.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddBool
}

func (mmAddBool *mEncoderMockAddBool) invocationsDone() bool {
	if len(mmAddBool.expectations) == 0 && mmAddBool.defaultExpectation == nil && mmAddBool.mock.funcAddBool == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddBool.mock.afterAddBoolCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddBool.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddBool implements Encoder
func (mmAddBool *EncoderMock) AddBool(key string, value bool) {
	mm_atomic.AddUint64(&mmAddBool.beforeAddBoolCounter, 1)
	defer mm_atomic.AddUint64(&mmAddBool.afterAddBoolCounter, 1)

	mmAddBool.t.Helper()

	if mmAddBool.inspectFuncAddBool != nil {
		mmAddBool.inspectFuncAddBool(key, value)
	}

	mm_params := EncoderMockAddBoolParams{key, value}

	// Record call args
	mmAddBool.AddBoolMock.mutex.Lock()
	mmAddBool.AddBoolMock.callArgs = append(mmAddBool.AddBoolMock.callArgs, &mm_params)
	mmAddBool.AddBoolMock.mutex.Unlock()

	for _, e := range mmAddBool.AddBoolMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddBool.AddBoolMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddBool.AddBoolMock.defaultExpectation.Counter, 1)
		mm_want := mmAddBool.AddBoolMock.defaultExpectation.params
		mm_want_ptrs := mmAddBool.AddBoolMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddBoolParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddBool.t.Errorf("EncoderMock.AddBool got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddBool.AddBoolMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddBool.t.Errorf("EncoderMock.AddBool got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddBool.AddBoolMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddBool.t.Errorf("EncoderMock.AddBool got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddBool.AddBoolMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddBool.funcAddBool != nil {
		mmAddBool.funcAddBool(key, value)
		return
	}
	mmAddBool.t.Fatalf("Unexpected call to EncoderMock.AddBool. %v %v", key, value)

}

// AddBoolAfterCounter returns a count of finished EncoderMock.AddBool invocations
func (mmAddBool *EncoderMock) AddBoolAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBool.afterAddBoolCounter)
}

// AddBoolBeforeCounter returns a count of EncoderMock.AddBool invocations
func (mmAddBool *EncoderMock) AddBoolBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBool.beforeAddBoolCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddBool.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddBool *mEncoderMockAddBool) Calls() []*EncoderMockAddBoolParams {
	mmAddBool.mutex.RLock()

	argCopy := make([]*EncoderMockAddBoolParams, len(mmAddBool.callArgs))
	copy(argCopy, mmAddBool.callArgs)

	mmAddBool.mutex.RUnlock()

	return argCopy
}

// MinimockAddBoolDone returns true if the count of the AddBool invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddBoolDone() bool {
	if m.AddBoolMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddBoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddBoolMock.invocationsDone()
}

// MinimockAddBoolInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddBoolInspect() {
	for _, e := range m.AddBoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddBool at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddBoolCounter := mm_atomic.LoadUint64(&m.afterAddBoolCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddBoolMock.defaultExpectation != nil && afterAddBoolCounter < 1 {
		if m.AddBoolMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddBool at\n%s", m.AddBoolMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddBool at\n%s with params: %#v", m.AddBoolMock.defaultExpectation.expectationOrigins.origin, *m.AddBoolMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBool != nil && afterAddBoolCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddBool at\n%s", m.funcAddBoolOrigin)
	}

	if !m.AddBoolMock.invocationsDone() && afterAddBoolCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddBool at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddBoolMock.expectedInvocations), m.AddBoolMock.expectedInvocationsOrigin, afterAddBoolCounter)
	}
}

type mEncoderMockAddByteString struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddByteStringExpectation
	expectations       []*EncoderMockAddByteStringExpectation

	callArgs []*EncoderMockAddByteStringParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddByteStringExpectation specifies expectation struct of the Encoder.AddByteString
type EncoderMockAddByteStringExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddByteStringParams
	paramPtrs          *EncoderMockAddByteStringParamPtrs
	expectationOrigins EncoderMockAddByteStringExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddByteStringParams contains parameters of the Encoder.AddByteString
type EncoderMockAddByteStringParams struct {
	key   string
	value []byte
}

// EncoderMockAddByteStringParamPtrs contains pointers to parameters of the Encoder.AddByteString
type EncoderMockAddByteStringParamPtrs struct {
	key   *string
	value *[]byte
}

// EncoderMockAddByteStringOrigins contains origins of expectations of the Encoder.AddByteString
type EncoderMockAddByteStringExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddByteString *mEncoderMockAddByteString) Optional() *mEncoderMockAddByteString {
	mmAddByteString.optional = true
	return mmAddByteString
}

// Expect sets up expected params for Encoder.AddByteString
func (mmAddByteString *mEncoderMockAddByteString) Expect(key string, value []byte) *mEncoderMockAddByteString {
	if mmAddByteString.mock.funcAddByteString != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Set")
	}

	if mmAddByteString.defaultExpectation == nil {
		mmAddByteString.defaultExpectation = &EncoderMockAddByteStringExpectation{}
	}

	if mmAddByteString.defaultExpectation.paramPtrs != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by ExpectParams functions")
	}

	mmAddByteString.defaultExpectation.params = &EncoderMockAddByteStringParams{key, value}
	mmAddByteString.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddByteString.expectations {
		if minimock.Equal(e.params, mmAddByteString.defaultExpectation.params) {
			mmAddByteString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddByteString.defaultExpectation.params)
		}
	}

	return mmAddByteString
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddByteString
func (mmAddByteString *mEncoderMockAddByteString) ExpectKeyParam1(key string) *mEncoderMockAddByteString {
	if mmAddByteString.mock.funcAddByteString != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Set")
	}

	if mmAddByteString.defaultExpectation == nil {
		mmAddByteString.defaultExpectation = &EncoderMockAddByteStringExpectation{}
	}

	if mmAddByteString.defaultExpectation.params != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Expect")
	}

	if mmAddByteString.defaultExpectation.paramPtrs == nil {
		mmAddByteString.defaultExpectation.paramPtrs = &EncoderMockAddByteStringParamPtrs{}
	}
	mmAddByteString.defaultExpectation.paramPtrs.key = &key
	mmAddByteString.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddByteString
}

// ExpectValueParam2 sets up expected param value for Encoder.AddByteString
func (mmAddByteString *mEncoderMockAddByteString) ExpectValueParam2(value []byte) *mEncoderMockAddByteString {
	if mmAddByteString.mock.funcAddByteString != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Set")
	}

	if mmAddByteString.defaultExpectation == nil {
		mmAddByteString.defaultExpectation = &EncoderMockAddByteStringExpectation{}
	}

	if mmAddByteString.defaultExpectation.params != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Expect")
	}

	if mmAddByteString.defaultExpectation.paramPtrs == nil {
		mmAddByteString.defaultExpectation.paramPtrs = &EncoderMockAddByteStringParamPtrs{}
	}
	mmAddByteString.defaultExpectation.paramPtrs.value = &value
	mmAddByteString.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddByteString
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddByteString
func (mmAddByteString *mEncoderMockAddByteString) Inspect(f func(key string, value []byte)) *mEncoderMockAddByteString {
	if mmAddByteString.mock.inspectFuncAddByteString != nil {
		mmAddByteString.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddByteString")
	}

	mmAddByteString.mock.inspectFuncAddByteString = f

	return mmAddByteString
}

// Return sets up results that will be returned by Encoder.AddByteString
func (mmAddByteString *mEncoderMockAddByteString) Return() *EncoderMock {
	if mmAddByteString.mock.funcAddByteString != nil {
		mmAddByteString.mock.t.Fatalf("EncoderMock.AddByteString mock is already set by Set")
	}

	if mmAddByteString.defaultExpectation == nil {
		mmAddByteString.defaultExpectation = &EncoderMockAddByteStringExpectation{mock: mmAddByteString.mock}
	}

	mmAddByteString.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddByteString.mock
}

// Set uses given function f to mock the Encoder.AddByteString method
func (mmAddByteString *mEncoderMockAddByteString) Set(f func(key string, value []byte)) *EncoderMock {
	if mmAddByteString.defaultExpectation != nil {
		mmAddByteString.mock.t.Fatalf("Default expectation is already set for the Encoder.AddByteString method")
	}

	if len(mmAddByteString.expectations) > 0 {
		mmAddByteString.mock.t.Fatalf("Some expectations are already set for the Encoder.AddByteString method")
	}

	mmAddByteString.mock.funcAddByteString = f
	mmAddByteString.mock.funcAddByteStringOrigin = minimock.CallerInfo(1)
	return mmAddByteString.mock
}

// Times sets number of times Encoder.AddByteString should be invoked
func (mmAddByteString *mEncoderMockAddByteString) Times(n uint64) *mEncoderMockAddByteString {
	if n == 0 {
		mmAddByteString.mock.t.Fatalf("Times of EncoderMock.AddByteString mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddByteString.expectedInvocations, n)
	mmAddByteString.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddByteString
}

func (mmAddByteString *mEncoderMockAddByteString) invocationsDone() bool {
	if len(mmAddByteString.expectations) == 0 && mmAddByteString.defaultExpectation == nil && mmAddByteString.mock.funcAddByteString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddByteString.mock.afterAddByteStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddByteString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddByteString implements Encoder
func (mmAddByteString *EncoderMock) AddByteString(key string, value []byte) {
	mm_atomic.AddUint64(&mmAddByteString.beforeAddByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAddByteString.afterAddByteStringCounter, 1)

	mmAddByteString.t.Helper()

	if mmAddByteString.inspectFuncAddByteString != nil {
		mmAddByteString.inspectFuncAddByteString(key, value)
	}

	mm_params := EncoderMockAddByteStringParams{key, value}

	// Record call args
	mmAddByteString.AddByteStringMock.mutex.Lock()
	mmAddByteString.AddByteStringMock.callArgs = append(mmAddByteString.AddByteStringMock.callArgs, &mm_params)
	mmAddByteString.AddByteStringMock.mutex.Unlock()

	for _, e := range mmAddByteString.AddByteStringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddByteString.AddByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddByteString.AddByteStringMock.defaultExpectation.Counter, 1)
		mm_want := mmAddByteString.AddByteStringMock.defaultExpectation.params
		mm_want_ptrs := mmAddByteString.AddByteStringMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddByteStringParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddByteString.t.Errorf("EncoderMock.AddByteString got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddByteString.AddByteStringMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddByteString.t.Errorf("EncoderMock.AddByteString got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddByteString.AddByteStringMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddByteString.t.Errorf("EncoderMock.AddByteString got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddByteString.AddByteStringMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddByteString.funcAddByteString != nil {
		mmAddByteString.funcAddByteString(key, value)
		return
	}
	mmAddByteString.t.Fatalf("Unexpected call to EncoderMock.AddByteString. %v %v", key, value)

}

// AddByteStringAfterCounter returns a count of finished EncoderMock.AddByteString invocations
func (mmAddByteString *EncoderMock) AddByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddByteString.afterAddByteStringCounter)
}

// AddByteStringBeforeCounter returns a count of EncoderMock.AddByteString invocations
func (mmAddByteString *EncoderMock) AddByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddByteString.beforeAddByteStringCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddByteString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddByteString *mEncoderMockAddByteString) Calls() []*EncoderMockAddByteStringParams {
	mmAddByteString.mutex.RLock()

	argCopy := make([]*EncoderMockAddByteStringParams, len(mmAddByteString.callArgs))
	copy(argCopy, mmAddByteString.callArgs)

	mmAddByteString.mutex.RUnlock()

	return argCopy
}

// MinimockAddByteStringDone returns true if the count of the AddByteString invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddByteStringDone() bool {
	if m.AddByteStringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddByteStringMock.invocationsDone()
}

// MinimockAddByteStringInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddByteStringInspect() {
	for _, e := range m.AddByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddByteString at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddByteStringCounter := mm_atomic.LoadUint64(&m.afterAddByteStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddByteStringMock.defaultExpectation != nil && afterAddByteStringCounter < 1 {
		if m.AddByteStringMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddByteString at\n%s", m.AddByteStringMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddByteString at\n%s with params: %#v", m.AddByteStringMock.defaultExpectation.expectationOrigins.origin, *m.AddByteStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddByteString != nil && afterAddByteStringCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddByteString at\n%s", m.funcAddByteStringOrigin)
	}

	if !m.AddByteStringMock.invocationsDone() && afterAddByteStringCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddByteString at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddByteStringMock.expectedInvocations), m.AddByteStringMock.expectedInvocationsOrigin, afterAddByteStringCounter)
	}
}

type mEncoderMockAddComplex128 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddComplex128Expectation
	expectations       []*EncoderMockAddComplex128Expectation

	callArgs []*EncoderMockAddComplex128Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddComplex128Expectation specifies expectation struct of the Encoder.AddComplex128
type EncoderMockAddComplex128Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddComplex128Params
	paramPtrs          *EncoderMockAddComplex128ParamPtrs
	expectationOrigins EncoderMockAddComplex128ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddComplex128Params contains parameters of the Encoder.AddComplex128
type EncoderMockAddComplex128Params struct {
	key   string
	value complex128
}

// EncoderMockAddComplex128ParamPtrs contains pointers to parameters of the Encoder.AddComplex128
type EncoderMockAddComplex128ParamPtrs struct {
	key   *string
	value *complex128
}

// EncoderMockAddComplex128Origins contains origins of expectations of the Encoder.AddComplex128
type EncoderMockAddComplex128ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddComplex128 *mEncoderMockAddComplex128) Optional() *mEncoderMockAddComplex128 {
	mmAddComplex128.optional = true
	return mmAddComplex128
}

// Expect sets up expected params for Encoder.AddComplex128
func (mmAddComplex128 *mEncoderMockAddComplex128) Expect(key string, value complex128) *mEncoderMockAddComplex128 {
	if mmAddComplex128.mock.funcAddComplex128 != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Set")
	}

	if mmAddComplex128.defaultExpectation == nil {
		mmAddComplex128.defaultExpectation = &EncoderMockAddComplex128Expectation{}
	}

	if mmAddComplex128.defaultExpectation.paramPtrs != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by ExpectParams functions")
	}

	mmAddComplex128.defaultExpectation.params = &EncoderMockAddComplex128Params{key, value}
	mmAddComplex128.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddComplex128.expectations {
		if minimock.Equal(e.params, mmAddComplex128.defaultExpectation.params) {
			mmAddComplex128.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddComplex128.defaultExpectation.params)
		}
	}

	return mmAddComplex128
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddComplex128
func (mmAddComplex128 *mEncoderMockAddComplex128) ExpectKeyParam1(key string) *mEncoderMockAddComplex128 {
	if mmAddComplex128.mock.funcAddComplex128 != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Set")
	}

	if mmAddComplex128.defaultExpectation == nil {
		mmAddComplex128.defaultExpectation = &EncoderMockAddComplex128Expectation{}
	}

	if mmAddComplex128.defaultExpectation.params != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Expect")
	}

	if mmAddComplex128.defaultExpectation.paramPtrs == nil {
		mmAddComplex128.defaultExpectation.paramPtrs = &EncoderMockAddComplex128ParamPtrs{}
	}
	mmAddComplex128.defaultExpectation.paramPtrs.key = &key
	mmAddComplex128.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddComplex128
}

// ExpectValueParam2 sets up expected param value for Encoder.AddComplex128
func (mmAddComplex128 *mEncoderMockAddComplex128) ExpectValueParam2(value complex128) *mEncoderMockAddComplex128 {
	if mmAddComplex128.mock.funcAddComplex128 != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Set")
	}

	if mmAddComplex128.defaultExpectation == nil {
		mmAddComplex128.defaultExpectation = &EncoderMockAddComplex128Expectation{}
	}

	if mmAddComplex128.defaultExpectation.params != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Expect")
	}

	if mmAddComplex128.defaultExpectation.paramPtrs == nil {
		mmAddComplex128.defaultExpectation.paramPtrs = &EncoderMockAddComplex128ParamPtrs{}
	}
	mmAddComplex128.defaultExpectation.paramPtrs.value = &value
	mmAddComplex128.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddComplex128
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddComplex128
func (mmAddComplex128 *mEncoderMockAddComplex128) Inspect(f func(key string, value complex128)) *mEncoderMockAddComplex128 {
	if mmAddComplex128.mock.inspectFuncAddComplex128 != nil {
		mmAddComplex128.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddComplex128")
	}

	mmAddComplex128.mock.inspectFuncAddComplex128 = f

	return mmAddComplex128
}

// Return sets up results that will be returned by Encoder.AddComplex128
func (mmAddComplex128 *mEncoderMockAddComplex128) Return() *EncoderMock {
	if mmAddComplex128.mock.funcAddComplex128 != nil {
		mmAddComplex128.mock.t.Fatalf("EncoderMock.AddComplex128 mock is already set by Set")
	}

	if mmAddComplex128.defaultExpectation == nil {
		mmAddComplex128.defaultExpectation = &EncoderMockAddComplex128Expectation{mock: mmAddComplex128.mock}
	}

	mmAddComplex128.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddComplex128.mock
}

// Set uses given function f to mock the Encoder.AddComplex128 method
func (mmAddComplex128 *mEncoderMockAddComplex128) Set(f func(key string, value complex128)) *EncoderMock {
	if mmAddComplex128.defaultExpectation != nil {
		mmAddComplex128.mock.t.Fatalf("Default expectation is already set for the Encoder.AddComplex128 method")
	}

	if len(mmAddComplex128.expectations) > 0 {
		mmAddComplex128.mock.t.Fatalf("Some expectations are already set for the Encoder.AddComplex128 method")
	}

	mmAddComplex128.mock.funcAddComplex128 = f
	mmAddComplex128.mock.funcAddComplex128Origin = minimock.CallerInfo(1)
	return mmAddComplex128.mock
}

// Times sets number of times Encoder.AddComplex128 should be invoked
func (mmAddComplex128 *mEncoderMockAddComplex128) Times(n uint64) *mEncoderMockAddComplex128 {
	if n == 0 {
		mmAddComplex128.mock.t.Fatalf("Times of EncoderMock.AddComplex128 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddComplex128.expectedInvocations, n)
	mmAddComplex128.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddComplex128
}

func (mmAddComplex128 *mEncoderMockAddComplex128) invocationsDone() bool {
	if len(mmAddComplex128.expectations) == 0 && mmAddComplex128.defaultExpectation == nil && mmAddComplex128.mock.funcAddComplex128 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddComplex128.mock.afterAddComplex128Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddComplex128.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddComplex128 implements Encoder
func (mmAddComplex128 *EncoderMock) AddComplex128(key string, value complex128) {
	mm_atomic.AddUint64(&mmAddComplex128.beforeAddComplex128Counter, 1)
	defer mm_atomic.AddUint64(&mmAddComplex128.afterAddComplex128Counter, 1)

	mmAddComplex128.t.Helper()

	if mmAddComplex128.inspectFuncAddComplex128 != nil {
		mmAddComplex128.inspectFuncAddComplex128(key, value)
	}

	mm_params := EncoderMockAddComplex128Params{key, value}

	// Record call args
	mmAddComplex128.AddComplex128Mock.mutex.Lock()
	mmAddComplex128.AddComplex128Mock.callArgs = append(mmAddComplex128.AddComplex128Mock.callArgs, &mm_params)
	mmAddComplex128.AddComplex128Mock.mutex.Unlock()

	for _, e := range mmAddComplex128.AddComplex128Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddComplex128.AddComplex128Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddComplex128.AddComplex128Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddComplex128.AddComplex128Mock.defaultExpectation.params
		mm_want_ptrs := mmAddComplex128.AddComplex128Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddComplex128Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddComplex128.t.Errorf("EncoderMock.AddComplex128 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComplex128.AddComplex128Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddComplex128.t.Errorf("EncoderMock.AddComplex128 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComplex128.AddComplex128Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddComplex128.t.Errorf("EncoderMock.AddComplex128 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddComplex128.AddComplex128Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddComplex128.funcAddComplex128 != nil {
		mmAddComplex128.funcAddComplex128(key, value)
		return
	}
	mmAddComplex128.t.Fatalf("Unexpected call to EncoderMock.AddComplex128. %v %v", key, value)

}

// AddComplex128AfterCounter returns a count of finished EncoderMock.AddComplex128 invocations
func (mmAddComplex128 *EncoderMock) AddComplex128AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComplex128.afterAddComplex128Counter)
}

// AddComplex128BeforeCounter returns a count of EncoderMock.AddComplex128 invocations
func (mmAddComplex128 *EncoderMock) AddComplex128BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComplex128.beforeAddComplex128Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddComplex128.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddComplex128 *mEncoderMockAddComplex128) Calls() []*EncoderMockAddComplex128Params {
	mmAddComplex128.mutex.RLock()

	argCopy := make([]*EncoderMockAddComplex128Params, len(mmAddComplex128.callArgs))
	copy(argCopy, mmAddComplex128.callArgs)

	mmAddComplex128.mutex.RUnlock()

	return argCopy
}

// MinimockAddComplex128Done returns true if the count of the AddComplex128 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddComplex128Done() bool {
	if m.AddComplex128Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddComplex128Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddComplex128Mock.invocationsDone()
}

// MinimockAddComplex128Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddComplex128Inspect() {
	for _, e := range m.AddComplex128Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddComplex128 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddComplex128Counter := mm_atomic.LoadUint64(&m.afterAddComplex128Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddComplex128Mock.defaultExpectation != nil && afterAddComplex128Counter < 1 {
		if m.AddComplex128Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddComplex128 at\n%s", m.AddComplex128Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddComplex128 at\n%s with params: %#v", m.AddComplex128Mock.defaultExpectation.expectationOrigins.origin, *m.AddComplex128Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComplex128 != nil && afterAddComplex128Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddComplex128 at\n%s", m.funcAddComplex128Origin)
	}

	if !m.AddComplex128Mock.invocationsDone() && afterAddComplex128Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddComplex128 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddComplex128Mock.expectedInvocations), m.AddComplex128Mock.expectedInvocationsOrigin, afterAddComplex128Counter)
	}
}

type mEncoderMockAddComplex64 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddComplex64Expectation
	expectations       []*EncoderMockAddComplex64Expectation

	callArgs []*EncoderMockAddComplex64Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddComplex64Expectation specifies expectation struct of the Encoder.AddComplex64
type EncoderMockAddComplex64Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddComplex64Params
	paramPtrs          *EncoderMockAddComplex64ParamPtrs
	expectationOrigins EncoderMockAddComplex64ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddComplex64Params contains parameters of the Encoder.AddComplex64
type EncoderMockAddComplex64Params struct {
	key   string
	value complex64
}

// EncoderMockAddComplex64ParamPtrs contains pointers to parameters of the Encoder.AddComplex64
type EncoderMockAddComplex64ParamPtrs struct {
	key   *string
	value *complex64
}

// EncoderMockAddComplex64Origins contains origins of expectations of the Encoder.AddComplex64
type EncoderMockAddComplex64ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddComplex64 *mEncoderMockAddComplex64) Optional() *mEncoderMockAddComplex64 {
	mmAddComplex64.optional = true
	return mmAddComplex64
}

// Expect sets up expected params for Encoder.AddComplex64
func (mmAddComplex64 *mEncoderMockAddComplex64) Expect(key string, value complex64) *mEncoderMockAddComplex64 {
	if mmAddComplex64.mock.funcAddComplex64 != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Set")
	}

	if mmAddComplex64.defaultExpectation == nil {
		mmAddComplex64.defaultExpectation = &EncoderMockAddComplex64Expectation{}
	}

	if mmAddComplex64.defaultExpectation.paramPtrs != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by ExpectParams functions")
	}

	mmAddComplex64.defaultExpectation.params = &EncoderMockAddComplex64Params{key, value}
	mmAddComplex64.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddComplex64.expectations {
		if minimock.Equal(e.params, mmAddComplex64.defaultExpectation.params) {
			mmAddComplex64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddComplex64.defaultExpectation.params)
		}
	}

	return mmAddComplex64
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddComplex64
func (mmAddComplex64 *mEncoderMockAddComplex64) ExpectKeyParam1(key string) *mEncoderMockAddComplex64 {
	if mmAddComplex64.mock.funcAddComplex64 != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Set")
	}

	if mmAddComplex64.defaultExpectation == nil {
		mmAddComplex64.defaultExpectation = &EncoderMockAddComplex64Expectation{}
	}

	if mmAddComplex64.defaultExpectation.params != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Expect")
	}

	if mmAddComplex64.defaultExpectation.paramPtrs == nil {
		mmAddComplex64.defaultExpectation.paramPtrs = &EncoderMockAddComplex64ParamPtrs{}
	}
	mmAddComplex64.defaultExpectation.paramPtrs.key = &key
	mmAddComplex64.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddComplex64
}

// ExpectValueParam2 sets up expected param value for Encoder.AddComplex64
func (mmAddComplex64 *mEncoderMockAddComplex64) ExpectValueParam2(value complex64) *mEncoderMockAddComplex64 {
	if mmAddComplex64.mock.funcAddComplex64 != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Set")
	}

	if mmAddComplex64.defaultExpectation == nil {
		mmAddComplex64.defaultExpectation = &EncoderMockAddComplex64Expectation{}
	}

	if mmAddComplex64.defaultExpectation.params != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Expect")
	}

	if mmAddComplex64.defaultExpectation.paramPtrs == nil {
		mmAddComplex64.defaultExpectation.paramPtrs = &EncoderMockAddComplex64ParamPtrs{}
	}
	mmAddComplex64.defaultExpectation.paramPtrs.value = &value
	mmAddComplex64.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddComplex64
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddComplex64
func (mmAddComplex64 *mEncoderMockAddComplex64) Inspect(f func(key string, value complex64)) *mEncoderMockAddComplex64 {
	if mmAddComplex64.mock.inspectFuncAddComplex64 != nil {
		mmAddComplex64.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddComplex64")
	}

	mmAddComplex64.mock.inspectFuncAddComplex64 = f

	return mmAddComplex64
}

// Return sets up results that will be returned by Encoder.AddComplex64
func (mmAddComplex64 *mEncoderMockAddComplex64) Return() *EncoderMock {
	if mmAddComplex64.mock.funcAddComplex64 != nil {
		mmAddComplex64.mock.t.Fatalf("EncoderMock.AddComplex64 mock is already set by Set")
	}

	if mmAddComplex64.defaultExpectation == nil {
		mmAddComplex64.defaultExpectation = &EncoderMockAddComplex64Expectation{mock: mmAddComplex64.mock}
	}

	mmAddComplex64.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddComplex64.mock
}

// Set uses given function f to mock the Encoder.AddComplex64 method
func (mmAddComplex64 *mEncoderMockAddComplex64) Set(f func(key string, value complex64)) *EncoderMock {
	if mmAddComplex64.defaultExpectation != nil {
		mmAddComplex64.mock.t.Fatalf("Default expectation is already set for the Encoder.AddComplex64 method")
	}

	if len(mmAddComplex64.expectations) > 0 {
		mmAddComplex64.mock.t.Fatalf("Some expectations are already set for the Encoder.AddComplex64 method")
	}

	mmAddComplex64.mock.funcAddComplex64 = f
	mmAddComplex64.mock.funcAddComplex64Origin = minimock.CallerInfo(1)
	return mmAddComplex64.mock
}

// Times sets number of times Encoder.AddComplex64 should be invoked
func (mmAddComplex64 *mEncoderMockAddComplex64) Times(n uint64) *mEncoderMockAddComplex64 {
	if n == 0 {
		mmAddComplex64.mock.t.Fatalf("Times of EncoderMock.AddComplex64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddComplex64.expectedInvocations, n)
	mmAddComplex64.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddComplex64
}

func (mmAddComplex64 *mEncoderMockAddComplex64) invocationsDone() bool {
	if len(mmAddComplex64.expectations) == 0 && mmAddComplex64.defaultExpectation == nil && mmAddComplex64.mock.funcAddComplex64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddComplex64.mock.afterAddComplex64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddComplex64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddComplex64 implements Encoder
func (mmAddComplex64 *EncoderMock) AddComplex64(key string, value complex64) {
	mm_atomic.AddUint64(&mmAddComplex64.beforeAddComplex64Counter, 1)
	defer mm_atomic.AddUint64(&mmAddComplex64.afterAddComplex64Counter, 1)

	mmAddComplex64.t.Helper()

	if mmAddComplex64.inspectFuncAddComplex64 != nil {
		mmAddComplex64.inspectFuncAddComplex64(key, value)
	}

	mm_params := EncoderMockAddComplex64Params{key, value}

	// Record call args
	mmAddComplex64.AddComplex64Mock.mutex.Lock()
	mmAddComplex64.AddComplex64Mock.callArgs = append(mmAddComplex64.AddComplex64Mock.callArgs, &mm_params)
	mmAddComplex64.AddComplex64Mock.mutex.Unlock()

	for _, e := range mmAddComplex64.AddComplex64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddComplex64.AddComplex64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddComplex64.AddComplex64Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddComplex64.AddComplex64Mock.defaultExpectation.params
		mm_want_ptrs := mmAddComplex64.AddComplex64Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddComplex64Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddComplex64.t.Errorf("EncoderMock.AddComplex64 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComplex64.AddComplex64Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddComplex64.t.Errorf("EncoderMock.AddComplex64 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComplex64.AddComplex64Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddComplex64.t.Errorf("EncoderMock.AddComplex64 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddComplex64.AddComplex64Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddComplex64.funcAddComplex64 != nil {
		mmAddComplex64.funcAddComplex64(key, value)
		return
	}
	mmAddComplex64.t.Fatalf("Unexpected call to EncoderMock.AddComplex64. %v %v", key, value)

}

// AddComplex64AfterCounter returns a count of finished EncoderMock.AddComplex64 invocations
func (mmAddComplex64 *EncoderMock) AddComplex64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComplex64.afterAddComplex64Counter)
}

// AddComplex64BeforeCounter returns a count of EncoderMock.AddComplex64 invocations
func (mmAddComplex64 *EncoderMock) AddComplex64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComplex64.beforeAddComplex64Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddComplex64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddComplex64 *mEncoderMockAddComplex64) Calls() []*EncoderMockAddComplex64Params {
	mmAddComplex64.mutex.RLock()

	argCopy := make([]*EncoderMockAddComplex64Params, len(mmAddComplex64.callArgs))
	copy(argCopy, mmAddComplex64.callArgs)

	mmAddComplex64.mutex.RUnlock()

	return argCopy
}

// MinimockAddComplex64Done returns true if the count of the AddComplex64 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddComplex64Done() bool {
	if m.AddComplex64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddComplex64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddComplex64Mock.invocationsDone()
}

// MinimockAddComplex64Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddComplex64Inspect() {
	for _, e := range m.AddComplex64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddComplex64 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddComplex64Counter := mm_atomic.LoadUint64(&m.afterAddComplex64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddComplex64Mock.defaultExpectation != nil && afterAddComplex64Counter < 1 {
		if m.AddComplex64Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddComplex64 at\n%s", m.AddComplex64Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddComplex64 at\n%s with params: %#v", m.AddComplex64Mock.defaultExpectation.expectationOrigins.origin, *m.AddComplex64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComplex64 != nil && afterAddComplex64Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddComplex64 at\n%s", m.funcAddComplex64Origin)
	}

	if !m.AddComplex64Mock.invocationsDone() && afterAddComplex64Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddComplex64 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddComplex64Mock.expectedInvocations), m.AddComplex64Mock.expectedInvocationsOrigin, afterAddComplex64Counter)
	}
}

type mEncoderMockAddDuration struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddDurationExpectation
	expectations       []*EncoderMockAddDurationExpectation

	callArgs []*EncoderMockAddDurationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddDurationExpectation specifies expectation struct of the Encoder.AddDuration
type EncoderMockAddDurationExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddDurationParams
	paramPtrs          *EncoderMockAddDurationParamPtrs
	expectationOrigins EncoderMockAddDurationExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddDurationParams contains parameters of the Encoder.AddDuration
type EncoderMockAddDurationParams struct {
	key   string
	value time.Duration
}

// EncoderMockAddDurationParamPtrs contains pointers to parameters of the Encoder.AddDuration
type EncoderMockAddDurationParamPtrs struct {
	key   *string
	value *time.Duration
}

// EncoderMockAddDurationOrigins contains origins of expectations of the Encoder.AddDuration
type EncoderMockAddDurationExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddDuration *mEncoderMockAddDuration) Optional() *mEncoderMockAddDuration {
	mmAddDuration.optional = true
	return mmAddDuration
}

// Expect sets up expected params for Encoder.AddDuration
func (mmAddDuration *mEncoderMockAddDuration) Expect(key string, value time.Duration) *mEncoderMockAddDuration {
	if mmAddDuration.mock.funcAddDuration != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Set")
	}

	if mmAddDuration.defaultExpectation == nil {
		mmAddDuration.defaultExpectation = &EncoderMockAddDurationExpectation{}
	}

	if mmAddDuration.defaultExpectation.paramPtrs != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by ExpectParams functions")
	}

	mmAddDuration.defaultExpectation.params = &EncoderMockAddDurationParams{key, value}
	mmAddDuration.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddDuration.expectations {
		if minimock.Equal(e.params, mmAddDuration.defaultExpectation.params) {
			mmAddDuration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddDuration.defaultExpectation.params)
		}
	}

	return mmAddDuration
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddDuration
func (mmAddDuration *mEncoderMockAddDuration) ExpectKeyParam1(key string) *mEncoderMockAddDuration {
	if mmAddDuration.mock.funcAddDuration != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Set")
	}

	if mmAddDuration.defaultExpectation == nil {
		mmAddDuration.defaultExpectation = &EncoderMockAddDurationExpectation{}
	}

	if mmAddDuration.defaultExpectation.params != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Expect")
	}

	if mmAddDuration.defaultExpectation.paramPtrs == nil {
		mmAddDuration.defaultExpectation.paramPtrs = &EncoderMockAddDurationParamPtrs{}
	}
	mmAddDuration.defaultExpectation.paramPtrs.key = &key
	mmAddDuration.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddDuration
}

// ExpectValueParam2 sets up expected param value for Encoder.AddDuration
func (mmAddDuration *mEncoderMockAddDuration) ExpectValueParam2(value time.Duration) *mEncoderMockAddDuration {
	if mmAddDuration.mock.funcAddDuration != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Set")
	}

	if mmAddDuration.defaultExpectation == nil {
		mmAddDuration.defaultExpectation = &EncoderMockAddDurationExpectation{}
	}

	if mmAddDuration.defaultExpectation.params != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Expect")
	}

	if mmAddDuration.defaultExpectation.paramPtrs == nil {
		mmAddDuration.defaultExpectation.paramPtrs = &EncoderMockAddDurationParamPtrs{}
	}
	mmAddDuration.defaultExpectation.paramPtrs.value = &value
	mmAddDuration.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddDuration
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddDuration
func (mmAddDuration *mEncoderMockAddDuration) Inspect(f func(key string, value time.Duration)) *mEncoderMockAddDuration {
	if mmAddDuration.mock.inspectFuncAddDuration != nil {
		mmAddDuration.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddDuration")
	}

	mmAddDuration.mock.inspectFuncAddDuration = f

	return mmAddDuration
}

// Return sets up results that will be returned by Encoder.AddDuration
func (mmAddDuration *mEncoderMockAddDuration) Return() *EncoderMock {
	if mmAddDuration.mock.funcAddDuration != nil {
		mmAddDuration.mock.t.Fatalf("EncoderMock.AddDuration mock is already set by Set")
	}

	if mmAddDuration.defaultExpectation == nil {
		mmAddDuration.defaultExpectation = &EncoderMockAddDurationExpectation{mock: mmAddDuration.mock}
	}

	mmAddDuration.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddDuration.mock
}

// Set uses given function f to mock the Encoder.AddDuration method
func (mmAddDuration *mEncoderMockAddDuration) Set(f func(key string, value time.Duration)) *EncoderMock {
	if mmAddDuration.defaultExpectation != nil {
		mmAddDuration.mock.t.Fatalf("Default expectation is already set for the Encoder.AddDuration method")
	}

	if len(mmAddDuration.expectations) > 0 {
		mmAddDuration.mock.t.Fatalf("Some expectations are already set for the Encoder.AddDuration method")
	}

	mmAddDuration.mock.funcAddDuration = f
	mmAddDuration.mock.funcAddDurationOrigin = minimock.CallerInfo(1)
	return mmAddDuration.mock
}

// Times sets number of times Encoder.AddDuration should be invoked
func (mmAddDuration *mEncoderMockAddDuration) Times(n uint64) *mEncoderMockAddDuration {
	if n == 0 {
		mmAddDuration.mock.t.Fatalf("Times of EncoderMock.AddDuration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddDuration.expectedInvocations, n)
	mmAddDuration.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddDuration
}

func (mmAddDuration *mEncoderMockAddDuration) invocationsDone() bool {
	if len(mmAddDuration.expectations) == 0 && mmAddDuration.defaultExpectation == nil && mmAddDuration.mock.funcAddDuration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddDuration.mock.afterAddDurationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddDuration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddDuration implements Encoder
func (mmAddDuration *EncoderMock) AddDuration(key string, value time.Duration) {
	mm_atomic.AddUint64(&mmAddDuration.beforeAddDurationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddDuration.afterAddDurationCounter, 1)

	mmAddDuration.t.Helper()

	if mmAddDuration.inspectFuncAddDuration != nil {
		mmAddDuration.inspectFuncAddDuration(key, value)
	}

	mm_params := EncoderMockAddDurationParams{key, value}

	// Record call args
	mmAddDuration.AddDurationMock.mutex.Lock()
	mmAddDuration.AddDurationMock.callArgs = append(mmAddDuration.AddDurationMock.callArgs, &mm_params)
	mmAddDuration.AddDurationMock.mutex.Unlock()

	for _, e := range mmAddDuration.AddDurationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddDuration.AddDurationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddDuration.AddDurationMock.defaultExpectation.Counter, 1)
		mm_want := mmAddDuration.AddDurationMock.defaultExpectation.params
		mm_want_ptrs := mmAddDuration.AddDurationMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddDurationParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddDuration.t.Errorf("EncoderMock.AddDuration got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddDuration.AddDurationMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddDuration.t.Errorf("EncoderMock.AddDuration got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddDuration.AddDurationMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddDuration.t.Errorf("EncoderMock.AddDuration got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddDuration.AddDurationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddDuration.funcAddDuration != nil {
		mmAddDuration.funcAddDuration(key, value)
		return
	}
	mmAddDuration.t.Fatalf("Unexpected call to EncoderMock.AddDuration. %v %v", key, value)

}

// AddDurationAfterCounter returns a count of finished EncoderMock.AddDuration invocations
func (mmAddDuration *EncoderMock) AddDurationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDuration.afterAddDurationCounter)
}

// AddDurationBeforeCounter returns a count of EncoderMock.AddDuration invocations
func (mmAddDuration *EncoderMock) AddDurationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDuration.beforeAddDurationCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddDuration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddDuration *mEncoderMockAddDuration) Calls() []*EncoderMockAddDurationParams {
	mmAddDuration.mutex.RLock()

	argCopy := make([]*EncoderMockAddDurationParams, len(mmAddDuration.callArgs))
	copy(argCopy, mmAddDuration.callArgs)

	mmAddDuration.mutex.RUnlock()

	return argCopy
}

// MinimockAddDurationDone returns true if the count of the AddDuration invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddDurationDone() bool {
	if m.AddDurationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddDurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddDurationMock.invocationsDone()
}

// MinimockAddDurationInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddDurationInspect() {
	for _, e := range m.AddDurationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddDuration at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddDurationCounter := mm_atomic.LoadUint64(&m.afterAddDurationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddDurationMock.defaultExpectation != nil && afterAddDurationCounter < 1 {
		if m.AddDurationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddDuration at\n%s", m.AddDurationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddDuration at\n%s with params: %#v", m.AddDurationMock.defaultExpectation.expectationOrigins.origin, *m.AddDurationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddDuration != nil && afterAddDurationCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddDuration at\n%s", m.funcAddDurationOrigin)
	}

	if !m.AddDurationMock.invocationsDone() && afterAddDurationCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddDuration at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddDurationMock.expectedInvocations), m.AddDurationMock.expectedInvocationsOrigin, afterAddDurationCounter)
	}
}

type mEncoderMockAddFloat32 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddFloat32Expectation
	expectations       []*EncoderMockAddFloat32Expectation

	callArgs []*EncoderMockAddFloat32Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddFloat32Expectation specifies expectation struct of the Encoder.AddFloat32
type EncoderMockAddFloat32Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddFloat32Params
	paramPtrs          *EncoderMockAddFloat32ParamPtrs
	expectationOrigins EncoderMockAddFloat32ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddFloat32Params contains parameters of the Encoder.AddFloat32
type EncoderMockAddFloat32Params struct {
	key   string
	value float32
}

// EncoderMockAddFloat32ParamPtrs contains pointers to parameters of the Encoder.AddFloat32
type EncoderMockAddFloat32ParamPtrs struct {
	key   *string
	value *float32
}

// EncoderMockAddFloat32Origins contains origins of expectations of the Encoder.AddFloat32
type EncoderMockAddFloat32ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddFloat32 *mEncoderMockAddFloat32) Optional() *mEncoderMockAddFloat32 {
	mmAddFloat32.optional = true
	return mmAddFloat32
}

// Expect sets up expected params for Encoder.AddFloat32
func (mmAddFloat32 *mEncoderMockAddFloat32) Expect(key string, value float32) *mEncoderMockAddFloat32 {
	if mmAddFloat32.mock.funcAddFloat32 != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Set")
	}

	if mmAddFloat32.defaultExpectation == nil {
		mmAddFloat32.defaultExpectation = &EncoderMockAddFloat32Expectation{}
	}

	if mmAddFloat32.defaultExpectation.paramPtrs != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by ExpectParams functions")
	}

	mmAddFloat32.defaultExpectation.params = &EncoderMockAddFloat32Params{key, value}
	mmAddFloat32.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddFloat32.expectations {
		if minimock.Equal(e.params, mmAddFloat32.defaultExpectation.params) {
			mmAddFloat32.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFloat32.defaultExpectation.params)
		}
	}

	return mmAddFloat32
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddFloat32
func (mmAddFloat32 *mEncoderMockAddFloat32) ExpectKeyParam1(key string) *mEncoderMockAddFloat32 {
	if mmAddFloat32.mock.funcAddFloat32 != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Set")
	}

	if mmAddFloat32.defaultExpectation == nil {
		mmAddFloat32.defaultExpectation = &EncoderMockAddFloat32Expectation{}
	}

	if mmAddFloat32.defaultExpectation.params != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Expect")
	}

	if mmAddFloat32.defaultExpectation.paramPtrs == nil {
		mmAddFloat32.defaultExpectation.paramPtrs = &EncoderMockAddFloat32ParamPtrs{}
	}
	mmAddFloat32.defaultExpectation.paramPtrs.key = &key
	mmAddFloat32.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddFloat32
}

// ExpectValueParam2 sets up expected param value for Encoder.AddFloat32
func (mmAddFloat32 *mEncoderMockAddFloat32) ExpectValueParam2(value float32) *mEncoderMockAddFloat32 {
	if mmAddFloat32.mock.funcAddFloat32 != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Set")
	}

	if mmAddFloat32.defaultExpectation == nil {
		mmAddFloat32.defaultExpectation = &EncoderMockAddFloat32Expectation{}
	}

	if mmAddFloat32.defaultExpectation.params != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Expect")
	}

	if mmAddFloat32.defaultExpectation.paramPtrs == nil {
		mmAddFloat32.defaultExpectation.paramPtrs = &EncoderMockAddFloat32ParamPtrs{}
	}
	mmAddFloat32.defaultExpectation.paramPtrs.value = &value
	mmAddFloat32.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddFloat32
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddFloat32
func (mmAddFloat32 *mEncoderMockAddFloat32) Inspect(f func(key string, value float32)) *mEncoderMockAddFloat32 {
	if mmAddFloat32.mock.inspectFuncAddFloat32 != nil {
		mmAddFloat32.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddFloat32")
	}

	mmAddFloat32.mock.inspectFuncAddFloat32 = f

	return mmAddFloat32
}

// Return sets up results that will be returned by Encoder.AddFloat32
func (mmAddFloat32 *mEncoderMockAddFloat32) Return() *EncoderMock {
	if mmAddFloat32.mock.funcAddFloat32 != nil {
		mmAddFloat32.mock.t.Fatalf("EncoderMock.AddFloat32 mock is already set by Set")
	}

	if mmAddFloat32.defaultExpectation == nil {
		mmAddFloat32.defaultExpectation = &EncoderMockAddFloat32Expectation{mock: mmAddFloat32.mock}
	}

	mmAddFloat32.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddFloat32.mock
}

// Set uses given function f to mock the Encoder.AddFloat32 method
func (mmAddFloat32 *mEncoderMockAddFloat32) Set(f func(key string, value float32)) *EncoderMock {
	if mmAddFloat32.defaultExpectation != nil {
		mmAddFloat32.mock.t.Fatalf("Default expectation is already set for the Encoder.AddFloat32 method")
	}

	if len(mmAddFloat32.expectations) > 0 {
		mmAddFloat32.mock.t.Fatalf("Some expectations are already set for the Encoder.AddFloat32 method")
	}

	mmAddFloat32.mock.funcAddFloat32 = f
	mmAddFloat32.mock.funcAddFloat32Origin = minimock.CallerInfo(1)
	return mmAddFloat32.mock
}

// Times sets number of times Encoder.AddFloat32 should be invoked
func (mmAddFloat32 *mEncoderMockAddFloat32) Times(n uint64) *mEncoderMockAddFloat32 {
	if n == 0 {
		mmAddFloat32.mock.t.Fatalf("Times of EncoderMock.AddFloat32 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddFloat32.expectedInvocations, n)
	mmAddFloat32.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddFloat32
}

func (mmAddFloat32 *mEncoderMockAddFloat32) invocationsDone() bool {
	if len(mmAddFloat32.expectations) == 0 && mmAddFloat32.defaultExpectation == nil && mmAddFloat32.mock.funcAddFloat32 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddFloat32.mock.afterAddFloat32Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddFloat32.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddFloat32 implements Encoder
func (mmAddFloat32 *EncoderMock) AddFloat32(key string, value float32) {
	mm_atomic.AddUint64(&mmAddFloat32.beforeAddFloat32Counter, 1)
	defer mm_atomic.AddUint64(&mmAddFloat32.afterAddFloat32Counter, 1)

	mmAddFloat32.t.Helper()

	if mmAddFloat32.inspectFuncAddFloat32 != nil {
		mmAddFloat32.inspectFuncAddFloat32(key, value)
	}

	mm_params := EncoderMockAddFloat32Params{key, value}

	// Record call args
	mmAddFloat32.AddFloat32Mock.mutex.Lock()
	mmAddFloat32.AddFloat32Mock.callArgs = append(mmAddFloat32.AddFloat32Mock.callArgs, &mm_params)
	mmAddFloat32.AddFloat32Mock.mutex.Unlock()

	for _, e := range mmAddFloat32.AddFloat32Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddFloat32.AddFloat32Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFloat32.AddFloat32Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddFloat32.AddFloat32Mock.defaultExpectation.params
		mm_want_ptrs := mmAddFloat32.AddFloat32Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddFloat32Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddFloat32.t.Errorf("EncoderMock.AddFloat32 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddFloat32.AddFloat32Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddFloat32.t.Errorf("EncoderMock.AddFloat32 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddFloat32.AddFloat32Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddFloat32.t.Errorf("EncoderMock.AddFloat32 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddFloat32.AddFloat32Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddFloat32.funcAddFloat32 != nil {
		mmAddFloat32.funcAddFloat32(key, value)
		return
	}
	mmAddFloat32.t.Fatalf("Unexpected call to EncoderMock.AddFloat32. %v %v", key, value)

}

// AddFloat32AfterCounter returns a count of finished EncoderMock.AddFloat32 invocations
func (mmAddFloat32 *EncoderMock) AddFloat32AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFloat32.afterAddFloat32Counter)
}

// AddFloat32BeforeCounter returns a count of EncoderMock.AddFloat32 invocations
func (mmAddFloat32 *EncoderMock) AddFloat32BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFloat32.beforeAddFloat32Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddFloat32.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFloat32 *mEncoderMockAddFloat32) Calls() []*EncoderMockAddFloat32Params {
	mmAddFloat32.mutex.RLock()

	argCopy := make([]*EncoderMockAddFloat32Params, len(mmAddFloat32.callArgs))
	copy(argCopy, mmAddFloat32.callArgs)

	mmAddFloat32.mutex.RUnlock()

	return argCopy
}

// MinimockAddFloat32Done returns true if the count of the AddFloat32 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddFloat32Done() bool {
	if m.AddFloat32Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddFloat32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddFloat32Mock.invocationsDone()
}

// MinimockAddFloat32Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddFloat32Inspect() {
	for _, e := range m.AddFloat32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddFloat32 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddFloat32Counter := mm_atomic.LoadUint64(&m.afterAddFloat32Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddFloat32Mock.defaultExpectation != nil && afterAddFloat32Counter < 1 {
		if m.AddFloat32Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddFloat32 at\n%s", m.AddFloat32Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddFloat32 at\n%s with params: %#v", m.AddFloat32Mock.defaultExpectation.expectationOrigins.origin, *m.AddFloat32Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFloat32 != nil && afterAddFloat32Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddFloat32 at\n%s", m.funcAddFloat32Origin)
	}

	if !m.AddFloat32Mock.invocationsDone() && afterAddFloat32Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddFloat32 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddFloat32Mock.expectedInvocations), m.AddFloat32Mock.expectedInvocationsOrigin, afterAddFloat32Counter)
	}
}

type mEncoderMockAddFloat64 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddFloat64Expectation
	expectations       []*EncoderMockAddFloat64Expectation

	callArgs []*EncoderMockAddFloat64Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddFloat64Expectation specifies expectation struct of the Encoder.AddFloat64
type EncoderMockAddFloat64Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddFloat64Params
	paramPtrs          *EncoderMockAddFloat64ParamPtrs
	expectationOrigins EncoderMockAddFloat64ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddFloat64Params contains parameters of the Encoder.AddFloat64
type EncoderMockAddFloat64Params struct {
	key   string
	value float64
}

// EncoderMockAddFloat64ParamPtrs contains pointers to parameters of the Encoder.AddFloat64
type EncoderMockAddFloat64ParamPtrs struct {
	key   *string
	value *float64
}

// EncoderMockAddFloat64Origins contains origins of expectations of the Encoder.AddFloat64
type EncoderMockAddFloat64ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddFloat64 *mEncoderMockAddFloat64) Optional() *mEncoderMockAddFloat64 {
	mmAddFloat64.optional = true
	return mmAddFloat64
}

// Expect sets up expected params for Encoder.AddFloat64
func (mmAddFloat64 *mEncoderMockAddFloat64) Expect(key string, value float64) *mEncoderMockAddFloat64 {
	if mmAddFloat64.mock.funcAddFloat64 != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Set")
	}

	if mmAddFloat64.defaultExpectation == nil {
		mmAddFloat64.defaultExpectation = &EncoderMockAddFloat64Expectation{}
	}

	if mmAddFloat64.defaultExpectation.paramPtrs != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by ExpectParams functions")
	}

	mmAddFloat64.defaultExpectation.params = &EncoderMockAddFloat64Params{key, value}
	mmAddFloat64.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddFloat64.expectations {
		if minimock.Equal(e.params, mmAddFloat64.defaultExpectation.params) {
			mmAddFloat64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFloat64.defaultExpectation.params)
		}
	}

	return mmAddFloat64
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddFloat64
func (mmAddFloat64 *mEncoderMockAddFloat64) ExpectKeyParam1(key string) *mEncoderMockAddFloat64 {
	if mmAddFloat64.mock.funcAddFloat64 != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Set")
	}

	if mmAddFloat64.defaultExpectation == nil {
		mmAddFloat64.defaultExpectation = &EncoderMockAddFloat64Expectation{}
	}

	if mmAddFloat64.defaultExpectation.params != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Expect")
	}

	if mmAddFloat64.defaultExpectation.paramPtrs == nil {
		mmAddFloat64.defaultExpectation.paramPtrs = &EncoderMockAddFloat64ParamPtrs{}
	}
	mmAddFloat64.defaultExpectation.paramPtrs.key = &key
	mmAddFloat64.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddFloat64
}

// ExpectValueParam2 sets up expected param value for Encoder.AddFloat64
func (mmAddFloat64 *mEncoderMockAddFloat64) ExpectValueParam2(value float64) *mEncoderMockAddFloat64 {
	if mmAddFloat64.mock.funcAddFloat64 != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Set")
	}

	if mmAddFloat64.defaultExpectation == nil {
		mmAddFloat64.defaultExpectation = &EncoderMockAddFloat64Expectation{}
	}

	if mmAddFloat64.defaultExpectation.params != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Expect")
	}

	if mmAddFloat64.defaultExpectation.paramPtrs == nil {
		mmAddFloat64.defaultExpectation.paramPtrs = &EncoderMockAddFloat64ParamPtrs{}
	}
	mmAddFloat64.defaultExpectation.paramPtrs.value = &value
	mmAddFloat64.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddFloat64
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddFloat64
func (mmAddFloat64 *mEncoderMockAddFloat64) Inspect(f func(key string, value float64)) *mEncoderMockAddFloat64 {
	if mmAddFloat64.mock.inspectFuncAddFloat64 != nil {
		mmAddFloat64.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddFloat64")
	}

	mmAddFloat64.mock.inspectFuncAddFloat64 = f

	return mmAddFloat64
}

// Return sets up results that will be returned by Encoder.AddFloat64
func (mmAddFloat64 *mEncoderMockAddFloat64) Return() *EncoderMock {
	if mmAddFloat64.mock.funcAddFloat64 != nil {
		mmAddFloat64.mock.t.Fatalf("EncoderMock.AddFloat64 mock is already set by Set")
	}

	if mmAddFloat64.defaultExpectation == nil {
		mmAddFloat64.defaultExpectation = &EncoderMockAddFloat64Expectation{mock: mmAddFloat64.mock}
	}

	mmAddFloat64.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddFloat64.mock
}

// Set uses given function f to mock the Encoder.AddFloat64 method
func (mmAddFloat64 *mEncoderMockAddFloat64) Set(f func(key string, value float64)) *EncoderMock {
	if mmAddFloat64.defaultExpectation != nil {
		mmAddFloat64.mock.t.Fatalf("Default expectation is already set for the Encoder.AddFloat64 method")
	}

	if len(mmAddFloat64.expectations) > 0 {
		mmAddFloat64.mock.t.Fatalf("Some expectations are already set for the Encoder.AddFloat64 method")
	}

	mmAddFloat64.mock.funcAddFloat64 = f
	mmAddFloat64.mock.funcAddFloat64Origin = minimock.CallerInfo(1)
	return mmAddFloat64.mock
}

// Times sets number of times Encoder.AddFloat64 should be invoked
func (mmAddFloat64 *mEncoderMockAddFloat64) Times(n uint64) *mEncoderMockAddFloat64 {
	if n == 0 {
		mmAddFloat64.mock.t.Fatalf("Times of EncoderMock.AddFloat64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddFloat64.expectedInvocations, n)
	mmAddFloat64.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddFloat64
}

func (mmAddFloat64 *mEncoderMockAddFloat64) invocationsDone() bool {
	if len(mmAddFloat64.expectations) == 0 && mmAddFloat64.defaultExpectation == nil && mmAddFloat64.mock.funcAddFloat64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddFloat64.mock.afterAddFloat64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddFloat64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddFloat64 implements Encoder
func (mmAddFloat64 *EncoderMock) AddFloat64(key string, value float64) {
	mm_atomic.AddUint64(&mmAddFloat64.beforeAddFloat64Counter, 1)
	defer mm_atomic.AddUint64(&mmAddFloat64.afterAddFloat64Counter, 1)

	mmAddFloat64.t.Helper()

	if mmAddFloat64.inspectFuncAddFloat64 != nil {
		mmAddFloat64.inspectFuncAddFloat64(key, value)
	}

	mm_params := EncoderMockAddFloat64Params{key, value}

	// Record call args
	mmAddFloat64.AddFloat64Mock.mutex.Lock()
	mmAddFloat64.AddFloat64Mock.callArgs = append(mmAddFloat64.AddFloat64Mock.callArgs, &mm_params)
	mmAddFloat64.AddFloat64Mock.mutex.Unlock()

	for _, e := range mmAddFloat64.AddFloat64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddFloat64.AddFloat64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFloat64.AddFloat64Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddFloat64.AddFloat64Mock.defaultExpectation.params
		mm_want_ptrs := mmAddFloat64.AddFloat64Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddFloat64Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddFloat64.t.Errorf("EncoderMock.AddFloat64 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddFloat64.AddFloat64Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddFloat64.t.Errorf("EncoderMock.AddFloat64 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddFloat64.AddFloat64Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddFloat64.t.Errorf("EncoderMock.AddFloat64 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddFloat64.AddFloat64Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddFloat64.funcAddFloat64 != nil {
		mmAddFloat64.funcAddFloat64(key, value)
		return
	}
	mmAddFloat64.t.Fatalf("Unexpected call to EncoderMock.AddFloat64. %v %v", key, value)

}

// AddFloat64AfterCounter returns a count of finished EncoderMock.AddFloat64 invocations
func (mmAddFloat64 *EncoderMock) AddFloat64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFloat64.afterAddFloat64Counter)
}

// AddFloat64BeforeCounter returns a count of EncoderMock.AddFloat64 invocations
func (mmAddFloat64 *EncoderMock) AddFloat64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFloat64.beforeAddFloat64Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddFloat64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFloat64 *mEncoderMockAddFloat64) Calls() []*EncoderMockAddFloat64Params {
	mmAddFloat64.mutex.RLock()

	argCopy := make([]*EncoderMockAddFloat64Params, len(mmAddFloat64.callArgs))
	copy(argCopy, mmAddFloat64.callArgs)

	mmAddFloat64.mutex.RUnlock()

	return argCopy
}

// MinimockAddFloat64Done returns true if the count of the AddFloat64 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddFloat64Done() bool {
	if m.AddFloat64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddFloat64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddFloat64Mock.invocationsDone()
}

// MinimockAddFloat64Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddFloat64Inspect() {
	for _, e := range m.AddFloat64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddFloat64 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddFloat64Counter := mm_atomic.LoadUint64(&m.afterAddFloat64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddFloat64Mock.defaultExpectation != nil && afterAddFloat64Counter < 1 {
		if m.AddFloat64Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddFloat64 at\n%s", m.AddFloat64Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddFloat64 at\n%s with params: %#v", m.AddFloat64Mock.defaultExpectation.expectationOrigins.origin, *m.AddFloat64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFloat64 != nil && afterAddFloat64Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddFloat64 at\n%s", m.funcAddFloat64Origin)
	}

	if !m.AddFloat64Mock.invocationsDone() && afterAddFloat64Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddFloat64 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddFloat64Mock.expectedInvocations), m.AddFloat64Mock.expectedInvocationsOrigin, afterAddFloat64Counter)
	}
}

type mEncoderMockAddInt struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddIntExpectation
	expectations       []*EncoderMockAddIntExpectation

	callArgs []*EncoderMockAddIntParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddIntExpectation specifies expectation struct of the Encoder.AddInt
type EncoderMockAddIntExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddIntParams
	paramPtrs          *EncoderMockAddIntParamPtrs
	expectationOrigins EncoderMockAddIntExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddIntParams contains parameters of the Encoder.AddInt
type EncoderMockAddIntParams struct {
	key   string
	value int
}

// EncoderMockAddIntParamPtrs contains pointers to parameters of the Encoder.AddInt
type EncoderMockAddIntParamPtrs struct {
	key   *string
	value *int
}

// EncoderMockAddIntOrigins contains origins of expectations of the Encoder.AddInt
type EncoderMockAddIntExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddInt *mEncoderMockAddInt) Optional() *mEncoderMockAddInt {
	mmAddInt.optional = true
	return mmAddInt
}

// Expect sets up expected params for Encoder.AddInt
func (mmAddInt *mEncoderMockAddInt) Expect(key string, value int) *mEncoderMockAddInt {
	if mmAddInt.mock.funcAddInt != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Set")
	}

	if mmAddInt.defaultExpectation == nil {
		mmAddInt.defaultExpectation = &EncoderMockAddIntExpectation{}
	}

	if mmAddInt.defaultExpectation.paramPtrs != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by ExpectParams functions")
	}

	mmAddInt.defaultExpectation.params = &EncoderMockAddIntParams{key, value}
	mmAddInt.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddInt.expectations {
		if minimock.Equal(e.params, mmAddInt.defaultExpectation.params) {
			mmAddInt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddInt.defaultExpectation.params)
		}
	}

	return mmAddInt
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddInt
func (mmAddInt *mEncoderMockAddInt) ExpectKeyParam1(key string) *mEncoderMockAddInt {
	if mmAddInt.mock.funcAddInt != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Set")
	}

	if mmAddInt.defaultExpectation == nil {
		mmAddInt.defaultExpectation = &EncoderMockAddIntExpectation{}
	}

	if mmAddInt.defaultExpectation.params != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Expect")
	}

	if mmAddInt.defaultExpectation.paramPtrs == nil {
		mmAddInt.defaultExpectation.paramPtrs = &EncoderMockAddIntParamPtrs{}
	}
	mmAddInt.defaultExpectation.paramPtrs.key = &key
	mmAddInt.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddInt
}

// ExpectValueParam2 sets up expected param value for Encoder.AddInt
func (mmAddInt *mEncoderMockAddInt) ExpectValueParam2(value int) *mEncoderMockAddInt {
	if mmAddInt.mock.funcAddInt != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Set")
	}

	if mmAddInt.defaultExpectation == nil {
		mmAddInt.defaultExpectation = &EncoderMockAddIntExpectation{}
	}

	if mmAddInt.defaultExpectation.params != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Expect")
	}

	if mmAddInt.defaultExpectation.paramPtrs == nil {
		mmAddInt.defaultExpectation.paramPtrs = &EncoderMockAddIntParamPtrs{}
	}
	mmAddInt.defaultExpectation.paramPtrs.value = &value
	mmAddInt.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddInt
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddInt
func (mmAddInt *mEncoderMockAddInt) Inspect(f func(key string, value int)) *mEncoderMockAddInt {
	if mmAddInt.mock.inspectFuncAddInt != nil {
		mmAddInt.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddInt")
	}

	mmAddInt.mock.inspectFuncAddInt = f

	return mmAddInt
}

// Return sets up results that will be returned by Encoder.AddInt
func (mmAddInt *mEncoderMockAddInt) Return() *EncoderMock {
	if mmAddInt.mock.funcAddInt != nil {
		mmAddInt.mock.t.Fatalf("EncoderMock.AddInt mock is already set by Set")
	}

	if mmAddInt.defaultExpectation == nil {
		mmAddInt.defaultExpectation = &EncoderMockAddIntExpectation{mock: mmAddInt.mock}
	}

	mmAddInt.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddInt.mock
}

// Set uses given function f to mock the Encoder.AddInt method
func (mmAddInt *mEncoderMockAddInt) Set(f func(key string, value int)) *EncoderMock {
	if mmAddInt.defaultExpectation != nil {
		mmAddInt.mock.t.Fatalf("Default expectation is already set for the Encoder.AddInt method")
	}

	if len(mmAddInt.expectations) > 0 {
		mmAddInt.mock.t.Fatalf("Some expectations are already set for the Encoder.AddInt method")
	}

	mmAddInt.mock.funcAddInt = f
	mmAddInt.mock.funcAddIntOrigin = minimock.CallerInfo(1)
	return mmAddInt.mock
}

// Times sets number of times Encoder.AddInt should be invoked
func (mmAddInt *mEncoderMockAddInt) Times(n uint64) *mEncoderMockAddInt {
	if n == 0 {
		mmAddInt.mock.t.Fatalf("Times of EncoderMock.AddInt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddInt.expectedInvocations, n)
	mmAddInt.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddInt
}

func (mmAddInt *mEncoderMockAddInt) invocationsDone() bool {
	if len(mmAddInt.expectations) == 0 && mmAddInt.defaultExpectation == nil && mmAddInt.mock.funcAddInt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddInt.mock.afterAddIntCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddInt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddInt implements Encoder
func (mmAddInt *EncoderMock) AddInt(key string, value int) {
	mm_atomic.AddUint64(&mmAddInt.beforeAddIntCounter, 1)
	defer mm_atomic.AddUint64(&mmAddInt.afterAddIntCounter, 1)

	mmAddInt.t.Helper()

	if mmAddInt.inspectFuncAddInt != nil {
		mmAddInt.inspectFuncAddInt(key, value)
	}

	mm_params := EncoderMockAddIntParams{key, value}

	// Record call args
	mmAddInt.AddIntMock.mutex.Lock()
	mmAddInt.AddIntMock.callArgs = append(mmAddInt.AddIntMock.callArgs, &mm_params)
	mmAddInt.AddIntMock.mutex.Unlock()

	for _, e := range mmAddInt.AddIntMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddInt.AddIntMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddInt.AddIntMock.defaultExpectation.Counter, 1)
		mm_want := mmAddInt.AddIntMock.defaultExpectation.params
		mm_want_ptrs := mmAddInt.AddIntMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddIntParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddInt.t.Errorf("EncoderMock.AddInt got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt.AddIntMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddInt.t.Errorf("EncoderMock.AddInt got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt.AddIntMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddInt.t.Errorf("EncoderMock.AddInt got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddInt.AddIntMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddInt.funcAddInt != nil {
		mmAddInt.funcAddInt(key, value)
		return
	}
	mmAddInt.t.Fatalf("Unexpected call to EncoderMock.AddInt. %v %v", key, value)

}

// AddIntAfterCounter returns a count of finished EncoderMock.AddInt invocations
func (mmAddInt *EncoderMock) AddIntAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt.afterAddIntCounter)
}

// AddIntBeforeCounter returns a count of EncoderMock.AddInt invocations
func (mmAddInt *EncoderMock) AddIntBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt.beforeAddIntCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddInt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddInt *mEncoderMockAddInt) Calls() []*EncoderMockAddIntParams {
	mmAddInt.mutex.RLock()

	argCopy := make([]*EncoderMockAddIntParams, len(mmAddInt.callArgs))
	copy(argCopy, mmAddInt.callArgs)

	mmAddInt.mutex.RUnlock()

	return argCopy
}

// MinimockAddIntDone returns true if the count of the AddInt invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddIntDone() bool {
	if m.AddIntMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddIntMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddIntMock.invocationsDone()
}

// MinimockAddIntInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddIntInspect() {
	for _, e := range m.AddIntMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddInt at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddIntCounter := mm_atomic.LoadUint64(&m.afterAddIntCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddIntMock.defaultExpectation != nil && afterAddIntCounter < 1 {
		if m.AddIntMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddInt at\n%s", m.AddIntMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddInt at\n%s with params: %#v", m.AddIntMock.defaultExpectation.expectationOrigins.origin, *m.AddIntMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddInt != nil && afterAddIntCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddInt at\n%s", m.funcAddIntOrigin)
	}

	if !m.AddIntMock.invocationsDone() && afterAddIntCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddInt at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddIntMock.expectedInvocations), m.AddIntMock.expectedInvocationsOrigin, afterAddIntCounter)
	}
}

type mEncoderMockAddInt16 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddInt16Expectation
	expectations       []*EncoderMockAddInt16Expectation

	callArgs []*EncoderMockAddInt16Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddInt16Expectation specifies expectation struct of the Encoder.AddInt16
type EncoderMockAddInt16Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddInt16Params
	paramPtrs          *EncoderMockAddInt16ParamPtrs
	expectationOrigins EncoderMockAddInt16ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddInt16Params contains parameters of the Encoder.AddInt16
type EncoderMockAddInt16Params struct {
	key   string
	value int16
}

// EncoderMockAddInt16ParamPtrs contains pointers to parameters of the Encoder.AddInt16
type EncoderMockAddInt16ParamPtrs struct {
	key   *string
	value *int16
}

// EncoderMockAddInt16Origins contains origins of expectations of the Encoder.AddInt16
type EncoderMockAddInt16ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddInt16 *mEncoderMockAddInt16) Optional() *mEncoderMockAddInt16 {
	mmAddInt16.optional = true
	return mmAddInt16
}

// Expect sets up expected params for Encoder.AddInt16
func (mmAddInt16 *mEncoderMockAddInt16) Expect(key string, value int16) *mEncoderMockAddInt16 {
	if mmAddInt16.mock.funcAddInt16 != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Set")
	}

	if mmAddInt16.defaultExpectation == nil {
		mmAddInt16.defaultExpectation = &EncoderMockAddInt16Expectation{}
	}

	if mmAddInt16.defaultExpectation.paramPtrs != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by ExpectParams functions")
	}

	mmAddInt16.defaultExpectation.params = &EncoderMockAddInt16Params{key, value}
	mmAddInt16.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddInt16.expectations {
		if minimock.Equal(e.params, mmAddInt16.defaultExpectation.params) {
			mmAddInt16.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddInt16.defaultExpectation.params)
		}
	}

	return mmAddInt16
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddInt16
func (mmAddInt16 *mEncoderMockAddInt16) ExpectKeyParam1(key string) *mEncoderMockAddInt16 {
	if mmAddInt16.mock.funcAddInt16 != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Set")
	}

	if mmAddInt16.defaultExpectation == nil {
		mmAddInt16.defaultExpectation = &EncoderMockAddInt16Expectation{}
	}

	if mmAddInt16.defaultExpectation.params != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Expect")
	}

	if mmAddInt16.defaultExpectation.paramPtrs == nil {
		mmAddInt16.defaultExpectation.paramPtrs = &EncoderMockAddInt16ParamPtrs{}
	}
	mmAddInt16.defaultExpectation.paramPtrs.key = &key
	mmAddInt16.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddInt16
}

// ExpectValueParam2 sets up expected param value for Encoder.AddInt16
func (mmAddInt16 *mEncoderMockAddInt16) ExpectValueParam2(value int16) *mEncoderMockAddInt16 {
	if mmAddInt16.mock.funcAddInt16 != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Set")
	}

	if mmAddInt16.defaultExpectation == nil {
		mmAddInt16.defaultExpectation = &EncoderMockAddInt16Expectation{}
	}

	if mmAddInt16.defaultExpectation.params != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Expect")
	}

	if mmAddInt16.defaultExpectation.paramPtrs == nil {
		mmAddInt16.defaultExpectation.paramPtrs = &EncoderMockAddInt16ParamPtrs{}
	}
	mmAddInt16.defaultExpectation.paramPtrs.value = &value
	mmAddInt16.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddInt16
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddInt16
func (mmAddInt16 *mEncoderMockAddInt16) Inspect(f func(key string, value int16)) *mEncoderMockAddInt16 {
	if mmAddInt16.mock.inspectFuncAddInt16 != nil {
		mmAddInt16.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddInt16")
	}

	mmAddInt16.mock.inspectFuncAddInt16 = f

	return mmAddInt16
}

// Return sets up results that will be returned by Encoder.AddInt16
func (mmAddInt16 *mEncoderMockAddInt16) Return() *EncoderMock {
	if mmAddInt16.mock.funcAddInt16 != nil {
		mmAddInt16.mock.t.Fatalf("EncoderMock.AddInt16 mock is already set by Set")
	}

	if mmAddInt16.defaultExpectation == nil {
		mmAddInt16.defaultExpectation = &EncoderMockAddInt16Expectation{mock: mmAddInt16.mock}
	}

	mmAddInt16.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddInt16.mock
}

// Set uses given function f to mock the Encoder.AddInt16 method
func (mmAddInt16 *mEncoderMockAddInt16) Set(f func(key string, value int16)) *EncoderMock {
	if mmAddInt16.defaultExpectation != nil {
		mmAddInt16.mock.t.Fatalf("Default expectation is already set for the Encoder.AddInt16 method")
	}

	if len(mmAddInt16.expectations) > 0 {
		mmAddInt16.mock.t.Fatalf("Some expectations are already set for the Encoder.AddInt16 method")
	}

	mmAddInt16.mock.funcAddInt16 = f
	mmAddInt16.mock.funcAddInt16Origin = minimock.CallerInfo(1)
	return mmAddInt16.mock
}

// Times sets number of times Encoder.AddInt16 should be invoked
func (mmAddInt16 *mEncoderMockAddInt16) Times(n uint64) *mEncoderMockAddInt16 {
	if n == 0 {
		mmAddInt16.mock.t.Fatalf("Times of EncoderMock.AddInt16 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddInt16.expectedInvocations, n)
	mmAddInt16.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddInt16
}

func (mmAddInt16 *mEncoderMockAddInt16) invocationsDone() bool {
	if len(mmAddInt16.expectations) == 0 && mmAddInt16.defaultExpectation == nil && mmAddInt16.mock.funcAddInt16 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddInt16.mock.afterAddInt16Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddInt16.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddInt16 implements Encoder
func (mmAddInt16 *EncoderMock) AddInt16(key string, value int16) {
	mm_atomic.AddUint64(&mmAddInt16.beforeAddInt16Counter, 1)
	defer mm_atomic.AddUint64(&mmAddInt16.afterAddInt16Counter, 1)

	mmAddInt16.t.Helper()

	if mmAddInt16.inspectFuncAddInt16 != nil {
		mmAddInt16.inspectFuncAddInt16(key, value)
	}

	mm_params := EncoderMockAddInt16Params{key, value}

	// Record call args
	mmAddInt16.AddInt16Mock.mutex.Lock()
	mmAddInt16.AddInt16Mock.callArgs = append(mmAddInt16.AddInt16Mock.callArgs, &mm_params)
	mmAddInt16.AddInt16Mock.mutex.Unlock()

	for _, e := range mmAddInt16.AddInt16Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddInt16.AddInt16Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddInt16.AddInt16Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddInt16.AddInt16Mock.defaultExpectation.params
		mm_want_ptrs := mmAddInt16.AddInt16Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddInt16Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddInt16.t.Errorf("EncoderMock.AddInt16 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt16.AddInt16Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddInt16.t.Errorf("EncoderMock.AddInt16 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt16.AddInt16Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddInt16.t.Errorf("EncoderMock.AddInt16 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddInt16.AddInt16Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddInt16.funcAddInt16 != nil {
		mmAddInt16.funcAddInt16(key, value)
		return
	}
	mmAddInt16.t.Fatalf("Unexpected call to EncoderMock.AddInt16. %v %v", key, value)

}

// AddInt16AfterCounter returns a count of finished EncoderMock.AddInt16 invocations
func (mmAddInt16 *EncoderMock) AddInt16AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt16.afterAddInt16Counter)
}

// AddInt16BeforeCounter returns a count of EncoderMock.AddInt16 invocations
func (mmAddInt16 *EncoderMock) AddInt16BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt16.beforeAddInt16Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddInt16.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddInt16 *mEncoderMockAddInt16) Calls() []*EncoderMockAddInt16Params {
	mmAddInt16.mutex.RLock()

	argCopy := make([]*EncoderMockAddInt16Params, len(mmAddInt16.callArgs))
	copy(argCopy, mmAddInt16.callArgs)

	mmAddInt16.mutex.RUnlock()

	return argCopy
}

// MinimockAddInt16Done returns true if the count of the AddInt16 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddInt16Done() bool {
	if m.AddInt16Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddInt16Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddInt16Mock.invocationsDone()
}

// MinimockAddInt16Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddInt16Inspect() {
	for _, e := range m.AddInt16Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddInt16 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddInt16Counter := mm_atomic.LoadUint64(&m.afterAddInt16Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddInt16Mock.defaultExpectation != nil && afterAddInt16Counter < 1 {
		if m.AddInt16Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddInt16 at\n%s", m.AddInt16Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddInt16 at\n%s with params: %#v", m.AddInt16Mock.defaultExpectation.expectationOrigins.origin, *m.AddInt16Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddInt16 != nil && afterAddInt16Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddInt16 at\n%s", m.funcAddInt16Origin)
	}

	if !m.AddInt16Mock.invocationsDone() && afterAddInt16Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddInt16 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddInt16Mock.expectedInvocations), m.AddInt16Mock.expectedInvocationsOrigin, afterAddInt16Counter)
	}
}

type mEncoderMockAddInt32 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddInt32Expectation
	expectations       []*EncoderMockAddInt32Expectation

	callArgs []*EncoderMockAddInt32Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddInt32Expectation specifies expectation struct of the Encoder.AddInt32
type EncoderMockAddInt32Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddInt32Params
	paramPtrs          *EncoderMockAddInt32ParamPtrs
	expectationOrigins EncoderMockAddInt32ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddInt32Params contains parameters of the Encoder.AddInt32
type EncoderMockAddInt32Params struct {
	key   string
	value int32
}

// EncoderMockAddInt32ParamPtrs contains pointers to parameters of the Encoder.AddInt32
type EncoderMockAddInt32ParamPtrs struct {
	key   *string
	value *int32
}

// EncoderMockAddInt32Origins contains origins of expectations of the Encoder.AddInt32
type EncoderMockAddInt32ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddInt32 *mEncoderMockAddInt32) Optional() *mEncoderMockAddInt32 {
	mmAddInt32.optional = true
	return mmAddInt32
}

// Expect sets up expected params for Encoder.AddInt32
func (mmAddInt32 *mEncoderMockAddInt32) Expect(key string, value int32) *mEncoderMockAddInt32 {
	if mmAddInt32.mock.funcAddInt32 != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Set")
	}

	if mmAddInt32.defaultExpectation == nil {
		mmAddInt32.defaultExpectation = &EncoderMockAddInt32Expectation{}
	}

	if mmAddInt32.defaultExpectation.paramPtrs != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by ExpectParams functions")
	}

	mmAddInt32.defaultExpectation.params = &EncoderMockAddInt32Params{key, value}
	mmAddInt32.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddInt32.expectations {
		if minimock.Equal(e.params, mmAddInt32.defaultExpectation.params) {
			mmAddInt32.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddInt32.defaultExpectation.params)
		}
	}

	return mmAddInt32
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddInt32
func (mmAddInt32 *mEncoderMockAddInt32) ExpectKeyParam1(key string) *mEncoderMockAddInt32 {
	if mmAddInt32.mock.funcAddInt32 != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Set")
	}

	if mmAddInt32.defaultExpectation == nil {
		mmAddInt32.defaultExpectation = &EncoderMockAddInt32Expectation{}
	}

	if mmAddInt32.defaultExpectation.params != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Expect")
	}

	if mmAddInt32.defaultExpectation.paramPtrs == nil {
		mmAddInt32.defaultExpectation.paramPtrs = &EncoderMockAddInt32ParamPtrs{}
	}
	mmAddInt32.defaultExpectation.paramPtrs.key = &key
	mmAddInt32.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddInt32
}

// ExpectValueParam2 sets up expected param value for Encoder.AddInt32
func (mmAddInt32 *mEncoderMockAddInt32) ExpectValueParam2(value int32) *mEncoderMockAddInt32 {
	if mmAddInt32.mock.funcAddInt32 != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Set")
	}

	if mmAddInt32.defaultExpectation == nil {
		mmAddInt32.defaultExpectation = &EncoderMockAddInt32Expectation{}
	}

	if mmAddInt32.defaultExpectation.params != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Expect")
	}

	if mmAddInt32.defaultExpectation.paramPtrs == nil {
		mmAddInt32.defaultExpectation.paramPtrs = &EncoderMockAddInt32ParamPtrs{}
	}
	mmAddInt32.defaultExpectation.paramPtrs.value = &value
	mmAddInt32.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddInt32
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddInt32
func (mmAddInt32 *mEncoderMockAddInt32) Inspect(f func(key string, value int32)) *mEncoderMockAddInt32 {
	if mmAddInt32.mock.inspectFuncAddInt32 != nil {
		mmAddInt32.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddInt32")
	}

	mmAddInt32.mock.inspectFuncAddInt32 = f

	return mmAddInt32
}

// Return sets up results that will be returned by Encoder.AddInt32
func (mmAddInt32 *mEncoderMockAddInt32) Return() *EncoderMock {
	if mmAddInt32.mock.funcAddInt32 != nil {
		mmAddInt32.mock.t.Fatalf("EncoderMock.AddInt32 mock is already set by Set")
	}

	if mmAddInt32.defaultExpectation == nil {
		mmAddInt32.defaultExpectation = &EncoderMockAddInt32Expectation{mock: mmAddInt32.mock}
	}

	mmAddInt32.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddInt32.mock
}

// Set uses given function f to mock the Encoder.AddInt32 method
func (mmAddInt32 *mEncoderMockAddInt32) Set(f func(key string, value int32)) *EncoderMock {
	if mmAddInt32.defaultExpectation != nil {
		mmAddInt32.mock.t.Fatalf("Default expectation is already set for the Encoder.AddInt32 method")
	}

	if len(mmAddInt32.expectations) > 0 {
		mmAddInt32.mock.t.Fatalf("Some expectations are already set for the Encoder.AddInt32 method")
	}

	mmAddInt32.mock.funcAddInt32 = f
	mmAddInt32.mock.funcAddInt32Origin = minimock.CallerInfo(1)
	return mmAddInt32.mock
}

// Times sets number of times Encoder.AddInt32 should be invoked
func (mmAddInt32 *mEncoderMockAddInt32) Times(n uint64) *mEncoderMockAddInt32 {
	if n == 0 {
		mmAddInt32.mock.t.Fatalf("Times of EncoderMock.AddInt32 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddInt32.expectedInvocations, n)
	mmAddInt32.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddInt32
}

func (mmAddInt32 *mEncoderMockAddInt32) invocationsDone() bool {
	if len(mmAddInt32.expectations) == 0 && mmAddInt32.defaultExpectation == nil && mmAddInt32.mock.funcAddInt32 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddInt32.mock.afterAddInt32Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddInt32.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddInt32 implements Encoder
func (mmAddInt32 *EncoderMock) AddInt32(key string, value int32) {
	mm_atomic.AddUint64(&mmAddInt32.beforeAddInt32Counter, 1)
	defer mm_atomic.AddUint64(&mmAddInt32.afterAddInt32Counter, 1)

	mmAddInt32.t.Helper()

	if mmAddInt32.inspectFuncAddInt32 != nil {
		mmAddInt32.inspectFuncAddInt32(key, value)
	}

	mm_params := EncoderMockAddInt32Params{key, value}

	// Record call args
	mmAddInt32.AddInt32Mock.mutex.Lock()
	mmAddInt32.AddInt32Mock.callArgs = append(mmAddInt32.AddInt32Mock.callArgs, &mm_params)
	mmAddInt32.AddInt32Mock.mutex.Unlock()

	for _, e := range mmAddInt32.AddInt32Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddInt32.AddInt32Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddInt32.AddInt32Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddInt32.AddInt32Mock.defaultExpectation.params
		mm_want_ptrs := mmAddInt32.AddInt32Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddInt32Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddInt32.t.Errorf("EncoderMock.AddInt32 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt32.AddInt32Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddInt32.t.Errorf("EncoderMock.AddInt32 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt32.AddInt32Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddInt32.t.Errorf("EncoderMock.AddInt32 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddInt32.AddInt32Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddInt32.funcAddInt32 != nil {
		mmAddInt32.funcAddInt32(key, value)
		return
	}
	mmAddInt32.t.Fatalf("Unexpected call to EncoderMock.AddInt32. %v %v", key, value)

}

// AddInt32AfterCounter returns a count of finished EncoderMock.AddInt32 invocations
func (mmAddInt32 *EncoderMock) AddInt32AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt32.afterAddInt32Counter)
}

// AddInt32BeforeCounter returns a count of EncoderMock.AddInt32 invocations
func (mmAddInt32 *EncoderMock) AddInt32BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt32.beforeAddInt32Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddInt32.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddInt32 *mEncoderMockAddInt32) Calls() []*EncoderMockAddInt32Params {
	mmAddInt32.mutex.RLock()

	argCopy := make([]*EncoderMockAddInt32Params, len(mmAddInt32.callArgs))
	copy(argCopy, mmAddInt32.callArgs)

	mmAddInt32.mutex.RUnlock()

	return argCopy
}

// MinimockAddInt32Done returns true if the count of the AddInt32 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddInt32Done() bool {
	if m.AddInt32Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddInt32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddInt32Mock.invocationsDone()
}

// MinimockAddInt32Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddInt32Inspect() {
	for _, e := range m.AddInt32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddInt32 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddInt32Counter := mm_atomic.LoadUint64(&m.afterAddInt32Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddInt32Mock.defaultExpectation != nil && afterAddInt32Counter < 1 {
		if m.AddInt32Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddInt32 at\n%s", m.AddInt32Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddInt32 at\n%s with params: %#v", m.AddInt32Mock.defaultExpectation.expectationOrigins.origin, *m.AddInt32Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddInt32 != nil && afterAddInt32Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddInt32 at\n%s", m.funcAddInt32Origin)
	}

	if !m.AddInt32Mock.invocationsDone() && afterAddInt32Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddInt32 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddInt32Mock.expectedInvocations), m.AddInt32Mock.expectedInvocationsOrigin, afterAddInt32Counter)
	}
}

type mEncoderMockAddInt64 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddInt64Expectation
	expectations       []*EncoderMockAddInt64Expectation

	callArgs []*EncoderMockAddInt64Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddInt64Expectation specifies expectation struct of the Encoder.AddInt64
type EncoderMockAddInt64Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddInt64Params
	paramPtrs          *EncoderMockAddInt64ParamPtrs
	expectationOrigins EncoderMockAddInt64ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddInt64Params contains parameters of the Encoder.AddInt64
type EncoderMockAddInt64Params struct {
	key   string
	value int64
}

// EncoderMockAddInt64ParamPtrs contains pointers to parameters of the Encoder.AddInt64
type EncoderMockAddInt64ParamPtrs struct {
	key   *string
	value *int64
}

// EncoderMockAddInt64Origins contains origins of expectations of the Encoder.AddInt64
type EncoderMockAddInt64ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddInt64 *mEncoderMockAddInt64) Optional() *mEncoderMockAddInt64 {
	mmAddInt64.optional = true
	return mmAddInt64
}

// Expect sets up expected params for Encoder.AddInt64
func (mmAddInt64 *mEncoderMockAddInt64) Expect(key string, value int64) *mEncoderMockAddInt64 {
	if mmAddInt64.mock.funcAddInt64 != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Set")
	}

	if mmAddInt64.defaultExpectation == nil {
		mmAddInt64.defaultExpectation = &EncoderMockAddInt64Expectation{}
	}

	if mmAddInt64.defaultExpectation.paramPtrs != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by ExpectParams functions")
	}

	mmAddInt64.defaultExpectation.params = &EncoderMockAddInt64Params{key, value}
	mmAddInt64.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddInt64.expectations {
		if minimock.Equal(e.params, mmAddInt64.defaultExpectation.params) {
			mmAddInt64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddInt64.defaultExpectation.params)
		}
	}

	return mmAddInt64
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddInt64
func (mmAddInt64 *mEncoderMockAddInt64) ExpectKeyParam1(key string) *mEncoderMockAddInt64 {
	if mmAddInt64.mock.funcAddInt64 != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Set")
	}

	if mmAddInt64.defaultExpectation == nil {
		mmAddInt64.defaultExpectation = &EncoderMockAddInt64Expectation{}
	}

	if mmAddInt64.defaultExpectation.params != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Expect")
	}

	if mmAddInt64.defaultExpectation.paramPtrs == nil {
		mmAddInt64.defaultExpectation.paramPtrs = &EncoderMockAddInt64ParamPtrs{}
	}
	mmAddInt64.defaultExpectation.paramPtrs.key = &key
	mmAddInt64.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddInt64
}

// ExpectValueParam2 sets up expected param value for Encoder.AddInt64
func (mmAddInt64 *mEncoderMockAddInt64) ExpectValueParam2(value int64) *mEncoderMockAddInt64 {
	if mmAddInt64.mock.funcAddInt64 != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Set")
	}

	if mmAddInt64.defaultExpectation == nil {
		mmAddInt64.defaultExpectation = &EncoderMockAddInt64Expectation{}
	}

	if mmAddInt64.defaultExpectation.params != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Expect")
	}

	if mmAddInt64.defaultExpectation.paramPtrs == nil {
		mmAddInt64.defaultExpectation.paramPtrs = &EncoderMockAddInt64ParamPtrs{}
	}
	mmAddInt64.defaultExpectation.paramPtrs.value = &value
	mmAddInt64.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddInt64
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddInt64
func (mmAddInt64 *mEncoderMockAddInt64) Inspect(f func(key string, value int64)) *mEncoderMockAddInt64 {
	if mmAddInt64.mock.inspectFuncAddInt64 != nil {
		mmAddInt64.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddInt64")
	}

	mmAddInt64.mock.inspectFuncAddInt64 = f

	return mmAddInt64
}

// Return sets up results that will be returned by Encoder.AddInt64
func (mmAddInt64 *mEncoderMockAddInt64) Return() *EncoderMock {
	if mmAddInt64.mock.funcAddInt64 != nil {
		mmAddInt64.mock.t.Fatalf("EncoderMock.AddInt64 mock is already set by Set")
	}

	if mmAddInt64.defaultExpectation == nil {
		mmAddInt64.defaultExpectation = &EncoderMockAddInt64Expectation{mock: mmAddInt64.mock}
	}

	mmAddInt64.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddInt64.mock
}

// Set uses given function f to mock the Encoder.AddInt64 method
func (mmAddInt64 *mEncoderMockAddInt64) Set(f func(key string, value int64)) *EncoderMock {
	if mmAddInt64.defaultExpectation != nil {
		mmAddInt64.mock.t.Fatalf("Default expectation is already set for the Encoder.AddInt64 method")
	}

	if len(mmAddInt64.expectations) > 0 {
		mmAddInt64.mock.t.Fatalf("Some expectations are already set for the Encoder.AddInt64 method")
	}

	mmAddInt64.mock.funcAddInt64 = f
	mmAddInt64.mock.funcAddInt64Origin = minimock.CallerInfo(1)
	return mmAddInt64.mock
}

// Times sets number of times Encoder.AddInt64 should be invoked
func (mmAddInt64 *mEncoderMockAddInt64) Times(n uint64) *mEncoderMockAddInt64 {
	if n == 0 {
		mmAddInt64.mock.t.Fatalf("Times of EncoderMock.AddInt64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddInt64.expectedInvocations, n)
	mmAddInt64.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddInt64
}

func (mmAddInt64 *mEncoderMockAddInt64) invocationsDone() bool {
	if len(mmAddInt64.expectations) == 0 && mmAddInt64.defaultExpectation == nil && mmAddInt64.mock.funcAddInt64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddInt64.mock.afterAddInt64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddInt64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddInt64 implements Encoder
func (mmAddInt64 *EncoderMock) AddInt64(key string, value int64) {
	mm_atomic.AddUint64(&mmAddInt64.beforeAddInt64Counter, 1)
	defer mm_atomic.AddUint64(&mmAddInt64.afterAddInt64Counter, 1)

	mmAddInt64.t.Helper()

	if mmAddInt64.inspectFuncAddInt64 != nil {
		mmAddInt64.inspectFuncAddInt64(key, value)
	}

	mm_params := EncoderMockAddInt64Params{key, value}

	// Record call args
	mmAddInt64.AddInt64Mock.mutex.Lock()
	mmAddInt64.AddInt64Mock.callArgs = append(mmAddInt64.AddInt64Mock.callArgs, &mm_params)
	mmAddInt64.AddInt64Mock.mutex.Unlock()

	for _, e := range mmAddInt64.AddInt64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddInt64.AddInt64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddInt64.AddInt64Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddInt64.AddInt64Mock.defaultExpectation.params
		mm_want_ptrs := mmAddInt64.AddInt64Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddInt64Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddInt64.t.Errorf("EncoderMock.AddInt64 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt64.AddInt64Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddInt64.t.Errorf("EncoderMock.AddInt64 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt64.AddInt64Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddInt64.t.Errorf("EncoderMock.AddInt64 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddInt64.AddInt64Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddInt64.funcAddInt64 != nil {
		mmAddInt64.funcAddInt64(key, value)
		return
	}
	mmAddInt64.t.Fatalf("Unexpected call to EncoderMock.AddInt64. %v %v", key, value)

}

// AddInt64AfterCounter returns a count of finished EncoderMock.AddInt64 invocations
func (mmAddInt64 *EncoderMock) AddInt64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt64.afterAddInt64Counter)
}

// AddInt64BeforeCounter returns a count of EncoderMock.AddInt64 invocations
func (mmAddInt64 *EncoderMock) AddInt64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt64.beforeAddInt64Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddInt64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddInt64 *mEncoderMockAddInt64) Calls() []*EncoderMockAddInt64Params {
	mmAddInt64.mutex.RLock()

	argCopy := make([]*EncoderMockAddInt64Params, len(mmAddInt64.callArgs))
	copy(argCopy, mmAddInt64.callArgs)

	mmAddInt64.mutex.RUnlock()

	return argCopy
}

// MinimockAddInt64Done returns true if the count of the AddInt64 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddInt64Done() bool {
	if m.AddInt64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddInt64Mock.invocationsDone()
}

// MinimockAddInt64Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddInt64Inspect() {
	for _, e := range m.AddInt64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddInt64 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddInt64Counter := mm_atomic.LoadUint64(&m.afterAddInt64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddInt64Mock.defaultExpectation != nil && afterAddInt64Counter < 1 {
		if m.AddInt64Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddInt64 at\n%s", m.AddInt64Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddInt64 at\n%s with params: %#v", m.AddInt64Mock.defaultExpectation.expectationOrigins.origin, *m.AddInt64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddInt64 != nil && afterAddInt64Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddInt64 at\n%s", m.funcAddInt64Origin)
	}

	if !m.AddInt64Mock.invocationsDone() && afterAddInt64Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddInt64 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddInt64Mock.expectedInvocations), m.AddInt64Mock.expectedInvocationsOrigin, afterAddInt64Counter)
	}
}

type mEncoderMockAddInt8 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddInt8Expectation
	expectations       []*EncoderMockAddInt8Expectation

	callArgs []*EncoderMockAddInt8Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddInt8Expectation specifies expectation struct of the Encoder.AddInt8
type EncoderMockAddInt8Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddInt8Params
	paramPtrs          *EncoderMockAddInt8ParamPtrs
	expectationOrigins EncoderMockAddInt8ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddInt8Params contains parameters of the Encoder.AddInt8
type EncoderMockAddInt8Params struct {
	key   string
	value int8
}

// EncoderMockAddInt8ParamPtrs contains pointers to parameters of the Encoder.AddInt8
type EncoderMockAddInt8ParamPtrs struct {
	key   *string
	value *int8
}

// EncoderMockAddInt8Origins contains origins of expectations of the Encoder.AddInt8
type EncoderMockAddInt8ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddInt8 *mEncoderMockAddInt8) Optional() *mEncoderMockAddInt8 {
	mmAddInt8.optional = true
	return mmAddInt8
}

// Expect sets up expected params for Encoder.AddInt8
func (mmAddInt8 *mEncoderMockAddInt8) Expect(key string, value int8) *mEncoderMockAddInt8 {
	if mmAddInt8.mock.funcAddInt8 != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Set")
	}

	if mmAddInt8.defaultExpectation == nil {
		mmAddInt8.defaultExpectation = &EncoderMockAddInt8Expectation{}
	}

	if mmAddInt8.defaultExpectation.paramPtrs != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by ExpectParams functions")
	}

	mmAddInt8.defaultExpectation.params = &EncoderMockAddInt8Params{key, value}
	mmAddInt8.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddInt8.expectations {
		if minimock.Equal(e.params, mmAddInt8.defaultExpectation.params) {
			mmAddInt8.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddInt8.defaultExpectation.params)
		}
	}

	return mmAddInt8
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddInt8
func (mmAddInt8 *mEncoderMockAddInt8) ExpectKeyParam1(key string) *mEncoderMockAddInt8 {
	if mmAddInt8.mock.funcAddInt8 != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Set")
	}

	if mmAddInt8.defaultExpectation == nil {
		mmAddInt8.defaultExpectation = &EncoderMockAddInt8Expectation{}
	}

	if mmAddInt8.defaultExpectation.params != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Expect")
	}

	if mmAddInt8.defaultExpectation.paramPtrs == nil {
		mmAddInt8.defaultExpectation.paramPtrs = &EncoderMockAddInt8ParamPtrs{}
	}
	mmAddInt8.defaultExpectation.paramPtrs.key = &key
	mmAddInt8.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddInt8
}

// ExpectValueParam2 sets up expected param value for Encoder.AddInt8
func (mmAddInt8 *mEncoderMockAddInt8) ExpectValueParam2(value int8) *mEncoderMockAddInt8 {
	if mmAddInt8.mock.funcAddInt8 != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Set")
	}

	if mmAddInt8.defaultExpectation == nil {
		mmAddInt8.defaultExpectation = &EncoderMockAddInt8Expectation{}
	}

	if mmAddInt8.defaultExpectation.params != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Expect")
	}

	if mmAddInt8.defaultExpectation.paramPtrs == nil {
		mmAddInt8.defaultExpectation.paramPtrs = &EncoderMockAddInt8ParamPtrs{}
	}
	mmAddInt8.defaultExpectation.paramPtrs.value = &value
	mmAddInt8.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddInt8
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddInt8
func (mmAddInt8 *mEncoderMockAddInt8) Inspect(f func(key string, value int8)) *mEncoderMockAddInt8 {
	if mmAddInt8.mock.inspectFuncAddInt8 != nil {
		mmAddInt8.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddInt8")
	}

	mmAddInt8.mock.inspectFuncAddInt8 = f

	return mmAddInt8
}

// Return sets up results that will be returned by Encoder.AddInt8
func (mmAddInt8 *mEncoderMockAddInt8) Return() *EncoderMock {
	if mmAddInt8.mock.funcAddInt8 != nil {
		mmAddInt8.mock.t.Fatalf("EncoderMock.AddInt8 mock is already set by Set")
	}

	if mmAddInt8.defaultExpectation == nil {
		mmAddInt8.defaultExpectation = &EncoderMockAddInt8Expectation{mock: mmAddInt8.mock}
	}

	mmAddInt8.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddInt8.mock
}

// Set uses given function f to mock the Encoder.AddInt8 method
func (mmAddInt8 *mEncoderMockAddInt8) Set(f func(key string, value int8)) *EncoderMock {
	if mmAddInt8.defaultExpectation != nil {
		mmAddInt8.mock.t.Fatalf("Default expectation is already set for the Encoder.AddInt8 method")
	}

	if len(mmAddInt8.expectations) > 0 {
		mmAddInt8.mock.t.Fatalf("Some expectations are already set for the Encoder.AddInt8 method")
	}

	mmAddInt8.mock.funcAddInt8 = f
	mmAddInt8.mock.funcAddInt8Origin = minimock.CallerInfo(1)
	return mmAddInt8.mock
}

// Times sets number of times Encoder.AddInt8 should be invoked
func (mmAddInt8 *mEncoderMockAddInt8) Times(n uint64) *mEncoderMockAddInt8 {
	if n == 0 {
		mmAddInt8.mock.t.Fatalf("Times of EncoderMock.AddInt8 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddInt8.expectedInvocations, n)
	mmAddInt8.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddInt8
}

func (mmAddInt8 *mEncoderMockAddInt8) invocationsDone() bool {
	if len(mmAddInt8.expectations) == 0 && mmAddInt8.defaultExpectation == nil && mmAddInt8.mock.funcAddInt8 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddInt8.mock.afterAddInt8Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddInt8.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddInt8 implements Encoder
func (mmAddInt8 *EncoderMock) AddInt8(key string, value int8) {
	mm_atomic.AddUint64(&mmAddInt8.beforeAddInt8Counter, 1)
	defer mm_atomic.AddUint64(&mmAddInt8.afterAddInt8Counter, 1)

	mmAddInt8.t.Helper()

	if mmAddInt8.inspectFuncAddInt8 != nil {
		mmAddInt8.inspectFuncAddInt8(key, value)
	}

	mm_params := EncoderMockAddInt8Params{key, value}

	// Record call args
	mmAddInt8.AddInt8Mock.mutex.Lock()
	mmAddInt8.AddInt8Mock.callArgs = append(mmAddInt8.AddInt8Mock.callArgs, &mm_params)
	mmAddInt8.AddInt8Mock.mutex.Unlock()

	for _, e := range mmAddInt8.AddInt8Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddInt8.AddInt8Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddInt8.AddInt8Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddInt8.AddInt8Mock.defaultExpectation.params
		mm_want_ptrs := mmAddInt8.AddInt8Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddInt8Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddInt8.t.Errorf("EncoderMock.AddInt8 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt8.AddInt8Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddInt8.t.Errorf("EncoderMock.AddInt8 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddInt8.AddInt8Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddInt8.t.Errorf("EncoderMock.AddInt8 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddInt8.AddInt8Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddInt8.funcAddInt8 != nil {
		mmAddInt8.funcAddInt8(key, value)
		return
	}
	mmAddInt8.t.Fatalf("Unexpected call to EncoderMock.AddInt8. %v %v", key, value)

}

// AddInt8AfterCounter returns a count of finished EncoderMock.AddInt8 invocations
func (mmAddInt8 *EncoderMock) AddInt8AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt8.afterAddInt8Counter)
}

// AddInt8BeforeCounter returns a count of EncoderMock.AddInt8 invocations
func (mmAddInt8 *EncoderMock) AddInt8BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddInt8.beforeAddInt8Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddInt8.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddInt8 *mEncoderMockAddInt8) Calls() []*EncoderMockAddInt8Params {
	mmAddInt8.mutex.RLock()

	argCopy := make([]*EncoderMockAddInt8Params, len(mmAddInt8.callArgs))
	copy(argCopy, mmAddInt8.callArgs)

	mmAddInt8.mutex.RUnlock()

	return argCopy
}

// MinimockAddInt8Done returns true if the count of the AddInt8 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddInt8Done() bool {
	if m.AddInt8Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddInt8Mock.invocationsDone()
}

// MinimockAddInt8Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddInt8Inspect() {
	for _, e := range m.AddInt8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddInt8 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddInt8Counter := mm_atomic.LoadUint64(&m.afterAddInt8Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddInt8Mock.defaultExpectation != nil && afterAddInt8Counter < 1 {
		if m.AddInt8Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddInt8 at\n%s", m.AddInt8Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddInt8 at\n%s with params: %#v", m.AddInt8Mock.defaultExpectation.expectationOrigins.origin, *m.AddInt8Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddInt8 != nil && afterAddInt8Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddInt8 at\n%s", m.funcAddInt8Origin)
	}

	if !m.AddInt8Mock.invocationsDone() && afterAddInt8Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddInt8 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddInt8Mock.expectedInvocations), m.AddInt8Mock.expectedInvocationsOrigin, afterAddInt8Counter)
	}
}

type mEncoderMockAddObject struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddObjectExpectation
	expectations       []*EncoderMockAddObjectExpectation

	callArgs []*EncoderMockAddObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddObjectExpectation specifies expectation struct of the Encoder.AddObject
type EncoderMockAddObjectExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddObjectParams
	paramPtrs          *EncoderMockAddObjectParamPtrs
	expectationOrigins EncoderMockAddObjectExpectationOrigins
	results            *EncoderMockAddObjectResults
	returnOrigin       string
	Counter            uint64
}

// EncoderMockAddObjectParams contains parameters of the Encoder.AddObject
type EncoderMockAddObjectParams struct {
	key       string
	marshaler zapcore.ObjectMarshaler
}

// EncoderMockAddObjectParamPtrs contains pointers to parameters of the Encoder.AddObject
type EncoderMockAddObjectParamPtrs struct {
	key       *string
	marshaler *zapcore.ObjectMarshaler
}

// EncoderMockAddObjectResults contains results of the Encoder.AddObject
type EncoderMockAddObjectResults struct {
	err error
}

// EncoderMockAddObjectOrigins contains origins of expectations of the Encoder.AddObject
type EncoderMockAddObjectExpectationOrigins struct {
	origin          string
	originKey       string
	originMarshaler string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddObject *mEncoderMockAddObject) Optional() *mEncoderMockAddObject {
	mmAddObject.optional = true
	return mmAddObject
}

// Expect sets up expected params for Encoder.AddObject
func (mmAddObject *mEncoderMockAddObject) Expect(key string, marshaler zapcore.ObjectMarshaler) *mEncoderMockAddObject {
	if mmAddObject.mock.funcAddObject != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Set")
	}

	if mmAddObject.defaultExpectation == nil {
		mmAddObject.defaultExpectation = &EncoderMockAddObjectExpectation{}
	}

	if mmAddObject.defaultExpectation.paramPtrs != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by ExpectParams functions")
	}

	mmAddObject.defaultExpectation.params = &EncoderMockAddObjectParams{key, marshaler}
	mmAddObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddObject.expectations {
		if minimock.Equal(e.params, mmAddObject.defaultExpectation.params) {
			mmAddObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddObject.defaultExpectation.params)
		}
	}

	return mmAddObject
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddObject
func (mmAddObject *mEncoderMockAddObject) ExpectKeyParam1(key string) *mEncoderMockAddObject {
	if mmAddObject.mock.funcAddObject != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Set")
	}

	if mmAddObject.defaultExpectation == nil {
		mmAddObject.defaultExpectation = &EncoderMockAddObjectExpectation{}
	}

	if mmAddObject.defaultExpectation.params != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Expect")
	}

	if mmAddObject.defaultExpectation.paramPtrs == nil {
		mmAddObject.defaultExpectation.paramPtrs = &EncoderMockAddObjectParamPtrs{}
	}
	mmAddObject.defaultExpectation.paramPtrs.key = &key
	mmAddObject.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddObject
}

// ExpectMarshalerParam2 sets up expected param marshaler for Encoder.AddObject
func (mmAddObject *mEncoderMockAddObject) ExpectMarshalerParam2(marshaler zapcore.ObjectMarshaler) *mEncoderMockAddObject {
	if mmAddObject.mock.funcAddObject != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Set")
	}

	if mmAddObject.defaultExpectation == nil {
		mmAddObject.defaultExpectation = &EncoderMockAddObjectExpectation{}
	}

	if mmAddObject.defaultExpectation.params != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Expect")
	}

	if mmAddObject.defaultExpectation.paramPtrs == nil {
		mmAddObject.defaultExpectation.paramPtrs = &EncoderMockAddObjectParamPtrs{}
	}
	mmAddObject.defaultExpectation.paramPtrs.marshaler = &marshaler
	mmAddObject.defaultExpectation.expectationOrigins.originMarshaler = minimock.CallerInfo(1)

	return mmAddObject
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddObject
func (mmAddObject *mEncoderMockAddObject) Inspect(f func(key string, marshaler zapcore.ObjectMarshaler)) *mEncoderMockAddObject {
	if mmAddObject.mock.inspectFuncAddObject != nil {
		mmAddObject.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddObject")
	}

	mmAddObject.mock.inspectFuncAddObject = f

	return mmAddObject
}

// Return sets up results that will be returned by Encoder.AddObject
func (mmAddObject *mEncoderMockAddObject) Return(err error) *EncoderMock {
	if mmAddObject.mock.funcAddObject != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Set")
	}

	if mmAddObject.defaultExpectation == nil {
		mmAddObject.defaultExpectation = &EncoderMockAddObjectExpectation{mock: mmAddObject.mock}
	}
	mmAddObject.defaultExpectation.results = &EncoderMockAddObjectResults{err}
	mmAddObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddObject.mock
}

// Set uses given function f to mock the Encoder.AddObject method
func (mmAddObject *mEncoderMockAddObject) Set(f func(key string, marshaler zapcore.ObjectMarshaler) (err error)) *EncoderMock {
	if mmAddObject.defaultExpectation != nil {
		mmAddObject.mock.t.Fatalf("Default expectation is already set for the Encoder.AddObject method")
	}

	if len(mmAddObject.expectations) > 0 {
		mmAddObject.mock.t.Fatalf("Some expectations are already set for the Encoder.AddObject method")
	}

	mmAddObject.mock.funcAddObject = f
	mmAddObject.mock.funcAddObjectOrigin = minimock.CallerInfo(1)
	return mmAddObject.mock
}

// When sets expectation for the Encoder.AddObject which will trigger the result defined by the following
// Then helper
func (mmAddObject *mEncoderMockAddObject) When(key string, marshaler zapcore.ObjectMarshaler) *EncoderMockAddObjectExpectation {
	if mmAddObject.mock.funcAddObject != nil {
		mmAddObject.mock.t.Fatalf("EncoderMock.AddObject mock is already set by Set")
	}

	expectation := &EncoderMockAddObjectExpectation{
		mock:               mmAddObject.mock,
		params:             &EncoderMockAddObjectParams{key, marshaler},
		expectationOrigins: EncoderMockAddObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddObject.expectations = append(mmAddObject.expectations, expectation)
	return expectation
}

// Then sets up Encoder.AddObject return parameters for the expectation previously defined by the When method
func (e *EncoderMockAddObjectExpectation) Then(err error) *EncoderMock {
	e.results = &EncoderMockAddObjectResults{err}
	return e.mock
}

// Times sets number of times Encoder.AddObject should be invoked
func (mmAddObject *mEncoderMockAddObject) Times(n uint64) *mEncoderMockAddObject {
	if n == 0 {
		mmAddObject.mock.t.Fatalf("Times of EncoderMock.AddObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddObject.expectedInvocations, n)
	mmAddObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddObject
}

func (mmAddObject *mEncoderMockAddObject) invocationsDone() bool {
	if len(mmAddObject.expectations) == 0 && mmAddObject.defaultExpectation == nil && mmAddObject.mock.funcAddObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddObject.mock.afterAddObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddObject implements Encoder
func (mmAddObject *EncoderMock) AddObject(key string, marshaler zapcore.ObjectMarshaler) (err error) {
	mm_atomic.AddUint64(&mmAddObject.beforeAddObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmAddObject.afterAddObjectCounter, 1)

	mmAddObject.t.Helper()

	if mmAddObject.inspectFuncAddObject != nil {
		mmAddObject.inspectFuncAddObject(key, marshaler)
	}

	mm_params := EncoderMockAddObjectParams{key, marshaler}

	// Record call args
	mmAddObject.AddObjectMock.mutex.Lock()
	mmAddObject.AddObjectMock.callArgs = append(mmAddObject.AddObjectMock.callArgs, &mm_params)
	mmAddObject.AddObjectMock.mutex.Unlock()

	for _, e := range mmAddObject.AddObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddObject.AddObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddObject.AddObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmAddObject.AddObjectMock.defaultExpectation.params
		mm_want_ptrs := mmAddObject.AddObjectMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddObjectParams{key, marshaler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddObject.t.Errorf("EncoderMock.AddObject got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddObject.AddObjectMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.marshaler != nil && !minimock.Equal(*mm_want_ptrs.marshaler, mm_got.marshaler) {
				mmAddObject.t.Errorf("EncoderMock.AddObject got unexpected parameter marshaler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddObject.AddObjectMock.defaultExpectation.expectationOrigins.originMarshaler, *mm_want_ptrs.marshaler, mm_got.marshaler, minimock.Diff(*mm_want_ptrs.marshaler, mm_got.marshaler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddObject.t.Errorf("EncoderMock.AddObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddObject.AddObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddObject.AddObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmAddObject.t.Fatal("No results are set for the EncoderMock.AddObject")
		}
		return (*mm_results).err
	}
	if mmAddObject.funcAddObject != nil {
		return mmAddObject.funcAddObject(key, marshaler)
	}
	mmAddObject.t.Fatalf("Unexpected call to EncoderMock.AddObject. %v %v", key, marshaler)
	return
}

// AddObjectAfterCounter returns a count of finished EncoderMock.AddObject invocations
func (mmAddObject *EncoderMock) AddObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddObject.afterAddObjectCounter)
}

// AddObjectBeforeCounter returns a count of EncoderMock.AddObject invocations
func (mmAddObject *EncoderMock) AddObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddObject.beforeAddObjectCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddObject *mEncoderMockAddObject) Calls() []*EncoderMockAddObjectParams {
	mmAddObject.mutex.RLock()

	argCopy := make([]*EncoderMockAddObjectParams, len(mmAddObject.callArgs))
	copy(argCopy, mmAddObject.callArgs)

	mmAddObject.mutex.RUnlock()

	return argCopy
}

// MinimockAddObjectDone returns true if the count of the AddObject invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddObjectDone() bool {
	if m.AddObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddObjectMock.invocationsDone()
}

// MinimockAddObjectInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddObjectInspect() {
	for _, e := range m.AddObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddObjectCounter := mm_atomic.LoadUint64(&m.afterAddObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddObjectMock.defaultExpectation != nil && afterAddObjectCounter < 1 {
		if m.AddObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddObject at\n%s", m.AddObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddObject at\n%s with params: %#v", m.AddObjectMock.defaultExpectation.expectationOrigins.origin, *m.AddObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddObject != nil && afterAddObjectCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddObject at\n%s", m.funcAddObjectOrigin)
	}

	if !m.AddObjectMock.invocationsDone() && afterAddObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddObjectMock.expectedInvocations), m.AddObjectMock.expectedInvocationsOrigin, afterAddObjectCounter)
	}
}

type mEncoderMockAddReflected struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddReflectedExpectation
	expectations       []*EncoderMockAddReflectedExpectation

	callArgs []*EncoderMockAddReflectedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddReflectedExpectation specifies expectation struct of the Encoder.AddReflected
type EncoderMockAddReflectedExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddReflectedParams
	paramPtrs          *EncoderMockAddReflectedParamPtrs
	expectationOrigins EncoderMockAddReflectedExpectationOrigins
	results            *EncoderMockAddReflectedResults
	returnOrigin       string
	Counter            uint64
}

// EncoderMockAddReflectedParams contains parameters of the Encoder.AddReflected
type EncoderMockAddReflectedParams struct {
	key   string
	value interface{}
}

// EncoderMockAddReflectedParamPtrs contains pointers to parameters of the Encoder.AddReflected
type EncoderMockAddReflectedParamPtrs struct {
	key   *string
	value *interface{}
}

// EncoderMockAddReflectedResults contains results of the Encoder.AddReflected
type EncoderMockAddReflectedResults struct {
	err error
}

// EncoderMockAddReflectedOrigins contains origins of expectations of the Encoder.AddReflected
type EncoderMockAddReflectedExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReflected *mEncoderMockAddReflected) Optional() *mEncoderMockAddReflected {
	mmAddReflected.optional = true
	return mmAddReflected
}

// Expect sets up expected params for Encoder.AddReflected
func (mmAddReflected *mEncoderMockAddReflected) Expect(key string, value interface{}) *mEncoderMockAddReflected {
	if mmAddReflected.mock.funcAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Set")
	}

	if mmAddReflected.defaultExpectation == nil {
		mmAddReflected.defaultExpectation = &EncoderMockAddReflectedExpectation{}
	}

	if mmAddReflected.defaultExpectation.paramPtrs != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by ExpectParams functions")
	}

	mmAddReflected.defaultExpectation.params = &EncoderMockAddReflectedParams{key, value}
	mmAddReflected.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddReflected.expectations {
		if minimock.Equal(e.params, mmAddReflected.defaultExpectation.params) {
			mmAddReflected.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReflected.defaultExpectation.params)
		}
	}

	return mmAddReflected
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddReflected
func (mmAddReflected *mEncoderMockAddReflected) ExpectKeyParam1(key string) *mEncoderMockAddReflected {
	if mmAddReflected.mock.funcAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Set")
	}

	if mmAddReflected.defaultExpectation == nil {
		mmAddReflected.defaultExpectation = &EncoderMockAddReflectedExpectation{}
	}

	if mmAddReflected.defaultExpectation.params != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Expect")
	}

	if mmAddReflected.defaultExpectation.paramPtrs == nil {
		mmAddReflected.defaultExpectation.paramPtrs = &EncoderMockAddReflectedParamPtrs{}
	}
	mmAddReflected.defaultExpectation.paramPtrs.key = &key
	mmAddReflected.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddReflected
}

// ExpectValueParam2 sets up expected param value for Encoder.AddReflected
func (mmAddReflected *mEncoderMockAddReflected) ExpectValueParam2(value interface{}) *mEncoderMockAddReflected {
	if mmAddReflected.mock.funcAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Set")
	}

	if mmAddReflected.defaultExpectation == nil {
		mmAddReflected.defaultExpectation = &EncoderMockAddReflectedExpectation{}
	}

	if mmAddReflected.defaultExpectation.params != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Expect")
	}

	if mmAddReflected.defaultExpectation.paramPtrs == nil {
		mmAddReflected.defaultExpectation.paramPtrs = &EncoderMockAddReflectedParamPtrs{}
	}
	mmAddReflected.defaultExpectation.paramPtrs.value = &value
	mmAddReflected.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddReflected
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddReflected
func (mmAddReflected *mEncoderMockAddReflected) Inspect(f func(key string, value interface{})) *mEncoderMockAddReflected {
	if mmAddReflected.mock.inspectFuncAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddReflected")
	}

	mmAddReflected.mock.inspectFuncAddReflected = f

	return mmAddReflected
}

// Return sets up results that will be returned by Encoder.AddReflected
func (mmAddReflected *mEncoderMockAddReflected) Return(err error) *EncoderMock {
	if mmAddReflected.mock.funcAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Set")
	}

	if mmAddReflected.defaultExpectation == nil {
		mmAddReflected.defaultExpectation = &EncoderMockAddReflectedExpectation{mock: mmAddReflected.mock}
	}
	mmAddReflected.defaultExpectation.results = &EncoderMockAddReflectedResults{err}
	mmAddReflected.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddReflected.mock
}

// Set uses given function f to mock the Encoder.AddReflected method
func (mmAddReflected *mEncoderMockAddReflected) Set(f func(key string, value interface{}) (err error)) *EncoderMock {
	if mmAddReflected.defaultExpectation != nil {
		mmAddReflected.mock.t.Fatalf("Default expectation is already set for the Encoder.AddReflected method")
	}

	if len(mmAddReflected.expectations) > 0 {
		mmAddReflected.mock.t.Fatalf("Some expectations are already set for the Encoder.AddReflected method")
	}

	mmAddReflected.mock.funcAddReflected = f
	mmAddReflected.mock.funcAddReflectedOrigin = minimock.CallerInfo(1)
	return mmAddReflected.mock
}

// When sets expectation for the Encoder.AddReflected which will trigger the result defined by the following
// Then helper
func (mmAddReflected *mEncoderMockAddReflected) When(key string, value interface{}) *EncoderMockAddReflectedExpectation {
	if mmAddReflected.mock.funcAddReflected != nil {
		mmAddReflected.mock.t.Fatalf("EncoderMock.AddReflected mock is already set by Set")
	}

	expectation := &EncoderMockAddReflectedExpectation{
		mock:               mmAddReflected.mock,
		params:             &EncoderMockAddReflectedParams{key, value},
		expectationOrigins: EncoderMockAddReflectedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddReflected.expectations = append(mmAddReflected.expectations, expectation)
	return expectation
}

// Then sets up Encoder.AddReflected return parameters for the expectation previously defined by the When method
func (e *EncoderMockAddReflectedExpectation) Then(err error) *EncoderMock {
	e.results = &EncoderMockAddReflectedResults{err}
	return e.mock
}

// Times sets number of times Encoder.AddReflected should be invoked
func (mmAddReflected *mEncoderMockAddReflected) Times(n uint64) *mEncoderMockAddReflected {
	if n == 0 {
		mmAddReflected.mock.t.Fatalf("Times of EncoderMock.AddReflected mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReflected.expectedInvocations, n)
	mmAddReflected.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddReflected
}

func (mmAddReflected *mEncoderMockAddReflected) invocationsDone() bool {
	if len(mmAddReflected.expectations) == 0 && mmAddReflected.defaultExpectation == nil && mmAddReflected.mock.funcAddReflected == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReflected.mock.afterAddReflectedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReflected.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReflected implements Encoder
func (mmAddReflected *EncoderMock) AddReflected(key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmAddReflected.beforeAddReflectedCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReflected.afterAddReflectedCounter, 1)

	mmAddReflected.t.Helper()

	if mmAddReflected.inspectFuncAddReflected != nil {
		mmAddReflected.inspectFuncAddReflected(key, value)
	}

	mm_params := EncoderMockAddReflectedParams{key, value}

	// Record call args
	mmAddReflected.AddReflectedMock.mutex.Lock()
	mmAddReflected.AddReflectedMock.callArgs = append(mmAddReflected.AddReflectedMock.callArgs, &mm_params)
	mmAddReflected.AddReflectedMock.mutex.Unlock()

	for _, e := range mmAddReflected.AddReflectedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReflected.AddReflectedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReflected.AddReflectedMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReflected.AddReflectedMock.defaultExpectation.params
		mm_want_ptrs := mmAddReflected.AddReflectedMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddReflectedParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddReflected.t.Errorf("EncoderMock.AddReflected got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReflected.AddReflectedMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddReflected.t.Errorf("EncoderMock.AddReflected got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReflected.AddReflectedMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReflected.t.Errorf("EncoderMock.AddReflected got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddReflected.AddReflectedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReflected.AddReflectedMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReflected.t.Fatal("No results are set for the EncoderMock.AddReflected")
		}
		return (*mm_results).err
	}
	if mmAddReflected.funcAddReflected != nil {
		return mmAddReflected.funcAddReflected(key, value)
	}
	mmAddReflected.t.Fatalf("Unexpected call to EncoderMock.AddReflected. %v %v", key, value)
	return
}

// AddReflectedAfterCounter returns a count of finished EncoderMock.AddReflected invocations
func (mmAddReflected *EncoderMock) AddReflectedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReflected.afterAddReflectedCounter)
}

// AddReflectedBeforeCounter returns a count of EncoderMock.AddReflected invocations
func (mmAddReflected *EncoderMock) AddReflectedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReflected.beforeAddReflectedCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddReflected.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReflected *mEncoderMockAddReflected) Calls() []*EncoderMockAddReflectedParams {
	mmAddReflected.mutex.RLock()

	argCopy := make([]*EncoderMockAddReflectedParams, len(mmAddReflected.callArgs))
	copy(argCopy, mmAddReflected.callArgs)

	mmAddReflected.mutex.RUnlock()

	return argCopy
}

// MinimockAddReflectedDone returns true if the count of the AddReflected invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddReflectedDone() bool {
	if m.AddReflectedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReflectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReflectedMock.invocationsDone()
}

// MinimockAddReflectedInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddReflectedInspect() {
	for _, e := range m.AddReflectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddReflected at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddReflectedCounter := mm_atomic.LoadUint64(&m.afterAddReflectedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReflectedMock.defaultExpectation != nil && afterAddReflectedCounter < 1 {
		if m.AddReflectedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddReflected at\n%s", m.AddReflectedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddReflected at\n%s with params: %#v", m.AddReflectedMock.defaultExpectation.expectationOrigins.origin, *m.AddReflectedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReflected != nil && afterAddReflectedCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddReflected at\n%s", m.funcAddReflectedOrigin)
	}

	if !m.AddReflectedMock.invocationsDone() && afterAddReflectedCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddReflected at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddReflectedMock.expectedInvocations), m.AddReflectedMock.expectedInvocationsOrigin, afterAddReflectedCounter)
	}
}

type mEncoderMockAddString struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddStringExpectation
	expectations       []*EncoderMockAddStringExpectation

	callArgs []*EncoderMockAddStringParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddStringExpectation specifies expectation struct of the Encoder.AddString
type EncoderMockAddStringExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddStringParams
	paramPtrs          *EncoderMockAddStringParamPtrs
	expectationOrigins EncoderMockAddStringExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddStringParams contains parameters of the Encoder.AddString
type EncoderMockAddStringParams struct {
	key   string
	value string
}

// EncoderMockAddStringParamPtrs contains pointers to parameters of the Encoder.AddString
type EncoderMockAddStringParamPtrs struct {
	key   *string
	value *string
}

// EncoderMockAddStringOrigins contains origins of expectations of the Encoder.AddString
type EncoderMockAddStringExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddString *mEncoderMockAddString) Optional() *mEncoderMockAddString {
	mmAddString.optional = true
	return mmAddString
}

// Expect sets up expected params for Encoder.AddString
func (mmAddString *mEncoderMockAddString) Expect(key string, value string) *mEncoderMockAddString {
	if mmAddString.mock.funcAddString != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Set")
	}

	if mmAddString.defaultExpectation == nil {
		mmAddString.defaultExpectation = &EncoderMockAddStringExpectation{}
	}

	if mmAddString.defaultExpectation.paramPtrs != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by ExpectParams functions")
	}

	mmAddString.defaultExpectation.params = &EncoderMockAddStringParams{key, value}
	mmAddString.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddString.expectations {
		if minimock.Equal(e.params, mmAddString.defaultExpectation.params) {
			mmAddString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddString.defaultExpectation.params)
		}
	}

	return mmAddString
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddString
func (mmAddString *mEncoderMockAddString) ExpectKeyParam1(key string) *mEncoderMockAddString {
	if mmAddString.mock.funcAddString != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Set")
	}

	if mmAddString.defaultExpectation == nil {
		mmAddString.defaultExpectation = &EncoderMockAddStringExpectation{}
	}

	if mmAddString.defaultExpectation.params != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Expect")
	}

	if mmAddString.defaultExpectation.paramPtrs == nil {
		mmAddString.defaultExpectation.paramPtrs = &EncoderMockAddStringParamPtrs{}
	}
	mmAddString.defaultExpectation.paramPtrs.key = &key
	mmAddString.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddString
}

// ExpectValueParam2 sets up expected param value for Encoder.AddString
func (mmAddString *mEncoderMockAddString) ExpectValueParam2(value string) *mEncoderMockAddString {
	if mmAddString.mock.funcAddString != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Set")
	}

	if mmAddString.defaultExpectation == nil {
		mmAddString.defaultExpectation = &EncoderMockAddStringExpectation{}
	}

	if mmAddString.defaultExpectation.params != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Expect")
	}

	if mmAddString.defaultExpectation.paramPtrs == nil {
		mmAddString.defaultExpectation.paramPtrs = &EncoderMockAddStringParamPtrs{}
	}
	mmAddString.defaultExpectation.paramPtrs.value = &value
	mmAddString.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddString
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddString
func (mmAddString *mEncoderMockAddString) Inspect(f func(key string, value string)) *mEncoderMockAddString {
	if mmAddString.mock.inspectFuncAddString != nil {
		mmAddString.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddString")
	}

	mmAddString.mock.inspectFuncAddString = f

	return mmAddString
}

// Return sets up results that will be returned by Encoder.AddString
func (mmAddString *mEncoderMockAddString) Return() *EncoderMock {
	if mmAddString.mock.funcAddString != nil {
		mmAddString.mock.t.Fatalf("EncoderMock.AddString mock is already set by Set")
	}

	if mmAddString.defaultExpectation == nil {
		mmAddString.defaultExpectation = &EncoderMockAddStringExpectation{mock: mmAddString.mock}
	}

	mmAddString.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddString.mock
}

// Set uses given function f to mock the Encoder.AddString method
func (mmAddString *mEncoderMockAddString) Set(f func(key string, value string)) *EncoderMock {
	if mmAddString.defaultExpectation != nil {
		mmAddString.mock.t.Fatalf("Default expectation is already set for the Encoder.AddString method")
	}

	if len(mmAddString.expectations) > 0 {
		mmAddString.mock.t.Fatalf("Some expectations are already set for the Encoder.AddString method")
	}

	mmAddString.mock.funcAddString = f
	mmAddString.mock.funcAddStringOrigin = minimock.CallerInfo(1)
	return mmAddString.mock
}

// Times sets number of times Encoder.AddString should be invoked
func (mmAddString *mEncoderMockAddString) Times(n uint64) *mEncoderMockAddString {
	if n == 0 {
		mmAddString.mock.t.Fatalf("Times of EncoderMock.AddString mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddString.expectedInvocations, n)
	mmAddString.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddString
}

func (mmAddString *mEncoderMockAddString) invocationsDone() bool {
	if len(mmAddString.expectations) == 0 && mmAddString.defaultExpectation == nil && mmAddString.mock.funcAddString == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddString.mock.afterAddStringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddString.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddString implements Encoder
func (mmAddString *EncoderMock) AddString(key string, value string) {
	mm_atomic.AddUint64(&mmAddString.beforeAddStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAddString.afterAddStringCounter, 1)

	mmAddString.t.Helper()

	if mmAddString.inspectFuncAddString != nil {
		mmAddString.inspectFuncAddString(key, value)
	}

	mm_params := EncoderMockAddStringParams{key, value}

	// Record call args
	mmAddString.AddStringMock.mutex.Lock()
	mmAddString.AddStringMock.callArgs = append(mmAddString.AddStringMock.callArgs, &mm_params)
	mmAddString.AddStringMock.mutex.Unlock()

	for _, e := range mmAddString.AddStringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddString.AddStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddString.AddStringMock.defaultExpectation.Counter, 1)
		mm_want := mmAddString.AddStringMock.defaultExpectation.params
		mm_want_ptrs := mmAddString.AddStringMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddStringParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddString.t.Errorf("EncoderMock.AddString got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddString.AddStringMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddString.t.Errorf("EncoderMock.AddString got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddString.AddStringMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddString.t.Errorf("EncoderMock.AddString got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddString.AddStringMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddString.funcAddString != nil {
		mmAddString.funcAddString(key, value)
		return
	}
	mmAddString.t.Fatalf("Unexpected call to EncoderMock.AddString. %v %v", key, value)

}

// AddStringAfterCounter returns a count of finished EncoderMock.AddString invocations
func (mmAddString *EncoderMock) AddStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddString.afterAddStringCounter)
}

// AddStringBeforeCounter returns a count of EncoderMock.AddString invocations
func (mmAddString *EncoderMock) AddStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddString.beforeAddStringCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddString *mEncoderMockAddString) Calls() []*EncoderMockAddStringParams {
	mmAddString.mutex.RLock()

	argCopy := make([]*EncoderMockAddStringParams, len(mmAddString.callArgs))
	copy(argCopy, mmAddString.callArgs)

	mmAddString.mutex.RUnlock()

	return argCopy
}

// MinimockAddStringDone returns true if the count of the AddString invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddStringDone() bool {
	if m.AddStringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddStringMock.invocationsDone()
}

// MinimockAddStringInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddStringInspect() {
	for _, e := range m.AddStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddString at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddStringCounter := mm_atomic.LoadUint64(&m.afterAddStringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddStringMock.defaultExpectation != nil && afterAddStringCounter < 1 {
		if m.AddStringMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddString at\n%s", m.AddStringMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddString at\n%s with params: %#v", m.AddStringMock.defaultExpectation.expectationOrigins.origin, *m.AddStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddString != nil && afterAddStringCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddString at\n%s", m.funcAddStringOrigin)
	}

	if !m.AddStringMock.invocationsDone() && afterAddStringCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddString at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddStringMock.expectedInvocations), m.AddStringMock.expectedInvocationsOrigin, afterAddStringCounter)
	}
}

type mEncoderMockAddTime struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddTimeExpectation
	expectations       []*EncoderMockAddTimeExpectation

	callArgs []*EncoderMockAddTimeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddTimeExpectation specifies expectation struct of the Encoder.AddTime
type EncoderMockAddTimeExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddTimeParams
	paramPtrs          *EncoderMockAddTimeParamPtrs
	expectationOrigins EncoderMockAddTimeExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddTimeParams contains parameters of the Encoder.AddTime
type EncoderMockAddTimeParams struct {
	key   string
	value time.Time
}

// EncoderMockAddTimeParamPtrs contains pointers to parameters of the Encoder.AddTime
type EncoderMockAddTimeParamPtrs struct {
	key   *string
	value *time.Time
}

// EncoderMockAddTimeOrigins contains origins of expectations of the Encoder.AddTime
type EncoderMockAddTimeExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddTime *mEncoderMockAddTime) Optional() *mEncoderMockAddTime {
	mmAddTime.optional = true
	return mmAddTime
}

// Expect sets up expected params for Encoder.AddTime
func (mmAddTime *mEncoderMockAddTime) Expect(key string, value time.Time) *mEncoderMockAddTime {
	if mmAddTime.mock.funcAddTime != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Set")
	}

	if mmAddTime.defaultExpectation == nil {
		mmAddTime.defaultExpectation = &EncoderMockAddTimeExpectation{}
	}

	if mmAddTime.defaultExpectation.paramPtrs != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by ExpectParams functions")
	}

	mmAddTime.defaultExpectation.params = &EncoderMockAddTimeParams{key, value}
	mmAddTime.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddTime.expectations {
		if minimock.Equal(e.params, mmAddTime.defaultExpectation.params) {
			mmAddTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTime.defaultExpectation.params)
		}
	}

	return mmAddTime
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddTime
func (mmAddTime *mEncoderMockAddTime) ExpectKeyParam1(key string) *mEncoderMockAddTime {
	if mmAddTime.mock.funcAddTime != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Set")
	}

	if mmAddTime.defaultExpectation == nil {
		mmAddTime.defaultExpectation = &EncoderMockAddTimeExpectation{}
	}

	if mmAddTime.defaultExpectation.params != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Expect")
	}

	if mmAddTime.defaultExpectation.paramPtrs == nil {
		mmAddTime.defaultExpectation.paramPtrs = &EncoderMockAddTimeParamPtrs{}
	}
	mmAddTime.defaultExpectation.paramPtrs.key = &key
	mmAddTime.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddTime
}

// ExpectValueParam2 sets up expected param value for Encoder.AddTime
func (mmAddTime *mEncoderMockAddTime) ExpectValueParam2(value time.Time) *mEncoderMockAddTime {
	if mmAddTime.mock.funcAddTime != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Set")
	}

	if mmAddTime.defaultExpectation == nil {
		mmAddTime.defaultExpectation = &EncoderMockAddTimeExpectation{}
	}

	if mmAddTime.defaultExpectation.params != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Expect")
	}

	if mmAddTime.defaultExpectation.paramPtrs == nil {
		mmAddTime.defaultExpectation.paramPtrs = &EncoderMockAddTimeParamPtrs{}
	}
	mmAddTime.defaultExpectation.paramPtrs.value = &value
	mmAddTime.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddTime
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddTime
func (mmAddTime *mEncoderMockAddTime) Inspect(f func(key string, value time.Time)) *mEncoderMockAddTime {
	if mmAddTime.mock.inspectFuncAddTime != nil {
		mmAddTime.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddTime")
	}

	mmAddTime.mock.inspectFuncAddTime = f

	return mmAddTime
}

// Return sets up results that will be returned by Encoder.AddTime
func (mmAddTime *mEncoderMockAddTime) Return() *EncoderMock {
	if mmAddTime.mock.funcAddTime != nil {
		mmAddTime.mock.t.Fatalf("EncoderMock.AddTime mock is already set by Set")
	}

	if mmAddTime.defaultExpectation == nil {
		mmAddTime.defaultExpectation = &EncoderMockAddTimeExpectation{mock: mmAddTime.mock}
	}

	mmAddTime.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddTime.mock
}

// Set uses given function f to mock the Encoder.AddTime method
func (mmAddTime *mEncoderMockAddTime) Set(f func(key string, value time.Time)) *EncoderMock {
	if mmAddTime.defaultExpectation != nil {
		mmAddTime.mock.t.Fatalf("Default expectation is already set for the Encoder.AddTime method")
	}

	if len(mmAddTime.expectations) > 0 {
		mmAddTime.mock.t.Fatalf("Some expectations are already set for the Encoder.AddTime method")
	}

	mmAddTime.mock.funcAddTime = f
	mmAddTime.mock.funcAddTimeOrigin = minimock.CallerInfo(1)
	return mmAddTime.mock
}

// Times sets number of times Encoder.AddTime should be invoked
func (mmAddTime *mEncoderMockAddTime) Times(n uint64) *mEncoderMockAddTime {
	if n == 0 {
		mmAddTime.mock.t.Fatalf("Times of EncoderMock.AddTime mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddTime.expectedInvocations, n)
	mmAddTime.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddTime
}

func (mmAddTime *mEncoderMockAddTime) invocationsDone() bool {
	if len(mmAddTime.expectations) == 0 && mmAddTime.defaultExpectation == nil && mmAddTime.mock.funcAddTime == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddTime.mock.afterAddTimeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddTime.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddTime implements Encoder
func (mmAddTime *EncoderMock) AddTime(key string, value time.Time) {
	mm_atomic.AddUint64(&mmAddTime.beforeAddTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTime.afterAddTimeCounter, 1)

	mmAddTime.t.Helper()

	if mmAddTime.inspectFuncAddTime != nil {
		mmAddTime.inspectFuncAddTime(key, value)
	}

	mm_params := EncoderMockAddTimeParams{key, value}

	// Record call args
	mmAddTime.AddTimeMock.mutex.Lock()
	mmAddTime.AddTimeMock.callArgs = append(mmAddTime.AddTimeMock.callArgs, &mm_params)
	mmAddTime.AddTimeMock.mutex.Unlock()

	for _, e := range mmAddTime.AddTimeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddTime.AddTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTime.AddTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTime.AddTimeMock.defaultExpectation.params
		mm_want_ptrs := mmAddTime.AddTimeMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddTimeParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddTime.t.Errorf("EncoderMock.AddTime got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTime.AddTimeMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddTime.t.Errorf("EncoderMock.AddTime got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTime.AddTimeMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTime.t.Errorf("EncoderMock.AddTime got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddTime.AddTimeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddTime.funcAddTime != nil {
		mmAddTime.funcAddTime(key, value)
		return
	}
	mmAddTime.t.Fatalf("Unexpected call to EncoderMock.AddTime. %v %v", key, value)

}

// AddTimeAfterCounter returns a count of finished EncoderMock.AddTime invocations
func (mmAddTime *EncoderMock) AddTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTime.afterAddTimeCounter)
}

// AddTimeBeforeCounter returns a count of EncoderMock.AddTime invocations
func (mmAddTime *EncoderMock) AddTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTime.beforeAddTimeCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTime *mEncoderMockAddTime) Calls() []*EncoderMockAddTimeParams {
	mmAddTime.mutex.RLock()

	argCopy := make([]*EncoderMockAddTimeParams, len(mmAddTime.callArgs))
	copy(argCopy, mmAddTime.callArgs)

	mmAddTime.mutex.RUnlock()

	return argCopy
}

// MinimockAddTimeDone returns true if the count of the AddTime invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddTimeDone() bool {
	if m.AddTimeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddTimeMock.invocationsDone()
}

// MinimockAddTimeInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddTimeInspect() {
	for _, e := range m.AddTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddTime at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddTimeCounter := mm_atomic.LoadUint64(&m.afterAddTimeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddTimeMock.defaultExpectation != nil && afterAddTimeCounter < 1 {
		if m.AddTimeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddTime at\n%s", m.AddTimeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddTime at\n%s with params: %#v", m.AddTimeMock.defaultExpectation.expectationOrigins.origin, *m.AddTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTime != nil && afterAddTimeCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddTime at\n%s", m.funcAddTimeOrigin)
	}

	if !m.AddTimeMock.invocationsDone() && afterAddTimeCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddTime at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddTimeMock.expectedInvocations), m.AddTimeMock.expectedInvocationsOrigin, afterAddTimeCounter)
	}
}

type mEncoderMockAddUint struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUintExpectation
	expectations       []*EncoderMockAddUintExpectation

	callArgs []*EncoderMockAddUintParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUintExpectation specifies expectation struct of the Encoder.AddUint
type EncoderMockAddUintExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUintParams
	paramPtrs          *EncoderMockAddUintParamPtrs
	expectationOrigins EncoderMockAddUintExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUintParams contains parameters of the Encoder.AddUint
type EncoderMockAddUintParams struct {
	key   string
	value uint
}

// EncoderMockAddUintParamPtrs contains pointers to parameters of the Encoder.AddUint
type EncoderMockAddUintParamPtrs struct {
	key   *string
	value *uint
}

// EncoderMockAddUintOrigins contains origins of expectations of the Encoder.AddUint
type EncoderMockAddUintExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUint *mEncoderMockAddUint) Optional() *mEncoderMockAddUint {
	mmAddUint.optional = true
	return mmAddUint
}

// Expect sets up expected params for Encoder.AddUint
func (mmAddUint *mEncoderMockAddUint) Expect(key string, value uint) *mEncoderMockAddUint {
	if mmAddUint.mock.funcAddUint != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Set")
	}

	if mmAddUint.defaultExpectation == nil {
		mmAddUint.defaultExpectation = &EncoderMockAddUintExpectation{}
	}

	if mmAddUint.defaultExpectation.paramPtrs != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by ExpectParams functions")
	}

	mmAddUint.defaultExpectation.params = &EncoderMockAddUintParams{key, value}
	mmAddUint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUint.expectations {
		if minimock.Equal(e.params, mmAddUint.defaultExpectation.params) {
			mmAddUint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUint.defaultExpectation.params)
		}
	}

	return mmAddUint
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUint
func (mmAddUint *mEncoderMockAddUint) ExpectKeyParam1(key string) *mEncoderMockAddUint {
	if mmAddUint.mock.funcAddUint != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Set")
	}

	if mmAddUint.defaultExpectation == nil {
		mmAddUint.defaultExpectation = &EncoderMockAddUintExpectation{}
	}

	if mmAddUint.defaultExpectation.params != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Expect")
	}

	if mmAddUint.defaultExpectation.paramPtrs == nil {
		mmAddUint.defaultExpectation.paramPtrs = &EncoderMockAddUintParamPtrs{}
	}
	mmAddUint.defaultExpectation.paramPtrs.key = &key
	mmAddUint.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUint
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUint
func (mmAddUint *mEncoderMockAddUint) ExpectValueParam2(value uint) *mEncoderMockAddUint {
	if mmAddUint.mock.funcAddUint != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Set")
	}

	if mmAddUint.defaultExpectation == nil {
		mmAddUint.defaultExpectation = &EncoderMockAddUintExpectation{}
	}

	if mmAddUint.defaultExpectation.params != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Expect")
	}

	if mmAddUint.defaultExpectation.paramPtrs == nil {
		mmAddUint.defaultExpectation.paramPtrs = &EncoderMockAddUintParamPtrs{}
	}
	mmAddUint.defaultExpectation.paramPtrs.value = &value
	mmAddUint.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUint
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUint
func (mmAddUint *mEncoderMockAddUint) Inspect(f func(key string, value uint)) *mEncoderMockAddUint {
	if mmAddUint.mock.inspectFuncAddUint != nil {
		mmAddUint.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUint")
	}

	mmAddUint.mock.inspectFuncAddUint = f

	return mmAddUint
}

// Return sets up results that will be returned by Encoder.AddUint
func (mmAddUint *mEncoderMockAddUint) Return() *EncoderMock {
	if mmAddUint.mock.funcAddUint != nil {
		mmAddUint.mock.t.Fatalf("EncoderMock.AddUint mock is already set by Set")
	}

	if mmAddUint.defaultExpectation == nil {
		mmAddUint.defaultExpectation = &EncoderMockAddUintExpectation{mock: mmAddUint.mock}
	}

	mmAddUint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUint.mock
}

// Set uses given function f to mock the Encoder.AddUint method
func (mmAddUint *mEncoderMockAddUint) Set(f func(key string, value uint)) *EncoderMock {
	if mmAddUint.defaultExpectation != nil {
		mmAddUint.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUint method")
	}

	if len(mmAddUint.expectations) > 0 {
		mmAddUint.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUint method")
	}

	mmAddUint.mock.funcAddUint = f
	mmAddUint.mock.funcAddUintOrigin = minimock.CallerInfo(1)
	return mmAddUint.mock
}

// Times sets number of times Encoder.AddUint should be invoked
func (mmAddUint *mEncoderMockAddUint) Times(n uint64) *mEncoderMockAddUint {
	if n == 0 {
		mmAddUint.mock.t.Fatalf("Times of EncoderMock.AddUint mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUint.expectedInvocations, n)
	mmAddUint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUint
}

func (mmAddUint *mEncoderMockAddUint) invocationsDone() bool {
	if len(mmAddUint.expectations) == 0 && mmAddUint.defaultExpectation == nil && mmAddUint.mock.funcAddUint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUint.mock.afterAddUintCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUint implements Encoder
func (mmAddUint *EncoderMock) AddUint(key string, value uint) {
	mm_atomic.AddUint64(&mmAddUint.beforeAddUintCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUint.afterAddUintCounter, 1)

	mmAddUint.t.Helper()

	if mmAddUint.inspectFuncAddUint != nil {
		mmAddUint.inspectFuncAddUint(key, value)
	}

	mm_params := EncoderMockAddUintParams{key, value}

	// Record call args
	mmAddUint.AddUintMock.mutex.Lock()
	mmAddUint.AddUintMock.callArgs = append(mmAddUint.AddUintMock.callArgs, &mm_params)
	mmAddUint.AddUintMock.mutex.Unlock()

	for _, e := range mmAddUint.AddUintMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUint.AddUintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUint.AddUintMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUint.AddUintMock.defaultExpectation.params
		mm_want_ptrs := mmAddUint.AddUintMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUintParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUint.t.Errorf("EncoderMock.AddUint got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint.AddUintMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUint.t.Errorf("EncoderMock.AddUint got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint.AddUintMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUint.t.Errorf("EncoderMock.AddUint got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUint.AddUintMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUint.funcAddUint != nil {
		mmAddUint.funcAddUint(key, value)
		return
	}
	mmAddUint.t.Fatalf("Unexpected call to EncoderMock.AddUint. %v %v", key, value)

}

// AddUintAfterCounter returns a count of finished EncoderMock.AddUint invocations
func (mmAddUint *EncoderMock) AddUintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint.afterAddUintCounter)
}

// AddUintBeforeCounter returns a count of EncoderMock.AddUint invocations
func (mmAddUint *EncoderMock) AddUintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint.beforeAddUintCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUint *mEncoderMockAddUint) Calls() []*EncoderMockAddUintParams {
	mmAddUint.mutex.RLock()

	argCopy := make([]*EncoderMockAddUintParams, len(mmAddUint.callArgs))
	copy(argCopy, mmAddUint.callArgs)

	mmAddUint.mutex.RUnlock()

	return argCopy
}

// MinimockAddUintDone returns true if the count of the AddUint invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUintDone() bool {
	if m.AddUintMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUintMock.invocationsDone()
}

// MinimockAddUintInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUintInspect() {
	for _, e := range m.AddUintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUint at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUintCounter := mm_atomic.LoadUint64(&m.afterAddUintCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUintMock.defaultExpectation != nil && afterAddUintCounter < 1 {
		if m.AddUintMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUint at\n%s", m.AddUintMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUint at\n%s with params: %#v", m.AddUintMock.defaultExpectation.expectationOrigins.origin, *m.AddUintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUint != nil && afterAddUintCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUint at\n%s", m.funcAddUintOrigin)
	}

	if !m.AddUintMock.invocationsDone() && afterAddUintCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUint at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUintMock.expectedInvocations), m.AddUintMock.expectedInvocationsOrigin, afterAddUintCounter)
	}
}

type mEncoderMockAddUint16 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUint16Expectation
	expectations       []*EncoderMockAddUint16Expectation

	callArgs []*EncoderMockAddUint16Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUint16Expectation specifies expectation struct of the Encoder.AddUint16
type EncoderMockAddUint16Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUint16Params
	paramPtrs          *EncoderMockAddUint16ParamPtrs
	expectationOrigins EncoderMockAddUint16ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUint16Params contains parameters of the Encoder.AddUint16
type EncoderMockAddUint16Params struct {
	key   string
	value uint16
}

// EncoderMockAddUint16ParamPtrs contains pointers to parameters of the Encoder.AddUint16
type EncoderMockAddUint16ParamPtrs struct {
	key   *string
	value *uint16
}

// EncoderMockAddUint16Origins contains origins of expectations of the Encoder.AddUint16
type EncoderMockAddUint16ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUint16 *mEncoderMockAddUint16) Optional() *mEncoderMockAddUint16 {
	mmAddUint16.optional = true
	return mmAddUint16
}

// Expect sets up expected params for Encoder.AddUint16
func (mmAddUint16 *mEncoderMockAddUint16) Expect(key string, value uint16) *mEncoderMockAddUint16 {
	if mmAddUint16.mock.funcAddUint16 != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Set")
	}

	if mmAddUint16.defaultExpectation == nil {
		mmAddUint16.defaultExpectation = &EncoderMockAddUint16Expectation{}
	}

	if mmAddUint16.defaultExpectation.paramPtrs != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by ExpectParams functions")
	}

	mmAddUint16.defaultExpectation.params = &EncoderMockAddUint16Params{key, value}
	mmAddUint16.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUint16.expectations {
		if minimock.Equal(e.params, mmAddUint16.defaultExpectation.params) {
			mmAddUint16.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUint16.defaultExpectation.params)
		}
	}

	return mmAddUint16
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUint16
func (mmAddUint16 *mEncoderMockAddUint16) ExpectKeyParam1(key string) *mEncoderMockAddUint16 {
	if mmAddUint16.mock.funcAddUint16 != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Set")
	}

	if mmAddUint16.defaultExpectation == nil {
		mmAddUint16.defaultExpectation = &EncoderMockAddUint16Expectation{}
	}

	if mmAddUint16.defaultExpectation.params != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Expect")
	}

	if mmAddUint16.defaultExpectation.paramPtrs == nil {
		mmAddUint16.defaultExpectation.paramPtrs = &EncoderMockAddUint16ParamPtrs{}
	}
	mmAddUint16.defaultExpectation.paramPtrs.key = &key
	mmAddUint16.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUint16
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUint16
func (mmAddUint16 *mEncoderMockAddUint16) ExpectValueParam2(value uint16) *mEncoderMockAddUint16 {
	if mmAddUint16.mock.funcAddUint16 != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Set")
	}

	if mmAddUint16.defaultExpectation == nil {
		mmAddUint16.defaultExpectation = &EncoderMockAddUint16Expectation{}
	}

	if mmAddUint16.defaultExpectation.params != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Expect")
	}

	if mmAddUint16.defaultExpectation.paramPtrs == nil {
		mmAddUint16.defaultExpectation.paramPtrs = &EncoderMockAddUint16ParamPtrs{}
	}
	mmAddUint16.defaultExpectation.paramPtrs.value = &value
	mmAddUint16.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUint16
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUint16
func (mmAddUint16 *mEncoderMockAddUint16) Inspect(f func(key string, value uint16)) *mEncoderMockAddUint16 {
	if mmAddUint16.mock.inspectFuncAddUint16 != nil {
		mmAddUint16.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUint16")
	}

	mmAddUint16.mock.inspectFuncAddUint16 = f

	return mmAddUint16
}

// Return sets up results that will be returned by Encoder.AddUint16
func (mmAddUint16 *mEncoderMockAddUint16) Return() *EncoderMock {
	if mmAddUint16.mock.funcAddUint16 != nil {
		mmAddUint16.mock.t.Fatalf("EncoderMock.AddUint16 mock is already set by Set")
	}

	if mmAddUint16.defaultExpectation == nil {
		mmAddUint16.defaultExpectation = &EncoderMockAddUint16Expectation{mock: mmAddUint16.mock}
	}

	mmAddUint16.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUint16.mock
}

// Set uses given function f to mock the Encoder.AddUint16 method
func (mmAddUint16 *mEncoderMockAddUint16) Set(f func(key string, value uint16)) *EncoderMock {
	if mmAddUint16.defaultExpectation != nil {
		mmAddUint16.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUint16 method")
	}

	if len(mmAddUint16.expectations) > 0 {
		mmAddUint16.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUint16 method")
	}

	mmAddUint16.mock.funcAddUint16 = f
	mmAddUint16.mock.funcAddUint16Origin = minimock.CallerInfo(1)
	return mmAddUint16.mock
}

// Times sets number of times Encoder.AddUint16 should be invoked
func (mmAddUint16 *mEncoderMockAddUint16) Times(n uint64) *mEncoderMockAddUint16 {
	if n == 0 {
		mmAddUint16.mock.t.Fatalf("Times of EncoderMock.AddUint16 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUint16.expectedInvocations, n)
	mmAddUint16.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUint16
}

func (mmAddUint16 *mEncoderMockAddUint16) invocationsDone() bool {
	if len(mmAddUint16.expectations) == 0 && mmAddUint16.defaultExpectation == nil && mmAddUint16.mock.funcAddUint16 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUint16.mock.afterAddUint16Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUint16.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUint16 implements Encoder
func (mmAddUint16 *EncoderMock) AddUint16(key string, value uint16) {
	mm_atomic.AddUint64(&mmAddUint16.beforeAddUint16Counter, 1)
	defer mm_atomic.AddUint64(&mmAddUint16.afterAddUint16Counter, 1)

	mmAddUint16.t.Helper()

	if mmAddUint16.inspectFuncAddUint16 != nil {
		mmAddUint16.inspectFuncAddUint16(key, value)
	}

	mm_params := EncoderMockAddUint16Params{key, value}

	// Record call args
	mmAddUint16.AddUint16Mock.mutex.Lock()
	mmAddUint16.AddUint16Mock.callArgs = append(mmAddUint16.AddUint16Mock.callArgs, &mm_params)
	mmAddUint16.AddUint16Mock.mutex.Unlock()

	for _, e := range mmAddUint16.AddUint16Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUint16.AddUint16Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUint16.AddUint16Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddUint16.AddUint16Mock.defaultExpectation.params
		mm_want_ptrs := mmAddUint16.AddUint16Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUint16Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUint16.t.Errorf("EncoderMock.AddUint16 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint16.AddUint16Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUint16.t.Errorf("EncoderMock.AddUint16 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint16.AddUint16Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUint16.t.Errorf("EncoderMock.AddUint16 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUint16.AddUint16Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUint16.funcAddUint16 != nil {
		mmAddUint16.funcAddUint16(key, value)
		return
	}
	mmAddUint16.t.Fatalf("Unexpected call to EncoderMock.AddUint16. %v %v", key, value)

}

// AddUint16AfterCounter returns a count of finished EncoderMock.AddUint16 invocations
func (mmAddUint16 *EncoderMock) AddUint16AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint16.afterAddUint16Counter)
}

// AddUint16BeforeCounter returns a count of EncoderMock.AddUint16 invocations
func (mmAddUint16 *EncoderMock) AddUint16BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint16.beforeAddUint16Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUint16.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUint16 *mEncoderMockAddUint16) Calls() []*EncoderMockAddUint16Params {
	mmAddUint16.mutex.RLock()

	argCopy := make([]*EncoderMockAddUint16Params, len(mmAddUint16.callArgs))
	copy(argCopy, mmAddUint16.callArgs)

	mmAddUint16.mutex.RUnlock()

	return argCopy
}

// MinimockAddUint16Done returns true if the count of the AddUint16 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUint16Done() bool {
	if m.AddUint16Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUint16Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUint16Mock.invocationsDone()
}

// MinimockAddUint16Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUint16Inspect() {
	for _, e := range m.AddUint16Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUint16 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUint16Counter := mm_atomic.LoadUint64(&m.afterAddUint16Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUint16Mock.defaultExpectation != nil && afterAddUint16Counter < 1 {
		if m.AddUint16Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUint16 at\n%s", m.AddUint16Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUint16 at\n%s with params: %#v", m.AddUint16Mock.defaultExpectation.expectationOrigins.origin, *m.AddUint16Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUint16 != nil && afterAddUint16Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUint16 at\n%s", m.funcAddUint16Origin)
	}

	if !m.AddUint16Mock.invocationsDone() && afterAddUint16Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUint16 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUint16Mock.expectedInvocations), m.AddUint16Mock.expectedInvocationsOrigin, afterAddUint16Counter)
	}
}

type mEncoderMockAddUint32 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUint32Expectation
	expectations       []*EncoderMockAddUint32Expectation

	callArgs []*EncoderMockAddUint32Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUint32Expectation specifies expectation struct of the Encoder.AddUint32
type EncoderMockAddUint32Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUint32Params
	paramPtrs          *EncoderMockAddUint32ParamPtrs
	expectationOrigins EncoderMockAddUint32ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUint32Params contains parameters of the Encoder.AddUint32
type EncoderMockAddUint32Params struct {
	key   string
	value uint32
}

// EncoderMockAddUint32ParamPtrs contains pointers to parameters of the Encoder.AddUint32
type EncoderMockAddUint32ParamPtrs struct {
	key   *string
	value *uint32
}

// EncoderMockAddUint32Origins contains origins of expectations of the Encoder.AddUint32
type EncoderMockAddUint32ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUint32 *mEncoderMockAddUint32) Optional() *mEncoderMockAddUint32 {
	mmAddUint32.optional = true
	return mmAddUint32
}

// Expect sets up expected params for Encoder.AddUint32
func (mmAddUint32 *mEncoderMockAddUint32) Expect(key string, value uint32) *mEncoderMockAddUint32 {
	if mmAddUint32.mock.funcAddUint32 != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Set")
	}

	if mmAddUint32.defaultExpectation == nil {
		mmAddUint32.defaultExpectation = &EncoderMockAddUint32Expectation{}
	}

	if mmAddUint32.defaultExpectation.paramPtrs != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by ExpectParams functions")
	}

	mmAddUint32.defaultExpectation.params = &EncoderMockAddUint32Params{key, value}
	mmAddUint32.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUint32.expectations {
		if minimock.Equal(e.params, mmAddUint32.defaultExpectation.params) {
			mmAddUint32.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUint32.defaultExpectation.params)
		}
	}

	return mmAddUint32
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUint32
func (mmAddUint32 *mEncoderMockAddUint32) ExpectKeyParam1(key string) *mEncoderMockAddUint32 {
	if mmAddUint32.mock.funcAddUint32 != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Set")
	}

	if mmAddUint32.defaultExpectation == nil {
		mmAddUint32.defaultExpectation = &EncoderMockAddUint32Expectation{}
	}

	if mmAddUint32.defaultExpectation.params != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Expect")
	}

	if mmAddUint32.defaultExpectation.paramPtrs == nil {
		mmAddUint32.defaultExpectation.paramPtrs = &EncoderMockAddUint32ParamPtrs{}
	}
	mmAddUint32.defaultExpectation.paramPtrs.key = &key
	mmAddUint32.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUint32
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUint32
func (mmAddUint32 *mEncoderMockAddUint32) ExpectValueParam2(value uint32) *mEncoderMockAddUint32 {
	if mmAddUint32.mock.funcAddUint32 != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Set")
	}

	if mmAddUint32.defaultExpectation == nil {
		mmAddUint32.defaultExpectation = &EncoderMockAddUint32Expectation{}
	}

	if mmAddUint32.defaultExpectation.params != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Expect")
	}

	if mmAddUint32.defaultExpectation.paramPtrs == nil {
		mmAddUint32.defaultExpectation.paramPtrs = &EncoderMockAddUint32ParamPtrs{}
	}
	mmAddUint32.defaultExpectation.paramPtrs.value = &value
	mmAddUint32.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUint32
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUint32
func (mmAddUint32 *mEncoderMockAddUint32) Inspect(f func(key string, value uint32)) *mEncoderMockAddUint32 {
	if mmAddUint32.mock.inspectFuncAddUint32 != nil {
		mmAddUint32.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUint32")
	}

	mmAddUint32.mock.inspectFuncAddUint32 = f

	return mmAddUint32
}

// Return sets up results that will be returned by Encoder.AddUint32
func (mmAddUint32 *mEncoderMockAddUint32) Return() *EncoderMock {
	if mmAddUint32.mock.funcAddUint32 != nil {
		mmAddUint32.mock.t.Fatalf("EncoderMock.AddUint32 mock is already set by Set")
	}

	if mmAddUint32.defaultExpectation == nil {
		mmAddUint32.defaultExpectation = &EncoderMockAddUint32Expectation{mock: mmAddUint32.mock}
	}

	mmAddUint32.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUint32.mock
}

// Set uses given function f to mock the Encoder.AddUint32 method
func (mmAddUint32 *mEncoderMockAddUint32) Set(f func(key string, value uint32)) *EncoderMock {
	if mmAddUint32.defaultExpectation != nil {
		mmAddUint32.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUint32 method")
	}

	if len(mmAddUint32.expectations) > 0 {
		mmAddUint32.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUint32 method")
	}

	mmAddUint32.mock.funcAddUint32 = f
	mmAddUint32.mock.funcAddUint32Origin = minimock.CallerInfo(1)
	return mmAddUint32.mock
}

// Times sets number of times Encoder.AddUint32 should be invoked
func (mmAddUint32 *mEncoderMockAddUint32) Times(n uint64) *mEncoderMockAddUint32 {
	if n == 0 {
		mmAddUint32.mock.t.Fatalf("Times of EncoderMock.AddUint32 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUint32.expectedInvocations, n)
	mmAddUint32.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUint32
}

func (mmAddUint32 *mEncoderMockAddUint32) invocationsDone() bool {
	if len(mmAddUint32.expectations) == 0 && mmAddUint32.defaultExpectation == nil && mmAddUint32.mock.funcAddUint32 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUint32.mock.afterAddUint32Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUint32.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUint32 implements Encoder
func (mmAddUint32 *EncoderMock) AddUint32(key string, value uint32) {
	mm_atomic.AddUint64(&mmAddUint32.beforeAddUint32Counter, 1)
	defer mm_atomic.AddUint64(&mmAddUint32.afterAddUint32Counter, 1)

	mmAddUint32.t.Helper()

	if mmAddUint32.inspectFuncAddUint32 != nil {
		mmAddUint32.inspectFuncAddUint32(key, value)
	}

	mm_params := EncoderMockAddUint32Params{key, value}

	// Record call args
	mmAddUint32.AddUint32Mock.mutex.Lock()
	mmAddUint32.AddUint32Mock.callArgs = append(mmAddUint32.AddUint32Mock.callArgs, &mm_params)
	mmAddUint32.AddUint32Mock.mutex.Unlock()

	for _, e := range mmAddUint32.AddUint32Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUint32.AddUint32Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUint32.AddUint32Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddUint32.AddUint32Mock.defaultExpectation.params
		mm_want_ptrs := mmAddUint32.AddUint32Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUint32Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUint32.t.Errorf("EncoderMock.AddUint32 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint32.AddUint32Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUint32.t.Errorf("EncoderMock.AddUint32 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint32.AddUint32Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUint32.t.Errorf("EncoderMock.AddUint32 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUint32.AddUint32Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUint32.funcAddUint32 != nil {
		mmAddUint32.funcAddUint32(key, value)
		return
	}
	mmAddUint32.t.Fatalf("Unexpected call to EncoderMock.AddUint32. %v %v", key, value)

}

// AddUint32AfterCounter returns a count of finished EncoderMock.AddUint32 invocations
func (mmAddUint32 *EncoderMock) AddUint32AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint32.afterAddUint32Counter)
}

// AddUint32BeforeCounter returns a count of EncoderMock.AddUint32 invocations
func (mmAddUint32 *EncoderMock) AddUint32BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint32.beforeAddUint32Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUint32.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUint32 *mEncoderMockAddUint32) Calls() []*EncoderMockAddUint32Params {
	mmAddUint32.mutex.RLock()

	argCopy := make([]*EncoderMockAddUint32Params, len(mmAddUint32.callArgs))
	copy(argCopy, mmAddUint32.callArgs)

	mmAddUint32.mutex.RUnlock()

	return argCopy
}

// MinimockAddUint32Done returns true if the count of the AddUint32 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUint32Done() bool {
	if m.AddUint32Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUint32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUint32Mock.invocationsDone()
}

// MinimockAddUint32Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUint32Inspect() {
	for _, e := range m.AddUint32Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUint32 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUint32Counter := mm_atomic.LoadUint64(&m.afterAddUint32Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUint32Mock.defaultExpectation != nil && afterAddUint32Counter < 1 {
		if m.AddUint32Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUint32 at\n%s", m.AddUint32Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUint32 at\n%s with params: %#v", m.AddUint32Mock.defaultExpectation.expectationOrigins.origin, *m.AddUint32Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUint32 != nil && afterAddUint32Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUint32 at\n%s", m.funcAddUint32Origin)
	}

	if !m.AddUint32Mock.invocationsDone() && afterAddUint32Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUint32 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUint32Mock.expectedInvocations), m.AddUint32Mock.expectedInvocationsOrigin, afterAddUint32Counter)
	}
}

type mEncoderMockAddUint64 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUint64Expectation
	expectations       []*EncoderMockAddUint64Expectation

	callArgs []*EncoderMockAddUint64Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUint64Expectation specifies expectation struct of the Encoder.AddUint64
type EncoderMockAddUint64Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUint64Params
	paramPtrs          *EncoderMockAddUint64ParamPtrs
	expectationOrigins EncoderMockAddUint64ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUint64Params contains parameters of the Encoder.AddUint64
type EncoderMockAddUint64Params struct {
	key   string
	value uint64
}

// EncoderMockAddUint64ParamPtrs contains pointers to parameters of the Encoder.AddUint64
type EncoderMockAddUint64ParamPtrs struct {
	key   *string
	value *uint64
}

// EncoderMockAddUint64Origins contains origins of expectations of the Encoder.AddUint64
type EncoderMockAddUint64ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUint64 *mEncoderMockAddUint64) Optional() *mEncoderMockAddUint64 {
	mmAddUint64.optional = true
	return mmAddUint64
}

// Expect sets up expected params for Encoder.AddUint64
func (mmAddUint64 *mEncoderMockAddUint64) Expect(key string, value uint64) *mEncoderMockAddUint64 {
	if mmAddUint64.mock.funcAddUint64 != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Set")
	}

	if mmAddUint64.defaultExpectation == nil {
		mmAddUint64.defaultExpectation = &EncoderMockAddUint64Expectation{}
	}

	if mmAddUint64.defaultExpectation.paramPtrs != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by ExpectParams functions")
	}

	mmAddUint64.defaultExpectation.params = &EncoderMockAddUint64Params{key, value}
	mmAddUint64.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUint64.expectations {
		if minimock.Equal(e.params, mmAddUint64.defaultExpectation.params) {
			mmAddUint64.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUint64.defaultExpectation.params)
		}
	}

	return mmAddUint64
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUint64
func (mmAddUint64 *mEncoderMockAddUint64) ExpectKeyParam1(key string) *mEncoderMockAddUint64 {
	if mmAddUint64.mock.funcAddUint64 != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Set")
	}

	if mmAddUint64.defaultExpectation == nil {
		mmAddUint64.defaultExpectation = &EncoderMockAddUint64Expectation{}
	}

	if mmAddUint64.defaultExpectation.params != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Expect")
	}

	if mmAddUint64.defaultExpectation.paramPtrs == nil {
		mmAddUint64.defaultExpectation.paramPtrs = &EncoderMockAddUint64ParamPtrs{}
	}
	mmAddUint64.defaultExpectation.paramPtrs.key = &key
	mmAddUint64.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUint64
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUint64
func (mmAddUint64 *mEncoderMockAddUint64) ExpectValueParam2(value uint64) *mEncoderMockAddUint64 {
	if mmAddUint64.mock.funcAddUint64 != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Set")
	}

	if mmAddUint64.defaultExpectation == nil {
		mmAddUint64.defaultExpectation = &EncoderMockAddUint64Expectation{}
	}

	if mmAddUint64.defaultExpectation.params != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Expect")
	}

	if mmAddUint64.defaultExpectation.paramPtrs == nil {
		mmAddUint64.defaultExpectation.paramPtrs = &EncoderMockAddUint64ParamPtrs{}
	}
	mmAddUint64.defaultExpectation.paramPtrs.value = &value
	mmAddUint64.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUint64
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUint64
func (mmAddUint64 *mEncoderMockAddUint64) Inspect(f func(key string, value uint64)) *mEncoderMockAddUint64 {
	if mmAddUint64.mock.inspectFuncAddUint64 != nil {
		mmAddUint64.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUint64")
	}

	mmAddUint64.mock.inspectFuncAddUint64 = f

	return mmAddUint64
}

// Return sets up results that will be returned by Encoder.AddUint64
func (mmAddUint64 *mEncoderMockAddUint64) Return() *EncoderMock {
	if mmAddUint64.mock.funcAddUint64 != nil {
		mmAddUint64.mock.t.Fatalf("EncoderMock.AddUint64 mock is already set by Set")
	}

	if mmAddUint64.defaultExpectation == nil {
		mmAddUint64.defaultExpectation = &EncoderMockAddUint64Expectation{mock: mmAddUint64.mock}
	}

	mmAddUint64.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUint64.mock
}

// Set uses given function f to mock the Encoder.AddUint64 method
func (mmAddUint64 *mEncoderMockAddUint64) Set(f func(key string, value uint64)) *EncoderMock {
	if mmAddUint64.defaultExpectation != nil {
		mmAddUint64.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUint64 method")
	}

	if len(mmAddUint64.expectations) > 0 {
		mmAddUint64.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUint64 method")
	}

	mmAddUint64.mock.funcAddUint64 = f
	mmAddUint64.mock.funcAddUint64Origin = minimock.CallerInfo(1)
	return mmAddUint64.mock
}

// Times sets number of times Encoder.AddUint64 should be invoked
func (mmAddUint64 *mEncoderMockAddUint64) Times(n uint64) *mEncoderMockAddUint64 {
	if n == 0 {
		mmAddUint64.mock.t.Fatalf("Times of EncoderMock.AddUint64 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUint64.expectedInvocations, n)
	mmAddUint64.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUint64
}

func (mmAddUint64 *mEncoderMockAddUint64) invocationsDone() bool {
	if len(mmAddUint64.expectations) == 0 && mmAddUint64.defaultExpectation == nil && mmAddUint64.mock.funcAddUint64 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUint64.mock.afterAddUint64Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUint64.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUint64 implements Encoder
func (mmAddUint64 *EncoderMock) AddUint64(key string, value uint64) {
	mm_atomic.AddUint64(&mmAddUint64.beforeAddUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmAddUint64.afterAddUint64Counter, 1)

	mmAddUint64.t.Helper()

	if mmAddUint64.inspectFuncAddUint64 != nil {
		mmAddUint64.inspectFuncAddUint64(key, value)
	}

	mm_params := EncoderMockAddUint64Params{key, value}

	// Record call args
	mmAddUint64.AddUint64Mock.mutex.Lock()
	mmAddUint64.AddUint64Mock.callArgs = append(mmAddUint64.AddUint64Mock.callArgs, &mm_params)
	mmAddUint64.AddUint64Mock.mutex.Unlock()

	for _, e := range mmAddUint64.AddUint64Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUint64.AddUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUint64.AddUint64Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddUint64.AddUint64Mock.defaultExpectation.params
		mm_want_ptrs := mmAddUint64.AddUint64Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUint64Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUint64.t.Errorf("EncoderMock.AddUint64 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint64.AddUint64Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUint64.t.Errorf("EncoderMock.AddUint64 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint64.AddUint64Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUint64.t.Errorf("EncoderMock.AddUint64 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUint64.AddUint64Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUint64.funcAddUint64 != nil {
		mmAddUint64.funcAddUint64(key, value)
		return
	}
	mmAddUint64.t.Fatalf("Unexpected call to EncoderMock.AddUint64. %v %v", key, value)

}

// AddUint64AfterCounter returns a count of finished EncoderMock.AddUint64 invocations
func (mmAddUint64 *EncoderMock) AddUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint64.afterAddUint64Counter)
}

// AddUint64BeforeCounter returns a count of EncoderMock.AddUint64 invocations
func (mmAddUint64 *EncoderMock) AddUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint64.beforeAddUint64Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUint64.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUint64 *mEncoderMockAddUint64) Calls() []*EncoderMockAddUint64Params {
	mmAddUint64.mutex.RLock()

	argCopy := make([]*EncoderMockAddUint64Params, len(mmAddUint64.callArgs))
	copy(argCopy, mmAddUint64.callArgs)

	mmAddUint64.mutex.RUnlock()

	return argCopy
}

// MinimockAddUint64Done returns true if the count of the AddUint64 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUint64Done() bool {
	if m.AddUint64Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUint64Mock.invocationsDone()
}

// MinimockAddUint64Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUint64Inspect() {
	for _, e := range m.AddUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUint64 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUint64Counter := mm_atomic.LoadUint64(&m.afterAddUint64Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUint64Mock.defaultExpectation != nil && afterAddUint64Counter < 1 {
		if m.AddUint64Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUint64 at\n%s", m.AddUint64Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUint64 at\n%s with params: %#v", m.AddUint64Mock.defaultExpectation.expectationOrigins.origin, *m.AddUint64Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUint64 != nil && afterAddUint64Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUint64 at\n%s", m.funcAddUint64Origin)
	}

	if !m.AddUint64Mock.invocationsDone() && afterAddUint64Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUint64 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUint64Mock.expectedInvocations), m.AddUint64Mock.expectedInvocationsOrigin, afterAddUint64Counter)
	}
}

type mEncoderMockAddUint8 struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUint8Expectation
	expectations       []*EncoderMockAddUint8Expectation

	callArgs []*EncoderMockAddUint8Params
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUint8Expectation specifies expectation struct of the Encoder.AddUint8
type EncoderMockAddUint8Expectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUint8Params
	paramPtrs          *EncoderMockAddUint8ParamPtrs
	expectationOrigins EncoderMockAddUint8ExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUint8Params contains parameters of the Encoder.AddUint8
type EncoderMockAddUint8Params struct {
	key   string
	value uint8
}

// EncoderMockAddUint8ParamPtrs contains pointers to parameters of the Encoder.AddUint8
type EncoderMockAddUint8ParamPtrs struct {
	key   *string
	value *uint8
}

// EncoderMockAddUint8Origins contains origins of expectations of the Encoder.AddUint8
type EncoderMockAddUint8ExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUint8 *mEncoderMockAddUint8) Optional() *mEncoderMockAddUint8 {
	mmAddUint8.optional = true
	return mmAddUint8
}

// Expect sets up expected params for Encoder.AddUint8
func (mmAddUint8 *mEncoderMockAddUint8) Expect(key string, value uint8) *mEncoderMockAddUint8 {
	if mmAddUint8.mock.funcAddUint8 != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Set")
	}

	if mmAddUint8.defaultExpectation == nil {
		mmAddUint8.defaultExpectation = &EncoderMockAddUint8Expectation{}
	}

	if mmAddUint8.defaultExpectation.paramPtrs != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by ExpectParams functions")
	}

	mmAddUint8.defaultExpectation.params = &EncoderMockAddUint8Params{key, value}
	mmAddUint8.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUint8.expectations {
		if minimock.Equal(e.params, mmAddUint8.defaultExpectation.params) {
			mmAddUint8.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUint8.defaultExpectation.params)
		}
	}

	return mmAddUint8
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUint8
func (mmAddUint8 *mEncoderMockAddUint8) ExpectKeyParam1(key string) *mEncoderMockAddUint8 {
	if mmAddUint8.mock.funcAddUint8 != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Set")
	}

	if mmAddUint8.defaultExpectation == nil {
		mmAddUint8.defaultExpectation = &EncoderMockAddUint8Expectation{}
	}

	if mmAddUint8.defaultExpectation.params != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Expect")
	}

	if mmAddUint8.defaultExpectation.paramPtrs == nil {
		mmAddUint8.defaultExpectation.paramPtrs = &EncoderMockAddUint8ParamPtrs{}
	}
	mmAddUint8.defaultExpectation.paramPtrs.key = &key
	mmAddUint8.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUint8
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUint8
func (mmAddUint8 *mEncoderMockAddUint8) ExpectValueParam2(value uint8) *mEncoderMockAddUint8 {
	if mmAddUint8.mock.funcAddUint8 != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Set")
	}

	if mmAddUint8.defaultExpectation == nil {
		mmAddUint8.defaultExpectation = &EncoderMockAddUint8Expectation{}
	}

	if mmAddUint8.defaultExpectation.params != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Expect")
	}

	if mmAddUint8.defaultExpectation.paramPtrs == nil {
		mmAddUint8.defaultExpectation.paramPtrs = &EncoderMockAddUint8ParamPtrs{}
	}
	mmAddUint8.defaultExpectation.paramPtrs.value = &value
	mmAddUint8.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUint8
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUint8
func (mmAddUint8 *mEncoderMockAddUint8) Inspect(f func(key string, value uint8)) *mEncoderMockAddUint8 {
	if mmAddUint8.mock.inspectFuncAddUint8 != nil {
		mmAddUint8.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUint8")
	}

	mmAddUint8.mock.inspectFuncAddUint8 = f

	return mmAddUint8
}

// Return sets up results that will be returned by Encoder.AddUint8
func (mmAddUint8 *mEncoderMockAddUint8) Return() *EncoderMock {
	if mmAddUint8.mock.funcAddUint8 != nil {
		mmAddUint8.mock.t.Fatalf("EncoderMock.AddUint8 mock is already set by Set")
	}

	if mmAddUint8.defaultExpectation == nil {
		mmAddUint8.defaultExpectation = &EncoderMockAddUint8Expectation{mock: mmAddUint8.mock}
	}

	mmAddUint8.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUint8.mock
}

// Set uses given function f to mock the Encoder.AddUint8 method
func (mmAddUint8 *mEncoderMockAddUint8) Set(f func(key string, value uint8)) *EncoderMock {
	if mmAddUint8.defaultExpectation != nil {
		mmAddUint8.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUint8 method")
	}

	if len(mmAddUint8.expectations) > 0 {
		mmAddUint8.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUint8 method")
	}

	mmAddUint8.mock.funcAddUint8 = f
	mmAddUint8.mock.funcAddUint8Origin = minimock.CallerInfo(1)
	return mmAddUint8.mock
}

// Times sets number of times Encoder.AddUint8 should be invoked
func (mmAddUint8 *mEncoderMockAddUint8) Times(n uint64) *mEncoderMockAddUint8 {
	if n == 0 {
		mmAddUint8.mock.t.Fatalf("Times of EncoderMock.AddUint8 mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUint8.expectedInvocations, n)
	mmAddUint8.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUint8
}

func (mmAddUint8 *mEncoderMockAddUint8) invocationsDone() bool {
	if len(mmAddUint8.expectations) == 0 && mmAddUint8.defaultExpectation == nil && mmAddUint8.mock.funcAddUint8 == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUint8.mock.afterAddUint8Counter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUint8.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUint8 implements Encoder
func (mmAddUint8 *EncoderMock) AddUint8(key string, value uint8) {
	mm_atomic.AddUint64(&mmAddUint8.beforeAddUint8Counter, 1)
	defer mm_atomic.AddUint64(&mmAddUint8.afterAddUint8Counter, 1)

	mmAddUint8.t.Helper()

	if mmAddUint8.inspectFuncAddUint8 != nil {
		mmAddUint8.inspectFuncAddUint8(key, value)
	}

	mm_params := EncoderMockAddUint8Params{key, value}

	// Record call args
	mmAddUint8.AddUint8Mock.mutex.Lock()
	mmAddUint8.AddUint8Mock.callArgs = append(mmAddUint8.AddUint8Mock.callArgs, &mm_params)
	mmAddUint8.AddUint8Mock.mutex.Unlock()

	for _, e := range mmAddUint8.AddUint8Mock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUint8.AddUint8Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUint8.AddUint8Mock.defaultExpectation.Counter, 1)
		mm_want := mmAddUint8.AddUint8Mock.defaultExpectation.params
		mm_want_ptrs := mmAddUint8.AddUint8Mock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUint8Params{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUint8.t.Errorf("EncoderMock.AddUint8 got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint8.AddUint8Mock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUint8.t.Errorf("EncoderMock.AddUint8 got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUint8.AddUint8Mock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUint8.t.Errorf("EncoderMock.AddUint8 got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUint8.AddUint8Mock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUint8.funcAddUint8 != nil {
		mmAddUint8.funcAddUint8(key, value)
		return
	}
	mmAddUint8.t.Fatalf("Unexpected call to EncoderMock.AddUint8. %v %v", key, value)

}

// AddUint8AfterCounter returns a count of finished EncoderMock.AddUint8 invocations
func (mmAddUint8 *EncoderMock) AddUint8AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint8.afterAddUint8Counter)
}

// AddUint8BeforeCounter returns a count of EncoderMock.AddUint8 invocations
func (mmAddUint8 *EncoderMock) AddUint8BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUint8.beforeAddUint8Counter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUint8.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUint8 *mEncoderMockAddUint8) Calls() []*EncoderMockAddUint8Params {
	mmAddUint8.mutex.RLock()

	argCopy := make([]*EncoderMockAddUint8Params, len(mmAddUint8.callArgs))
	copy(argCopy, mmAddUint8.callArgs)

	mmAddUint8.mutex.RUnlock()

	return argCopy
}

// MinimockAddUint8Done returns true if the count of the AddUint8 invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUint8Done() bool {
	if m.AddUint8Mock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUint8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUint8Mock.invocationsDone()
}

// MinimockAddUint8Inspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUint8Inspect() {
	for _, e := range m.AddUint8Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUint8 at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUint8Counter := mm_atomic.LoadUint64(&m.afterAddUint8Counter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUint8Mock.defaultExpectation != nil && afterAddUint8Counter < 1 {
		if m.AddUint8Mock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUint8 at\n%s", m.AddUint8Mock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUint8 at\n%s with params: %#v", m.AddUint8Mock.defaultExpectation.expectationOrigins.origin, *m.AddUint8Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUint8 != nil && afterAddUint8Counter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUint8 at\n%s", m.funcAddUint8Origin)
	}

	if !m.AddUint8Mock.invocationsDone() && afterAddUint8Counter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUint8 at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUint8Mock.expectedInvocations), m.AddUint8Mock.expectedInvocationsOrigin, afterAddUint8Counter)
	}
}

type mEncoderMockAddUintptr struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockAddUintptrExpectation
	expectations       []*EncoderMockAddUintptrExpectation

	callArgs []*EncoderMockAddUintptrParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockAddUintptrExpectation specifies expectation struct of the Encoder.AddUintptr
type EncoderMockAddUintptrExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockAddUintptrParams
	paramPtrs          *EncoderMockAddUintptrParamPtrs
	expectationOrigins EncoderMockAddUintptrExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockAddUintptrParams contains parameters of the Encoder.AddUintptr
type EncoderMockAddUintptrParams struct {
	key   string
	value uintptr
}

// EncoderMockAddUintptrParamPtrs contains pointers to parameters of the Encoder.AddUintptr
type EncoderMockAddUintptrParamPtrs struct {
	key   *string
	value *uintptr
}

// EncoderMockAddUintptrOrigins contains origins of expectations of the Encoder.AddUintptr
type EncoderMockAddUintptrExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUintptr *mEncoderMockAddUintptr) Optional() *mEncoderMockAddUintptr {
	mmAddUintptr.optional = true
	return mmAddUintptr
}

// Expect sets up expected params for Encoder.AddUintptr
func (mmAddUintptr *mEncoderMockAddUintptr) Expect(key string, value uintptr) *mEncoderMockAddUintptr {
	if mmAddUintptr.mock.funcAddUintptr != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Set")
	}

	if mmAddUintptr.defaultExpectation == nil {
		mmAddUintptr.defaultExpectation = &EncoderMockAddUintptrExpectation{}
	}

	if mmAddUintptr.defaultExpectation.paramPtrs != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by ExpectParams functions")
	}

	mmAddUintptr.defaultExpectation.params = &EncoderMockAddUintptrParams{key, value}
	mmAddUintptr.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUintptr.expectations {
		if minimock.Equal(e.params, mmAddUintptr.defaultExpectation.params) {
			mmAddUintptr.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUintptr.defaultExpectation.params)
		}
	}

	return mmAddUintptr
}

// ExpectKeyParam1 sets up expected param key for Encoder.AddUintptr
func (mmAddUintptr *mEncoderMockAddUintptr) ExpectKeyParam1(key string) *mEncoderMockAddUintptr {
	if mmAddUintptr.mock.funcAddUintptr != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Set")
	}

	if mmAddUintptr.defaultExpectation == nil {
		mmAddUintptr.defaultExpectation = &EncoderMockAddUintptrExpectation{}
	}

	if mmAddUintptr.defaultExpectation.params != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Expect")
	}

	if mmAddUintptr.defaultExpectation.paramPtrs == nil {
		mmAddUintptr.defaultExpectation.paramPtrs = &EncoderMockAddUintptrParamPtrs{}
	}
	mmAddUintptr.defaultExpectation.paramPtrs.key = &key
	mmAddUintptr.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAddUintptr
}

// ExpectValueParam2 sets up expected param value for Encoder.AddUintptr
func (mmAddUintptr *mEncoderMockAddUintptr) ExpectValueParam2(value uintptr) *mEncoderMockAddUintptr {
	if mmAddUintptr.mock.funcAddUintptr != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Set")
	}

	if mmAddUintptr.defaultExpectation == nil {
		mmAddUintptr.defaultExpectation = &EncoderMockAddUintptrExpectation{}
	}

	if mmAddUintptr.defaultExpectation.params != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Expect")
	}

	if mmAddUintptr.defaultExpectation.paramPtrs == nil {
		mmAddUintptr.defaultExpectation.paramPtrs = &EncoderMockAddUintptrParamPtrs{}
	}
	mmAddUintptr.defaultExpectation.paramPtrs.value = &value
	mmAddUintptr.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddUintptr
}

// Inspect accepts an inspector function that has same arguments as the Encoder.AddUintptr
func (mmAddUintptr *mEncoderMockAddUintptr) Inspect(f func(key string, value uintptr)) *mEncoderMockAddUintptr {
	if mmAddUintptr.mock.inspectFuncAddUintptr != nil {
		mmAddUintptr.mock.t.Fatalf("Inspect function is already set for EncoderMock.AddUintptr")
	}

	mmAddUintptr.mock.inspectFuncAddUintptr = f

	return mmAddUintptr
}

// Return sets up results that will be returned by Encoder.AddUintptr
func (mmAddUintptr *mEncoderMockAddUintptr) Return() *EncoderMock {
	if mmAddUintptr.mock.funcAddUintptr != nil {
		mmAddUintptr.mock.t.Fatalf("EncoderMock.AddUintptr mock is already set by Set")
	}

	if mmAddUintptr.defaultExpectation == nil {
		mmAddUintptr.defaultExpectation = &EncoderMockAddUintptrExpectation{mock: mmAddUintptr.mock}
	}

	mmAddUintptr.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUintptr.mock
}

// Set uses given function f to mock the Encoder.AddUintptr method
func (mmAddUintptr *mEncoderMockAddUintptr) Set(f func(key string, value uintptr)) *EncoderMock {
	if mmAddUintptr.defaultExpectation != nil {
		mmAddUintptr.mock.t.Fatalf("Default expectation is already set for the Encoder.AddUintptr method")
	}

	if len(mmAddUintptr.expectations) > 0 {
		mmAddUintptr.mock.t.Fatalf("Some expectations are already set for the Encoder.AddUintptr method")
	}

	mmAddUintptr.mock.funcAddUintptr = f
	mmAddUintptr.mock.funcAddUintptrOrigin = minimock.CallerInfo(1)
	return mmAddUintptr.mock
}

// Times sets number of times Encoder.AddUintptr should be invoked
func (mmAddUintptr *mEncoderMockAddUintptr) Times(n uint64) *mEncoderMockAddUintptr {
	if n == 0 {
		mmAddUintptr.mock.t.Fatalf("Times of EncoderMock.AddUintptr mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUintptr.expectedInvocations, n)
	mmAddUintptr.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUintptr
}

func (mmAddUintptr *mEncoderMockAddUintptr) invocationsDone() bool {
	if len(mmAddUintptr.expectations) == 0 && mmAddUintptr.defaultExpectation == nil && mmAddUintptr.mock.funcAddUintptr == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUintptr.mock.afterAddUintptrCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUintptr.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUintptr implements Encoder
func (mmAddUintptr *EncoderMock) AddUintptr(key string, value uintptr) {
	mm_atomic.AddUint64(&mmAddUintptr.beforeAddUintptrCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUintptr.afterAddUintptrCounter, 1)

	mmAddUintptr.t.Helper()

	if mmAddUintptr.inspectFuncAddUintptr != nil {
		mmAddUintptr.inspectFuncAddUintptr(key, value)
	}

	mm_params := EncoderMockAddUintptrParams{key, value}

	// Record call args
	mmAddUintptr.AddUintptrMock.mutex.Lock()
	mmAddUintptr.AddUintptrMock.callArgs = append(mmAddUintptr.AddUintptrMock.callArgs, &mm_params)
	mmAddUintptr.AddUintptrMock.mutex.Unlock()

	for _, e := range mmAddUintptr.AddUintptrMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddUintptr.AddUintptrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUintptr.AddUintptrMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUintptr.AddUintptrMock.defaultExpectation.params
		mm_want_ptrs := mmAddUintptr.AddUintptrMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockAddUintptrParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAddUintptr.t.Errorf("EncoderMock.AddUintptr got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUintptr.AddUintptrMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddUintptr.t.Errorf("EncoderMock.AddUintptr got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUintptr.AddUintptrMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUintptr.t.Errorf("EncoderMock.AddUintptr got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUintptr.AddUintptrMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddUintptr.funcAddUintptr != nil {
		mmAddUintptr.funcAddUintptr(key, value)
		return
	}
	mmAddUintptr.t.Fatalf("Unexpected call to EncoderMock.AddUintptr. %v %v", key, value)

}

// AddUintptrAfterCounter returns a count of finished EncoderMock.AddUintptr invocations
func (mmAddUintptr *EncoderMock) AddUintptrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUintptr.afterAddUintptrCounter)
}

// AddUintptrBeforeCounter returns a count of EncoderMock.AddUintptr invocations
func (mmAddUintptr *EncoderMock) AddUintptrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUintptr.beforeAddUintptrCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.AddUintptr.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUintptr *mEncoderMockAddUintptr) Calls() []*EncoderMockAddUintptrParams {
	mmAddUintptr.mutex.RLock()

	argCopy := make([]*EncoderMockAddUintptrParams, len(mmAddUintptr.callArgs))
	copy(argCopy, mmAddUintptr.callArgs)

	mmAddUintptr.mutex.RUnlock()

	return argCopy
}

// MinimockAddUintptrDone returns true if the count of the AddUintptr invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockAddUintptrDone() bool {
	if m.AddUintptrMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUintptrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUintptrMock.invocationsDone()
}

// MinimockAddUintptrInspect logs each unmet expectation
func (m *EncoderMock) MinimockAddUintptrInspect() {
	for _, e := range m.AddUintptrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.AddUintptr at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUintptrCounter := mm_atomic.LoadUint64(&m.afterAddUintptrCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUintptrMock.defaultExpectation != nil && afterAddUintptrCounter < 1 {
		if m.AddUintptrMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.AddUintptr at\n%s", m.AddUintptrMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.AddUintptr at\n%s with params: %#v", m.AddUintptrMock.defaultExpectation.expectationOrigins.origin, *m.AddUintptrMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUintptr != nil && afterAddUintptrCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.AddUintptr at\n%s", m.funcAddUintptrOrigin)
	}

	if !m.AddUintptrMock.invocationsDone() && afterAddUintptrCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.AddUintptr at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUintptrMock.expectedInvocations), m.AddUintptrMock.expectedInvocationsOrigin, afterAddUintptrCounter)
	}
}

type mEncoderMockClone struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockCloneExpectation
	expectations       []*EncoderMockCloneExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockCloneExpectation specifies expectation struct of the Encoder.Clone
type EncoderMockCloneExpectation struct {
	mock *EncoderMock

	results      *EncoderMockCloneResults
	returnOrigin string
	Counter      uint64
}

// EncoderMockCloneResults contains results of the Encoder.Clone
type EncoderMockCloneResults struct {
	e1 zapcore.Encoder
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClone *mEncoderMockClone) Optional() *mEncoderMockClone {
	mmClone.optional = true
	return mmClone
}

// Expect sets up expected params for Encoder.Clone
func (mmClone *mEncoderMockClone) Expect() *mEncoderMockClone {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("EncoderMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &EncoderMockCloneExpectation{}
	}

	return mmClone
}

// Inspect accepts an inspector function that has same arguments as the Encoder.Clone
func (mmClone *mEncoderMockClone) Inspect(f func()) *mEncoderMockClone {
	if mmClone.mock.inspectFuncClone != nil {
		mmClone.mock.t.Fatalf("Inspect function is already set for EncoderMock.Clone")
	}

	mmClone.mock.inspectFuncClone = f

	return mmClone
}

// Return sets up results that will be returned by Encoder.Clone
func (mmClone *mEncoderMockClone) Return(e1 zapcore.Encoder) *EncoderMock {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("EncoderMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &EncoderMockCloneExpectation{mock: mmClone.mock}
	}
	mmClone.defaultExpectation.results = &EncoderMockCloneResults{e1}
	mmClone.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClone.mock
}

// Set uses given function f to mock the Encoder.Clone method
func (mmClone *mEncoderMockClone) Set(f func() (e1 zapcore.Encoder)) *EncoderMock {
	if mmClone.defaultExpectation != nil {
		mmClone.mock.t.Fatalf("Default expectation is already set for the Encoder.Clone method")
	}

	if len(mmClone.expectations) > 0 {
		mmClone.mock.t.Fatalf("Some expectations are already set for the Encoder.Clone method")
	}

	mmClone.mock.funcClone = f
	mmClone.mock.funcCloneOrigin = minimock.CallerInfo(1)
	return mmClone.mock
}

// Times sets number of times Encoder.Clone should be invoked
func (mmClone *mEncoderMockClone) Times(n uint64) *mEncoderMockClone {
	if n == 0 {
		mmClone.mock.t.Fatalf("Times of EncoderMock.Clone mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClone.expectedInvocations, n)
	mmClone.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClone
}

func (mmClone *mEncoderMockClone) invocationsDone() bool {
	if len(mmClone.expectations) == 0 && mmClone.defaultExpectation == nil && mmClone.mock.funcClone == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClone.mock.afterCloneCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClone.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Clone implements Encoder
func (mmClone *EncoderMock) Clone() (e1 zapcore.Encoder) {
	mm_atomic.AddUint64(&mmClone.beforeCloneCounter, 1)
	defer mm_atomic.AddUint64(&mmClone.afterCloneCounter, 1)

	mmClone.t.Helper()

	if mmClone.inspectFuncClone != nil {
		mmClone.inspectFuncClone()
	}

	if mmClone.CloneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClone.CloneMock.defaultExpectation.Counter, 1)

		mm_results := mmClone.CloneMock.defaultExpectation.results
		if mm_results == nil {
			mmClone.t.Fatal("No results are set for the EncoderMock.Clone")
		}
		return (*mm_results).e1
	}
	if mmClone.funcClone != nil {
		return mmClone.funcClone()
	}
	mmClone.t.Fatalf("Unexpected call to EncoderMock.Clone.")
	return
}

// CloneAfterCounter returns a count of finished EncoderMock.Clone invocations
func (mmClone *EncoderMock) CloneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.afterCloneCounter)
}

// CloneBeforeCounter returns a count of EncoderMock.Clone invocations
func (mmClone *EncoderMock) CloneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.beforeCloneCounter)
}

// MinimockCloneDone returns true if the count of the Clone invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockCloneDone() bool {
	if m.CloneMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloneMock.invocationsDone()
}

// MinimockCloneInspect logs each unmet expectation
func (m *EncoderMock) MinimockCloneInspect() {
	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EncoderMock.Clone")
		}
	}

	afterCloneCounter := mm_atomic.LoadUint64(&m.afterCloneCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloneMock.defaultExpectation != nil && afterCloneCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.Clone at\n%s", m.CloneMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClone != nil && afterCloneCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.Clone at\n%s", m.funcCloneOrigin)
	}

	if !m.CloneMock.invocationsDone() && afterCloneCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.Clone at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloneMock.expectedInvocations), m.CloneMock.expectedInvocationsOrigin, afterCloneCounter)
	}
}

type mEncoderMockEncodeEntry struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockEncodeEntryExpectation
	expectations       []*EncoderMockEncodeEntryExpectation

	callArgs []*EncoderMockEncodeEntryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockEncodeEntryExpectation specifies expectation struct of the Encoder.EncodeEntry
type EncoderMockEncodeEntryExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockEncodeEntryParams
	paramPtrs          *EncoderMockEncodeEntryParamPtrs
	expectationOrigins EncoderMockEncodeEntryExpectationOrigins
	results            *EncoderMockEncodeEntryResults
	returnOrigin       string
	Counter            uint64
}

// EncoderMockEncodeEntryParams contains parameters of the Encoder.EncodeEntry
type EncoderMockEncodeEntryParams struct {
	entry  zapcore.Entry
	fields []zapcore.Field
}

// EncoderMockEncodeEntryParamPtrs contains pointers to parameters of the Encoder.EncodeEntry
type EncoderMockEncodeEntryParamPtrs struct {
	entry  *zapcore.Entry
	fields *[]zapcore.Field
}

// EncoderMockEncodeEntryResults contains results of the Encoder.EncodeEntry
type EncoderMockEncodeEntryResults struct {
	bp1 *buffer.Buffer
	err error
}

// EncoderMockEncodeEntryOrigins contains origins of expectations of the Encoder.EncodeEntry
type EncoderMockEncodeEntryExpectationOrigins struct {
	origin       string
	originEntry  string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEncodeEntry *mEncoderMockEncodeEntry) Optional() *mEncoderMockEncodeEntry {
	mmEncodeEntry.optional = true
	return mmEncodeEntry
}

// Expect sets up expected params for Encoder.EncodeEntry
func (mmEncodeEntry *mEncoderMockEncodeEntry) Expect(entry zapcore.Entry, fields []zapcore.Field) *mEncoderMockEncodeEntry {
	if mmEncodeEntry.mock.funcEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Set")
	}

	if mmEncodeEntry.defaultExpectation == nil {
		mmEncodeEntry.defaultExpectation = &EncoderMockEncodeEntryExpectation{}
	}

	if mmEncodeEntry.defaultExpectation.paramPtrs != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by ExpectParams functions")
	}

	mmEncodeEntry.defaultExpectation.params = &EncoderMockEncodeEntryParams{entry, fields}
	mmEncodeEntry.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEncodeEntry.expectations {
		if minimock.Equal(e.params, mmEncodeEntry.defaultExpectation.params) {
			mmEncodeEntry.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEncodeEntry.defaultExpectation.params)
		}
	}

	return mmEncodeEntry
}

// ExpectEntryParam1 sets up expected param entry for Encoder.EncodeEntry
func (mmEncodeEntry *mEncoderMockEncodeEntry) ExpectEntryParam1(entry zapcore.Entry) *mEncoderMockEncodeEntry {
	if mmEncodeEntry.mock.funcEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Set")
	}

	if mmEncodeEntry.defaultExpectation == nil {
		mmEncodeEntry.defaultExpectation = &EncoderMockEncodeEntryExpectation{}
	}

	if mmEncodeEntry.defaultExpectation.params != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Expect")
	}

	if mmEncodeEntry.defaultExpectation.paramPtrs == nil {
		mmEncodeEntry.defaultExpectation.paramPtrs = &EncoderMockEncodeEntryParamPtrs{}
	}
	mmEncodeEntry.defaultExpectation.paramPtrs.entry = &entry
	mmEncodeEntry.defaultExpectation.expectationOrigins.originEntry = minimock.CallerInfo(1)

	return mmEncodeEntry
}

// ExpectFieldsParam2 sets up expected param fields for Encoder.EncodeEntry
func (mmEncodeEntry *mEncoderMockEncodeEntry) ExpectFieldsParam2(fields []zapcore.Field) *mEncoderMockEncodeEntry {
	if mmEncodeEntry.mock.funcEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Set")
	}

	if mmEncodeEntry.defaultExpectation == nil {
		mmEncodeEntry.defaultExpectation = &EncoderMockEncodeEntryExpectation{}
	}

	if mmEncodeEntry.defaultExpectation.params != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Expect")
	}

	if mmEncodeEntry.defaultExpectation.paramPtrs == nil {
		mmEncodeEntry.defaultExpectation.paramPtrs = &EncoderMockEncodeEntryParamPtrs{}
	}
	mmEncodeEntry.defaultExpectation.paramPtrs.fields = &fields
	mmEncodeEntry.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmEncodeEntry
}

// Inspect accepts an inspector function that has same arguments as the Encoder.EncodeEntry
func (mmEncodeEntry *mEncoderMockEncodeEntry) Inspect(f func(entry zapcore.Entry, fields []zapcore.Field)) *mEncoderMockEncodeEntry {
	if mmEncodeEntry.mock.inspectFuncEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("Inspect function is already set for EncoderMock.EncodeEntry")
	}

	mmEncodeEntry.mock.inspectFuncEncodeEntry = f

	return mmEncodeEntry
}

// Return sets up results that will be returned by Encoder.EncodeEntry
func (mmEncodeEntry *mEncoderMockEncodeEntry) Return(bp1 *buffer.Buffer, err error) *EncoderMock {
	if mmEncodeEntry.mock.funcEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Set")
	}

	if mmEncodeEntry.defaultExpectation == nil {
		mmEncodeEntry.defaultExpectation = &EncoderMockEncodeEntryExpectation{mock: mmEncodeEntry.mock}
	}
	mmEncodeEntry.defaultExpectation.results = &EncoderMockEncodeEntryResults{bp1, err}
	mmEncodeEntry.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEncodeEntry.mock
}

// Set uses given function f to mock the Encoder.EncodeEntry method
func (mmEncodeEntry *mEncoderMockEncodeEntry) Set(f func(entry zapcore.Entry, fields []zapcore.Field) (bp1 *buffer.Buffer, err error)) *EncoderMock {
	if mmEncodeEntry.defaultExpectation != nil {
		mmEncodeEntry.mock.t.Fatalf("Default expectation is already set for the Encoder.EncodeEntry method")
	}

	if len(mmEncodeEntry.expectations) > 0 {
		mmEncodeEntry.mock.t.Fatalf("Some expectations are already set for the Encoder.EncodeEntry method")
	}

	mmEncodeEntry.mock.funcEncodeEntry = f
	mmEncodeEntry.mock.funcEncodeEntryOrigin = minimock.CallerInfo(1)
	return mmEncodeEntry.mock
}

// When sets expectation for the Encoder.EncodeEntry which will trigger the result defined by the following
// Then helper
func (mmEncodeEntry *mEncoderMockEncodeEntry) When(entry zapcore.Entry, fields []zapcore.Field) *EncoderMockEncodeEntryExpectation {
	if mmEncodeEntry.mock.funcEncodeEntry != nil {
		mmEncodeEntry.mock.t.Fatalf("EncoderMock.EncodeEntry mock is already set by Set")
	}

	expectation := &EncoderMockEncodeEntryExpectation{
		mock:               mmEncodeEntry.mock,
		params:             &EncoderMockEncodeEntryParams{entry, fields},
		expectationOrigins: EncoderMockEncodeEntryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEncodeEntry.expectations = append(mmEncodeEntry.expectations, expectation)
	return expectation
}

// Then sets up Encoder.EncodeEntry return parameters for the expectation previously defined by the When method
func (e *EncoderMockEncodeEntryExpectation) Then(bp1 *buffer.Buffer, err error) *EncoderMock {
	e.results = &EncoderMockEncodeEntryResults{bp1, err}
	return e.mock
}

// Times sets number of times Encoder.EncodeEntry should be invoked
func (mmEncodeEntry *mEncoderMockEncodeEntry) Times(n uint64) *mEncoderMockEncodeEntry {
	if n == 0 {
		mmEncodeEntry.mock.t.Fatalf("Times of EncoderMock.EncodeEntry mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEncodeEntry.expectedInvocations, n)
	mmEncodeEntry.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEncodeEntry
}

func (mmEncodeEntry *mEncoderMockEncodeEntry) invocationsDone() bool {
	if len(mmEncodeEntry.expectations) == 0 && mmEncodeEntry.defaultExpectation == nil && mmEncodeEntry.mock.funcEncodeEntry == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEncodeEntry.mock.afterEncodeEntryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEncodeEntry.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EncodeEntry implements Encoder
func (mmEncodeEntry *EncoderMock) EncodeEntry(entry zapcore.Entry, fields []zapcore.Field) (bp1 *buffer.Buffer, err error) {
	mm_atomic.AddUint64(&mmEncodeEntry.beforeEncodeEntryCounter, 1)
	defer mm_atomic.AddUint64(&mmEncodeEntry.afterEncodeEntryCounter, 1)

	mmEncodeEntry.t.Helper()

	if mmEncodeEntry.inspectFuncEncodeEntry != nil {
		mmEncodeEntry.inspectFuncEncodeEntry(entry, fields)
	}

	mm_params := EncoderMockEncodeEntryParams{entry, fields}

	// Record call args
	mmEncodeEntry.EncodeEntryMock.mutex.Lock()
	mmEncodeEntry.EncodeEntryMock.callArgs = append(mmEncodeEntry.EncodeEntryMock.callArgs, &mm_params)
	mmEncodeEntry.EncodeEntryMock.mutex.Unlock()

	for _, e := range mmEncodeEntry.EncodeEntryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmEncodeEntry.EncodeEntryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEncodeEntry.EncodeEntryMock.defaultExpectation.Counter, 1)
		mm_want := mmEncodeEntry.EncodeEntryMock.defaultExpectation.params
		mm_want_ptrs := mmEncodeEntry.EncodeEntryMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockEncodeEntryParams{entry, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.entry != nil && !minimock.Equal(*mm_want_ptrs.entry, mm_got.entry) {
				mmEncodeEntry.t.Errorf("EncoderMock.EncodeEntry got unexpected parameter entry, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEncodeEntry.EncodeEntryMock.defaultExpectation.expectationOrigins.originEntry, *mm_want_ptrs.entry, mm_got.entry, minimock.Diff(*mm_want_ptrs.entry, mm_got.entry))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmEncodeEntry.t.Errorf("EncoderMock.EncodeEntry got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEncodeEntry.EncodeEntryMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEncodeEntry.t.Errorf("EncoderMock.EncodeEntry got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEncodeEntry.EncodeEntryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEncodeEntry.EncodeEntryMock.defaultExpectation.results
		if mm_results == nil {
			mmEncodeEntry.t.Fatal("No results are set for the EncoderMock.EncodeEntry")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmEncodeEntry.funcEncodeEntry != nil {
		return mmEncodeEntry.funcEncodeEntry(entry, fields)
	}
	mmEncodeEntry.t.Fatalf("Unexpected call to EncoderMock.EncodeEntry. %v %v", entry, fields)
	return
}

// EncodeEntryAfterCounter returns a count of finished EncoderMock.EncodeEntry invocations
func (mmEncodeEntry *EncoderMock) EncodeEntryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEncodeEntry.afterEncodeEntryCounter)
}

// EncodeEntryBeforeCounter returns a count of EncoderMock.EncodeEntry invocations
func (mmEncodeEntry *EncoderMock) EncodeEntryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEncodeEntry.beforeEncodeEntryCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.EncodeEntry.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEncodeEntry *mEncoderMockEncodeEntry) Calls() []*EncoderMockEncodeEntryParams {
	mmEncodeEntry.mutex.RLock()

	argCopy := make([]*EncoderMockEncodeEntryParams, len(mmEncodeEntry.callArgs))
	copy(argCopy, mmEncodeEntry.callArgs)

	mmEncodeEntry.mutex.RUnlock()

	return argCopy
}

// MinimockEncodeEntryDone returns true if the count of the EncodeEntry invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockEncodeEntryDone() bool {
	if m.EncodeEntryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EncodeEntryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EncodeEntryMock.invocationsDone()
}

// MinimockEncodeEntryInspect logs each unmet expectation
func (m *EncoderMock) MinimockEncodeEntryInspect() {
	for _, e := range m.EncodeEntryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.EncodeEntry at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEncodeEntryCounter := mm_atomic.LoadUint64(&m.afterEncodeEntryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EncodeEntryMock.defaultExpectation != nil && afterEncodeEntryCounter < 1 {
		if m.EncodeEntryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.EncodeEntry at\n%s", m.EncodeEntryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.EncodeEntry at\n%s with params: %#v", m.EncodeEntryMock.defaultExpectation.expectationOrigins.origin, *m.EncodeEntryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEncodeEntry != nil && afterEncodeEntryCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.EncodeEntry at\n%s", m.funcEncodeEntryOrigin)
	}

	if !m.EncodeEntryMock.invocationsDone() && afterEncodeEntryCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.EncodeEntry at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EncodeEntryMock.expectedInvocations), m.EncodeEntryMock.expectedInvocationsOrigin, afterEncodeEntryCounter)
	}
}

type mEncoderMockOpenNamespace struct {
	optional           bool
	mock               *EncoderMock
	defaultExpectation *EncoderMockOpenNamespaceExpectation
	expectations       []*EncoderMockOpenNamespaceExpectation

	callArgs []*EncoderMockOpenNamespaceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EncoderMockOpenNamespaceExpectation specifies expectation struct of the Encoder.OpenNamespace
type EncoderMockOpenNamespaceExpectation struct {
	mock               *EncoderMock
	params             *EncoderMockOpenNamespaceParams
	paramPtrs          *EncoderMockOpenNamespaceParamPtrs
	expectationOrigins EncoderMockOpenNamespaceExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// EncoderMockOpenNamespaceParams contains parameters of the Encoder.OpenNamespace
type EncoderMockOpenNamespaceParams struct {
	key string
}

// EncoderMockOpenNamespaceParamPtrs contains pointers to parameters of the Encoder.OpenNamespace
type EncoderMockOpenNamespaceParamPtrs struct {
	key *string
}

// EncoderMockOpenNamespaceOrigins contains origins of expectations of the Encoder.OpenNamespace
type EncoderMockOpenNamespaceExpectationOrigins struct {
	origin    string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOpenNamespace *mEncoderMockOpenNamespace) Optional() *mEncoderMockOpenNamespace {
	mmOpenNamespace.optional = true
	return mmOpenNamespace
}

// Expect sets up expected params for Encoder.OpenNamespace
func (mmOpenNamespace *mEncoderMockOpenNamespace) Expect(key string) *mEncoderMockOpenNamespace {
	if mmOpenNamespace.mock.funcOpenNamespace != nil {
		mmOpenNamespace.mock.t.Fatalf("EncoderMock.OpenNamespace mock is already set by Set")
	}

	if mmOpenNamespace.defaultExpectation == nil {
		mmOpenNamespace.defaultExpectation = &EncoderMockOpenNamespaceExpectation{}
	}

	if mmOpenNamespace.defaultExpectation.paramPtrs != nil {
		mmOpenNamespace.mock.t.Fatalf("EncoderMock.OpenNamespace mock is already set by ExpectParams functions")
	}

	mmOpenNamespace.defaultExpectation.params = &EncoderMockOpenNamespaceParams{key}
	mmOpenNamespace.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOpenNamespace.expectations {
		if minimock.Equal(e.params, mmOpenNamespace.defaultExpectation.params) {
			mmOpenNamespace.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpenNamespace.defaultExpectation.params)
		}
	}

	return mmOpenNamespace
}

// ExpectKeyParam1 sets up expected param key for Encoder.OpenNamespace
func (mmOpenNamespace *mEncoderMockOpenNamespace) ExpectKeyParam1(key string) *mEncoderMockOpenNamespace {
	if mmOpenNamespace.mock.funcOpenNamespace != nil {
		mmOpenNamespace.mock.t.Fatalf("EncoderMock.OpenNamespace mock is already set by Set")
	}

	if mmOpenNamespace.defaultExpectation == nil {
		mmOpenNamespace.defaultExpectation = &EncoderMockOpenNamespaceExpectation{}
	}

	if mmOpenNamespace.defaultExpectation.params != nil {
		mmOpenNamespace.mock.t.Fatalf("EncoderMock.OpenNamespace mock is already set by Expect")
	}

	if mmOpenNamespace.defaultExpectation.paramPtrs == nil {
		mmOpenNamespace.defaultExpectation.paramPtrs = &EncoderMockOpenNamespaceParamPtrs{}
	}
	mmOpenNamespace.defaultExpectation.paramPtrs.key = &key
	mmOpenNamespace.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmOpenNamespace
}

// Inspect accepts an inspector function that has same arguments as the Encoder.OpenNamespace
func (mmOpenNamespace *mEncoderMockOpenNamespace) Inspect(f func(key string)) *mEncoderMockOpenNamespace {
	if mmOpenNamespace.mock.inspectFuncOpenNamespace != nil {
		mmOpenNamespace.mock.t.Fatalf("Inspect function is already set for EncoderMock.OpenNamespace")
	}

	mmOpenNamespace.mock.inspectFuncOpenNamespace = f

	return mmOpenNamespace
}

// Return sets up results that will be returned by Encoder.OpenNamespace
func (mmOpenNamespace *mEncoderMockOpenNamespace) Return() *EncoderMock {
	if mmOpenNamespace.mock.funcOpenNamespace != nil {
		mmOpenNamespace.mock.t.Fatalf("EncoderMock.OpenNamespace mock is already set by Set")
	}

	if mmOpenNamespace.defaultExpectation == nil {
		mmOpenNamespace.defaultExpectation = &EncoderMockOpenNamespaceExpectation{mock: mmOpenNamespace.mock}
	}

	mmOpenNamespace.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOpenNamespace.mock
}

// Set uses given function f to mock the Encoder.OpenNamespace method
func (mmOpenNamespace *mEncoderMockOpenNamespace) Set(f func(key string)) *EncoderMock {
	if mmOpenNamespace.defaultExpectation != nil {
		mmOpenNamespace.mock.t.Fatalf("Default expectation is already set for the Encoder.OpenNamespace method")
	}

	if len(mmOpenNamespace.expectations) > 0 {
		mmOpenNamespace.mock.t.Fatalf("Some expectations are already set for the Encoder.OpenNamespace method")
	}

	mmOpenNamespace.mock.funcOpenNamespace = f
	mmOpenNamespace.mock.funcOpenNamespaceOrigin = minimock.CallerInfo(1)
	return mmOpenNamespace.mock
}

// Times sets number of times Encoder.OpenNamespace should be invoked
func (mmOpenNamespace *mEncoderMockOpenNamespace) Times(n uint64) *mEncoderMockOpenNamespace {
	if n == 0 {
		mmOpenNamespace.mock.t.Fatalf("Times of EncoderMock.OpenNamespace mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOpenNamespace.expectedInvocations, n)
	mmOpenNamespace.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOpenNamespace
}

func (mmOpenNamespace *mEncoderMockOpenNamespace) invocationsDone() bool {
	if len(mmOpenNamespace.expectations) == 0 && mmOpenNamespace.defaultExpectation == nil && mmOpenNamespace.mock.funcOpenNamespace == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOpenNamespace.mock.afterOpenNamespaceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOpenNamespace.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OpenNamespace implements Encoder
func (mmOpenNamespace *EncoderMock) OpenNamespace(key string) {
	mm_atomic.AddUint64(&mmOpenNamespace.beforeOpenNamespaceCounter, 1)
	defer mm_atomic.AddUint64(&mmOpenNamespace.afterOpenNamespaceCounter, 1)

	mmOpenNamespace.t.Helper()

	if mmOpenNamespace.inspectFuncOpenNamespace != nil {
		mmOpenNamespace.inspectFuncOpenNamespace(key)
	}

	mm_params := EncoderMockOpenNamespaceParams{key}

	// Record call args
	mmOpenNamespace.OpenNamespaceMock.mutex.Lock()
	mmOpenNamespace.OpenNamespaceMock.callArgs = append(mmOpenNamespace.OpenNamespaceMock.callArgs, &mm_params)
	mmOpenNamespace.OpenNamespaceMock.mutex.Unlock()

	for _, e := range mmOpenNamespace.OpenNamespaceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOpenNamespace.OpenNamespaceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpenNamespace.OpenNamespaceMock.defaultExpectation.Counter, 1)
		mm_want := mmOpenNamespace.OpenNamespaceMock.defaultExpectation.params
		mm_want_ptrs := mmOpenNamespace.OpenNamespaceMock.defaultExpectation.paramPtrs

		mm_got := EncoderMockOpenNamespaceParams{key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmOpenNamespace.t.Errorf("EncoderMock.OpenNamespace got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOpenNamespace.OpenNamespaceMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpenNamespace.t.Errorf("EncoderMock.OpenNamespace got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOpenNamespace.OpenNamespaceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmOpenNamespace.funcOpenNamespace != nil {
		mmOpenNamespace.funcOpenNamespace(key)
		return
	}
	mmOpenNamespace.t.Fatalf("Unexpected call to EncoderMock.OpenNamespace. %v", key)

}

// OpenNamespaceAfterCounter returns a count of finished EncoderMock.OpenNamespace invocations
func (mmOpenNamespace *EncoderMock) OpenNamespaceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenNamespace.afterOpenNamespaceCounter)
}

// OpenNamespaceBeforeCounter returns a count of EncoderMock.OpenNamespace invocations
func (mmOpenNamespace *EncoderMock) OpenNamespaceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenNamespace.beforeOpenNamespaceCounter)
}

// Calls returns a list of arguments used in each call to EncoderMock.OpenNamespace.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpenNamespace *mEncoderMockOpenNamespace) Calls() []*EncoderMockOpenNamespaceParams {
	mmOpenNamespace.mutex.RLock()

	argCopy := make([]*EncoderMockOpenNamespaceParams, len(mmOpenNamespace.callArgs))
	copy(argCopy, mmOpenNamespace.callArgs)

	mmOpenNamespace.mutex.RUnlock()

	return argCopy
}

// MinimockOpenNamespaceDone returns true if the count of the OpenNamespace invocations corresponds
// the number of defined expectations
func (m *EncoderMock) MinimockOpenNamespaceDone() bool {
	if m.OpenNamespaceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OpenNamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OpenNamespaceMock.invocationsDone()
}

// MinimockOpenNamespaceInspect logs each unmet expectation
func (m *EncoderMock) MinimockOpenNamespaceInspect() {
	for _, e := range m.OpenNamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EncoderMock.OpenNamespace at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOpenNamespaceCounter := mm_atomic.LoadUint64(&m.afterOpenNamespaceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OpenNamespaceMock.defaultExpectation != nil && afterOpenNamespaceCounter < 1 {
		if m.OpenNamespaceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EncoderMock.OpenNamespace at\n%s", m.OpenNamespaceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EncoderMock.OpenNamespace at\n%s with params: %#v", m.OpenNamespaceMock.defaultExpectation.expectationOrigins.origin, *m.OpenNamespaceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenNamespace != nil && afterOpenNamespaceCounter < 1 {
		m.t.Errorf("Expected call to EncoderMock.OpenNamespace at\n%s", m.funcOpenNamespaceOrigin)
	}

	if !m.OpenNamespaceMock.invocationsDone() && afterOpenNamespaceCounter > 0 {
		m.t.Errorf("Expected %d calls to EncoderMock.OpenNamespace at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OpenNamespaceMock.expectedInvocations), m.OpenNamespaceMock.expectedInvocationsOrigin, afterOpenNamespaceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EncoderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddArrayInspect()

			m.MinimockAddBinaryInspect()

			m.MinimockAddBoolInspect()

			m.MinimockAddByteStringInspect()

			m.MinimockAddComplex128Inspect()

			m.MinimockAddComplex64Inspect()

			m.MinimockAddDurationInspect()

			m.MinimockAddFloat32Inspect()

			m.MinimockAddFloat64Inspect()

			m.MinimockAddIntInspect()

			m.MinimockAddInt16Inspect()

			m.MinimockAddInt32Inspect()

			m.MinimockAddInt64Inspect()

			m.MinimockAddInt8Inspect()

			m.MinimockAddObjectInspect()

			m.MinimockAddReflectedInspect()

			m.MinimockAddStringInspect()

			m.MinimockAddTimeInspect()

			m.MinimockAddUintInspect()

			m.MinimockAddUint16Inspect()

			m.MinimockAddUint32Inspect()

			m.MinimockAddUint64Inspect()

			m.MinimockAddUint8Inspect()

			m.MinimockAddUintptrInspect()

			m.MinimockCloneInspect()

			m.MinimockEncodeEntryInspect()

			m.MinimockOpenNamespaceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EncoderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EncoderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddArrayDone() &&
		m.MinimockAddBinaryDone() &&
		m.MinimockAddBoolDone() &&
		m.MinimockAddByteStringDone() &&
		m.MinimockAddComplex128Done() &&
		m.MinimockAddComplex64Done() &&
		m.MinimockAddDurationDone() &&
		m.MinimockAddFloat32Done() &&
		m.MinimockAddFloat64Done() &&
		m.MinimockAddIntDone() &&
		m.MinimockAddInt16Done() &&
		m.MinimockAddInt32Done() &&
		m.MinimockAddInt64Done() &&
		m.MinimockAddInt8Done() &&
		m.MinimockAddObjectDone() &&
		m.MinimockAddReflectedDone() &&
		m.MinimockAddStringDone() &&
		m.MinimockAddTimeDone() &&
		m.MinimockAddUintDone() &&
		m.MinimockAddUint16Done() &&
		m.MinimockAddUint32Done() &&
		m.MinimockAddUint64Done() &&
		m.MinimockAddUint8Done() &&
		m.MinimockAddUintptrDone() &&
		m.MinimockCloneDone() &&
		m.MinimockEncodeEntryDone() &&
		m.MinimockOpenNamespaceDone()
}
