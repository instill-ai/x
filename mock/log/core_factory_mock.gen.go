// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package log

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.uber.org/zap/zapcore"
)

// CoreFactoryMock implements CoreFactory
type CoreFactoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcNewCore          func(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler) (c1 zapcore.Core)
	funcNewCoreOrigin    string
	inspectFuncNewCore   func(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler)
	afterNewCoreCounter  uint64
	beforeNewCoreCounter uint64
	NewCoreMock          mCoreFactoryMockNewCore
}

// NewCoreFactoryMock returns a mock for CoreFactory
func NewCoreFactoryMock(t minimock.Tester) *CoreFactoryMock {
	m := &CoreFactoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NewCoreMock = mCoreFactoryMockNewCore{mock: m}
	m.NewCoreMock.callArgs = []*CoreFactoryMockNewCoreParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCoreFactoryMockNewCore struct {
	optional           bool
	mock               *CoreFactoryMock
	defaultExpectation *CoreFactoryMockNewCoreExpectation
	expectations       []*CoreFactoryMockNewCoreExpectation

	callArgs []*CoreFactoryMockNewCoreParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreFactoryMockNewCoreExpectation specifies expectation struct of the CoreFactory.NewCore
type CoreFactoryMockNewCoreExpectation struct {
	mock               *CoreFactoryMock
	params             *CoreFactoryMockNewCoreParams
	paramPtrs          *CoreFactoryMockNewCoreParamPtrs
	expectationOrigins CoreFactoryMockNewCoreExpectationOrigins
	results            *CoreFactoryMockNewCoreResults
	returnOrigin       string
	Counter            uint64
}

// CoreFactoryMockNewCoreParams contains parameters of the CoreFactory.NewCore
type CoreFactoryMockNewCoreParams struct {
	encoder zapcore.Encoder
	syncer  zapcore.WriteSyncer
	level   zapcore.LevelEnabler
}

// CoreFactoryMockNewCoreParamPtrs contains pointers to parameters of the CoreFactory.NewCore
type CoreFactoryMockNewCoreParamPtrs struct {
	encoder *zapcore.Encoder
	syncer  *zapcore.WriteSyncer
	level   *zapcore.LevelEnabler
}

// CoreFactoryMockNewCoreResults contains results of the CoreFactory.NewCore
type CoreFactoryMockNewCoreResults struct {
	c1 zapcore.Core
}

// CoreFactoryMockNewCoreOrigins contains origins of expectations of the CoreFactory.NewCore
type CoreFactoryMockNewCoreExpectationOrigins struct {
	origin        string
	originEncoder string
	originSyncer  string
	originLevel   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewCore *mCoreFactoryMockNewCore) Optional() *mCoreFactoryMockNewCore {
	mmNewCore.optional = true
	return mmNewCore
}

// Expect sets up expected params for CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) Expect(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler) *mCoreFactoryMockNewCore {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	if mmNewCore.defaultExpectation == nil {
		mmNewCore.defaultExpectation = &CoreFactoryMockNewCoreExpectation{}
	}

	if mmNewCore.defaultExpectation.paramPtrs != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by ExpectParams functions")
	}

	mmNewCore.defaultExpectation.params = &CoreFactoryMockNewCoreParams{encoder, syncer, level}
	mmNewCore.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewCore.expectations {
		if minimock.Equal(e.params, mmNewCore.defaultExpectation.params) {
			mmNewCore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewCore.defaultExpectation.params)
		}
	}

	return mmNewCore
}

// ExpectEncoderParam1 sets up expected param encoder for CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) ExpectEncoderParam1(encoder zapcore.Encoder) *mCoreFactoryMockNewCore {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	if mmNewCore.defaultExpectation == nil {
		mmNewCore.defaultExpectation = &CoreFactoryMockNewCoreExpectation{}
	}

	if mmNewCore.defaultExpectation.params != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Expect")
	}

	if mmNewCore.defaultExpectation.paramPtrs == nil {
		mmNewCore.defaultExpectation.paramPtrs = &CoreFactoryMockNewCoreParamPtrs{}
	}
	mmNewCore.defaultExpectation.paramPtrs.encoder = &encoder
	mmNewCore.defaultExpectation.expectationOrigins.originEncoder = minimock.CallerInfo(1)

	return mmNewCore
}

// ExpectSyncerParam2 sets up expected param syncer for CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) ExpectSyncerParam2(syncer zapcore.WriteSyncer) *mCoreFactoryMockNewCore {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	if mmNewCore.defaultExpectation == nil {
		mmNewCore.defaultExpectation = &CoreFactoryMockNewCoreExpectation{}
	}

	if mmNewCore.defaultExpectation.params != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Expect")
	}

	if mmNewCore.defaultExpectation.paramPtrs == nil {
		mmNewCore.defaultExpectation.paramPtrs = &CoreFactoryMockNewCoreParamPtrs{}
	}
	mmNewCore.defaultExpectation.paramPtrs.syncer = &syncer
	mmNewCore.defaultExpectation.expectationOrigins.originSyncer = minimock.CallerInfo(1)

	return mmNewCore
}

// ExpectLevelParam3 sets up expected param level for CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) ExpectLevelParam3(level zapcore.LevelEnabler) *mCoreFactoryMockNewCore {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	if mmNewCore.defaultExpectation == nil {
		mmNewCore.defaultExpectation = &CoreFactoryMockNewCoreExpectation{}
	}

	if mmNewCore.defaultExpectation.params != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Expect")
	}

	if mmNewCore.defaultExpectation.paramPtrs == nil {
		mmNewCore.defaultExpectation.paramPtrs = &CoreFactoryMockNewCoreParamPtrs{}
	}
	mmNewCore.defaultExpectation.paramPtrs.level = &level
	mmNewCore.defaultExpectation.expectationOrigins.originLevel = minimock.CallerInfo(1)

	return mmNewCore
}

// Inspect accepts an inspector function that has same arguments as the CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) Inspect(f func(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler)) *mCoreFactoryMockNewCore {
	if mmNewCore.mock.inspectFuncNewCore != nil {
		mmNewCore.mock.t.Fatalf("Inspect function is already set for CoreFactoryMock.NewCore")
	}

	mmNewCore.mock.inspectFuncNewCore = f

	return mmNewCore
}

// Return sets up results that will be returned by CoreFactory.NewCore
func (mmNewCore *mCoreFactoryMockNewCore) Return(c1 zapcore.Core) *CoreFactoryMock {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	if mmNewCore.defaultExpectation == nil {
		mmNewCore.defaultExpectation = &CoreFactoryMockNewCoreExpectation{mock: mmNewCore.mock}
	}
	mmNewCore.defaultExpectation.results = &CoreFactoryMockNewCoreResults{c1}
	mmNewCore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewCore.mock
}

// Set uses given function f to mock the CoreFactory.NewCore method
func (mmNewCore *mCoreFactoryMockNewCore) Set(f func(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler) (c1 zapcore.Core)) *CoreFactoryMock {
	if mmNewCore.defaultExpectation != nil {
		mmNewCore.mock.t.Fatalf("Default expectation is already set for the CoreFactory.NewCore method")
	}

	if len(mmNewCore.expectations) > 0 {
		mmNewCore.mock.t.Fatalf("Some expectations are already set for the CoreFactory.NewCore method")
	}

	mmNewCore.mock.funcNewCore = f
	mmNewCore.mock.funcNewCoreOrigin = minimock.CallerInfo(1)
	return mmNewCore.mock
}

// When sets expectation for the CoreFactory.NewCore which will trigger the result defined by the following
// Then helper
func (mmNewCore *mCoreFactoryMockNewCore) When(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler) *CoreFactoryMockNewCoreExpectation {
	if mmNewCore.mock.funcNewCore != nil {
		mmNewCore.mock.t.Fatalf("CoreFactoryMock.NewCore mock is already set by Set")
	}

	expectation := &CoreFactoryMockNewCoreExpectation{
		mock:               mmNewCore.mock,
		params:             &CoreFactoryMockNewCoreParams{encoder, syncer, level},
		expectationOrigins: CoreFactoryMockNewCoreExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewCore.expectations = append(mmNewCore.expectations, expectation)
	return expectation
}

// Then sets up CoreFactory.NewCore return parameters for the expectation previously defined by the When method
func (e *CoreFactoryMockNewCoreExpectation) Then(c1 zapcore.Core) *CoreFactoryMock {
	e.results = &CoreFactoryMockNewCoreResults{c1}
	return e.mock
}

// Times sets number of times CoreFactory.NewCore should be invoked
func (mmNewCore *mCoreFactoryMockNewCore) Times(n uint64) *mCoreFactoryMockNewCore {
	if n == 0 {
		mmNewCore.mock.t.Fatalf("Times of CoreFactoryMock.NewCore mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewCore.expectedInvocations, n)
	mmNewCore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewCore
}

func (mmNewCore *mCoreFactoryMockNewCore) invocationsDone() bool {
	if len(mmNewCore.expectations) == 0 && mmNewCore.defaultExpectation == nil && mmNewCore.mock.funcNewCore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewCore.mock.afterNewCoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewCore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewCore implements CoreFactory
func (mmNewCore *CoreFactoryMock) NewCore(encoder zapcore.Encoder, syncer zapcore.WriteSyncer, level zapcore.LevelEnabler) (c1 zapcore.Core) {
	mm_atomic.AddUint64(&mmNewCore.beforeNewCoreCounter, 1)
	defer mm_atomic.AddUint64(&mmNewCore.afterNewCoreCounter, 1)

	mmNewCore.t.Helper()

	if mmNewCore.inspectFuncNewCore != nil {
		mmNewCore.inspectFuncNewCore(encoder, syncer, level)
	}

	mm_params := CoreFactoryMockNewCoreParams{encoder, syncer, level}

	// Record call args
	mmNewCore.NewCoreMock.mutex.Lock()
	mmNewCore.NewCoreMock.callArgs = append(mmNewCore.NewCoreMock.callArgs, &mm_params)
	mmNewCore.NewCoreMock.mutex.Unlock()

	for _, e := range mmNewCore.NewCoreMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmNewCore.NewCoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewCore.NewCoreMock.defaultExpectation.Counter, 1)
		mm_want := mmNewCore.NewCoreMock.defaultExpectation.params
		mm_want_ptrs := mmNewCore.NewCoreMock.defaultExpectation.paramPtrs

		mm_got := CoreFactoryMockNewCoreParams{encoder, syncer, level}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.encoder != nil && !minimock.Equal(*mm_want_ptrs.encoder, mm_got.encoder) {
				mmNewCore.t.Errorf("CoreFactoryMock.NewCore got unexpected parameter encoder, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewCore.NewCoreMock.defaultExpectation.expectationOrigins.originEncoder, *mm_want_ptrs.encoder, mm_got.encoder, minimock.Diff(*mm_want_ptrs.encoder, mm_got.encoder))
			}

			if mm_want_ptrs.syncer != nil && !minimock.Equal(*mm_want_ptrs.syncer, mm_got.syncer) {
				mmNewCore.t.Errorf("CoreFactoryMock.NewCore got unexpected parameter syncer, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewCore.NewCoreMock.defaultExpectation.expectationOrigins.originSyncer, *mm_want_ptrs.syncer, mm_got.syncer, minimock.Diff(*mm_want_ptrs.syncer, mm_got.syncer))
			}

			if mm_want_ptrs.level != nil && !minimock.Equal(*mm_want_ptrs.level, mm_got.level) {
				mmNewCore.t.Errorf("CoreFactoryMock.NewCore got unexpected parameter level, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewCore.NewCoreMock.defaultExpectation.expectationOrigins.originLevel, *mm_want_ptrs.level, mm_got.level, minimock.Diff(*mm_want_ptrs.level, mm_got.level))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewCore.t.Errorf("CoreFactoryMock.NewCore got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewCore.NewCoreMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewCore.NewCoreMock.defaultExpectation.results
		if mm_results == nil {
			mmNewCore.t.Fatal("No results are set for the CoreFactoryMock.NewCore")
		}
		return (*mm_results).c1
	}
	if mmNewCore.funcNewCore != nil {
		return mmNewCore.funcNewCore(encoder, syncer, level)
	}
	mmNewCore.t.Fatalf("Unexpected call to CoreFactoryMock.NewCore. %v %v %v", encoder, syncer, level)
	return
}

// NewCoreAfterCounter returns a count of finished CoreFactoryMock.NewCore invocations
func (mmNewCore *CoreFactoryMock) NewCoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewCore.afterNewCoreCounter)
}

// NewCoreBeforeCounter returns a count of CoreFactoryMock.NewCore invocations
func (mmNewCore *CoreFactoryMock) NewCoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewCore.beforeNewCoreCounter)
}

// Calls returns a list of arguments used in each call to CoreFactoryMock.NewCore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewCore *mCoreFactoryMockNewCore) Calls() []*CoreFactoryMockNewCoreParams {
	mmNewCore.mutex.RLock()

	argCopy := make([]*CoreFactoryMockNewCoreParams, len(mmNewCore.callArgs))
	copy(argCopy, mmNewCore.callArgs)

	mmNewCore.mutex.RUnlock()

	return argCopy
}

// MinimockNewCoreDone returns true if the count of the NewCore invocations corresponds
// the number of defined expectations
func (m *CoreFactoryMock) MinimockNewCoreDone() bool {
	if m.NewCoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewCoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewCoreMock.invocationsDone()
}

// MinimockNewCoreInspect logs each unmet expectation
func (m *CoreFactoryMock) MinimockNewCoreInspect() {
	for _, e := range m.NewCoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreFactoryMock.NewCore at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewCoreCounter := mm_atomic.LoadUint64(&m.afterNewCoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewCoreMock.defaultExpectation != nil && afterNewCoreCounter < 1 {
		if m.NewCoreMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreFactoryMock.NewCore at\n%s", m.NewCoreMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreFactoryMock.NewCore at\n%s with params: %#v", m.NewCoreMock.defaultExpectation.expectationOrigins.origin, *m.NewCoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewCore != nil && afterNewCoreCounter < 1 {
		m.t.Errorf("Expected call to CoreFactoryMock.NewCore at\n%s", m.funcNewCoreOrigin)
	}

	if !m.NewCoreMock.invocationsDone() && afterNewCoreCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreFactoryMock.NewCore at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewCoreMock.expectedInvocations), m.NewCoreMock.expectedInvocationsOrigin, afterNewCoreCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CoreFactoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockNewCoreInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CoreFactoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CoreFactoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNewCoreDone()
}
