// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package minio

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	mm_minio "github.com/instill-ai/x/minio"
	miniogo "github.com/minio/minio-go/v7"
	"go.uber.org/zap"
)

// ClientMock implements mm_minio.Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClient          func() (cp1 *miniogo.Client)
	funcClientOrigin    string
	inspectFuncClient   func()
	afterClientCounter  uint64
	beforeClientCounter uint64
	ClientMock          mClientMockClient

	funcDeleteFile          func(ctx context.Context, userUID uuid.UUID, filePath string) (err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, userUID uuid.UUID, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mClientMockDeleteFile

	funcGetFile          func(ctx context.Context, userUID uuid.UUID, filePath string) (ba1 []byte, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, userUID uuid.UUID, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mClientMockGetFile

	funcGetFilesByPaths          func(ctx context.Context, userUID uuid.UUID, filePaths []string) (fa1 []mm_minio.FileContent, err error)
	funcGetFilesByPathsOrigin    string
	inspectFuncGetFilesByPaths   func(ctx context.Context, userUID uuid.UUID, filePaths []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mClientMockGetFilesByPaths

	funcUploadFile          func(ctx context.Context, up1 *mm_minio.UploadFileParam) (url string, objectInfo *miniogo.ObjectInfo, err error)
	funcUploadFileOrigin    string
	inspectFuncUploadFile   func(ctx context.Context, up1 *mm_minio.UploadFileParam)
	afterUploadFileCounter  uint64
	beforeUploadFileCounter uint64
	UploadFileMock          mClientMockUploadFile

	funcUploadFileBytes          func(ctx context.Context, up1 *mm_minio.UploadFileBytesParam) (url string, objectInfo *miniogo.ObjectInfo, err error)
	funcUploadFileBytesOrigin    string
	inspectFuncUploadFileBytes   func(ctx context.Context, up1 *mm_minio.UploadFileBytesParam)
	afterUploadFileBytesCounter  uint64
	beforeUploadFileBytesCounter uint64
	UploadFileBytesMock          mClientMockUploadFileBytes

	funcUploadPrivateFileBytes          func(ctx context.Context, u1 mm_minio.UploadFileBytesParam) (err error)
	funcUploadPrivateFileBytesOrigin    string
	inspectFuncUploadPrivateFileBytes   func(ctx context.Context, u1 mm_minio.UploadFileBytesParam)
	afterUploadPrivateFileBytesCounter  uint64
	beforeUploadPrivateFileBytesCounter uint64
	UploadPrivateFileBytesMock          mClientMockUploadPrivateFileBytes

	funcWithLogger          func(lp1 *zap.Logger) (c1 mm_minio.Client)
	funcWithLoggerOrigin    string
	inspectFuncWithLogger   func(lp1 *zap.Logger)
	afterWithLoggerCounter  uint64
	beforeWithLoggerCounter uint64
	WithLoggerMock          mClientMockWithLogger
}

// NewClientMock returns a mock for mm_minio.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClientMock = mClientMockClient{mock: m}

	m.DeleteFileMock = mClientMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*ClientMockDeleteFileParams{}

	m.GetFileMock = mClientMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*ClientMockGetFileParams{}

	m.GetFilesByPathsMock = mClientMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*ClientMockGetFilesByPathsParams{}

	m.UploadFileMock = mClientMockUploadFile{mock: m}
	m.UploadFileMock.callArgs = []*ClientMockUploadFileParams{}

	m.UploadFileBytesMock = mClientMockUploadFileBytes{mock: m}
	m.UploadFileBytesMock.callArgs = []*ClientMockUploadFileBytesParams{}

	m.UploadPrivateFileBytesMock = mClientMockUploadPrivateFileBytes{mock: m}
	m.UploadPrivateFileBytesMock.callArgs = []*ClientMockUploadPrivateFileBytesParams{}

	m.WithLoggerMock = mClientMockWithLogger{mock: m}
	m.WithLoggerMock.callArgs = []*ClientMockWithLoggerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockClient struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockClientExpectation
	expectations       []*ClientMockClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockClientExpectation specifies expectation struct of the Client.Client
type ClientMockClientExpectation struct {
	mock *ClientMock

	results      *ClientMockClientResults
	returnOrigin string
	Counter      uint64
}

// ClientMockClientResults contains results of the Client.Client
type ClientMockClientResults struct {
	cp1 *miniogo.Client
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClient *mClientMockClient) Optional() *mClientMockClient {
	mmClient.optional = true
	return mmClient
}

// Expect sets up expected params for Client.Client
func (mmClient *mClientMockClient) Expect() *mClientMockClient {
	if mmClient.mock.funcClient != nil {
		mmClient.mock.t.Fatalf("ClientMock.Client mock is already set by Set")
	}

	if mmClient.defaultExpectation == nil {
		mmClient.defaultExpectation = &ClientMockClientExpectation{}
	}

	return mmClient
}

// Inspect accepts an inspector function that has same arguments as the Client.Client
func (mmClient *mClientMockClient) Inspect(f func()) *mClientMockClient {
	if mmClient.mock.inspectFuncClient != nil {
		mmClient.mock.t.Fatalf("Inspect function is already set for ClientMock.Client")
	}

	mmClient.mock.inspectFuncClient = f

	return mmClient
}

// Return sets up results that will be returned by Client.Client
func (mmClient *mClientMockClient) Return(cp1 *miniogo.Client) *ClientMock {
	if mmClient.mock.funcClient != nil {
		mmClient.mock.t.Fatalf("ClientMock.Client mock is already set by Set")
	}

	if mmClient.defaultExpectation == nil {
		mmClient.defaultExpectation = &ClientMockClientExpectation{mock: mmClient.mock}
	}
	mmClient.defaultExpectation.results = &ClientMockClientResults{cp1}
	mmClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClient.mock
}

// Set uses given function f to mock the Client.Client method
func (mmClient *mClientMockClient) Set(f func() (cp1 *miniogo.Client)) *ClientMock {
	if mmClient.defaultExpectation != nil {
		mmClient.mock.t.Fatalf("Default expectation is already set for the Client.Client method")
	}

	if len(mmClient.expectations) > 0 {
		mmClient.mock.t.Fatalf("Some expectations are already set for the Client.Client method")
	}

	mmClient.mock.funcClient = f
	mmClient.mock.funcClientOrigin = minimock.CallerInfo(1)
	return mmClient.mock
}

// Times sets number of times Client.Client should be invoked
func (mmClient *mClientMockClient) Times(n uint64) *mClientMockClient {
	if n == 0 {
		mmClient.mock.t.Fatalf("Times of ClientMock.Client mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClient.expectedInvocations, n)
	mmClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClient
}

func (mmClient *mClientMockClient) invocationsDone() bool {
	if len(mmClient.expectations) == 0 && mmClient.defaultExpectation == nil && mmClient.mock.funcClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClient.mock.afterClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Client implements mm_minio.Client
func (mmClient *ClientMock) Client() (cp1 *miniogo.Client) {
	mm_atomic.AddUint64(&mmClient.beforeClientCounter, 1)
	defer mm_atomic.AddUint64(&mmClient.afterClientCounter, 1)

	mmClient.t.Helper()

	if mmClient.inspectFuncClient != nil {
		mmClient.inspectFuncClient()
	}

	if mmClient.ClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClient.ClientMock.defaultExpectation.Counter, 1)

		mm_results := mmClient.ClientMock.defaultExpectation.results
		if mm_results == nil {
			mmClient.t.Fatal("No results are set for the ClientMock.Client")
		}
		return (*mm_results).cp1
	}
	if mmClient.funcClient != nil {
		return mmClient.funcClient()
	}
	mmClient.t.Fatalf("Unexpected call to ClientMock.Client.")
	return
}

// ClientAfterCounter returns a count of finished ClientMock.Client invocations
func (mmClient *ClientMock) ClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClient.afterClientCounter)
}

// ClientBeforeCounter returns a count of ClientMock.Client invocations
func (mmClient *ClientMock) ClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClient.beforeClientCounter)
}

// MinimockClientDone returns true if the count of the Client invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockClientDone() bool {
	if m.ClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClientMock.invocationsDone()
}

// MinimockClientInspect logs each unmet expectation
func (m *ClientMock) MinimockClientInspect() {
	for _, e := range m.ClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Client")
		}
	}

	afterClientCounter := mm_atomic.LoadUint64(&m.afterClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClientMock.defaultExpectation != nil && afterClientCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Client at\n%s", m.ClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClient != nil && afterClientCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Client at\n%s", m.funcClientOrigin)
	}

	if !m.ClientMock.invocationsDone() && afterClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Client at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClientMock.expectedInvocations), m.ClientMock.expectedInvocationsOrigin, afterClientCounter)
	}
}

type mClientMockDeleteFile struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteFileExpectation
	expectations       []*ClientMockDeleteFileExpectation

	callArgs []*ClientMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteFileExpectation specifies expectation struct of the Client.DeleteFile
type ClientMockDeleteFileExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteFileParams
	paramPtrs          *ClientMockDeleteFileParamPtrs
	expectationOrigins ClientMockDeleteFileExpectationOrigins
	results            *ClientMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteFileParams contains parameters of the Client.DeleteFile
type ClientMockDeleteFileParams struct {
	ctx      context.Context
	userUID  uuid.UUID
	filePath string
}

// ClientMockDeleteFileParamPtrs contains pointers to parameters of the Client.DeleteFile
type ClientMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	userUID  *uuid.UUID
	filePath *string
}

// ClientMockDeleteFileResults contains results of the Client.DeleteFile
type ClientMockDeleteFileResults struct {
	err error
}

// ClientMockDeleteFileOrigins contains origins of expectations of the Client.DeleteFile
type ClientMockDeleteFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserUID  string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mClientMockDeleteFile) Optional() *mClientMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) Expect(ctx context.Context, userUID uuid.UUID, filePath string) *mClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &ClientMockDeleteFileParams{ctx, userUID, filePath}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectUserUIDParam2 sets up expected param userUID for Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) ExpectUserUIDParam2(userUID uuid.UUID) *mClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.userUID = &userUID
	mmDeleteFile.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectFilePathParam3 sets up expected param filePath for Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) ExpectFilePathParam3(filePath string) *mClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmDeleteFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) Inspect(f func(ctx context.Context, userUID uuid.UUID, filePath string)) *mClientMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by Client.DeleteFile
func (mmDeleteFile *mClientMockDeleteFile) Return(err error) *ClientMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ClientMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &ClientMockDeleteFileResults{err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the Client.DeleteFile method
func (mmDeleteFile *mClientMockDeleteFile) Set(f func(ctx context.Context, userUID uuid.UUID, filePath string) (err error)) *ClientMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the Client.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the Client.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the Client.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mClientMockDeleteFile) When(ctx context.Context, userUID uuid.UUID, filePath string) *ClientMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ClientMock.DeleteFile mock is already set by Set")
	}

	expectation := &ClientMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &ClientMockDeleteFileParams{ctx, userUID, filePath},
		expectationOrigins: ClientMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteFile return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteFileExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteFile should be invoked
func (mmDeleteFile *mClientMockDeleteFile) Times(n uint64) *mClientMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of ClientMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mClientMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_minio.Client
func (mmDeleteFile *ClientMock) DeleteFile(ctx context.Context, userUID uuid.UUID, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, userUID, filePath)
	}

	mm_params := ClientMockDeleteFileParams{ctx, userUID, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteFileParams{ctx, userUID, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("ClientMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmDeleteFile.t.Errorf("ClientMock.DeleteFile got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("ClientMock.DeleteFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("ClientMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the ClientMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, userUID, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to ClientMock.DeleteFile. %v %v %v", ctx, userUID, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished ClientMock.DeleteFile invocations
func (mmDeleteFile *ClientMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of ClientMock.DeleteFile invocations
func (mmDeleteFile *ClientMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mClientMockDeleteFile) Calls() []*ClientMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*ClientMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mClientMockGetFile struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetFileExpectation
	expectations       []*ClientMockGetFileExpectation

	callArgs []*ClientMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetFileExpectation specifies expectation struct of the Client.GetFile
type ClientMockGetFileExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetFileParams
	paramPtrs          *ClientMockGetFileParamPtrs
	expectationOrigins ClientMockGetFileExpectationOrigins
	results            *ClientMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetFileParams contains parameters of the Client.GetFile
type ClientMockGetFileParams struct {
	ctx      context.Context
	userUID  uuid.UUID
	filePath string
}

// ClientMockGetFileParamPtrs contains pointers to parameters of the Client.GetFile
type ClientMockGetFileParamPtrs struct {
	ctx      *context.Context
	userUID  *uuid.UUID
	filePath *string
}

// ClientMockGetFileResults contains results of the Client.GetFile
type ClientMockGetFileResults struct {
	ba1 []byte
	err error
}

// ClientMockGetFileOrigins contains origins of expectations of the Client.GetFile
type ClientMockGetFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserUID  string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mClientMockGetFile) Optional() *mClientMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for Client.GetFile
func (mmGetFile *mClientMockGetFile) Expect(ctx context.Context, userUID uuid.UUID, filePath string) *mClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &ClientMockGetFileParams{ctx, userUID, filePath}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetFile
func (mmGetFile *mClientMockGetFile) ExpectCtxParam1(ctx context.Context) *mClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectUserUIDParam2 sets up expected param userUID for Client.GetFile
func (mmGetFile *mClientMockGetFile) ExpectUserUIDParam2(userUID uuid.UUID) *mClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.userUID = &userUID
	mmGetFile.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectFilePathParam3 sets up expected param filePath for Client.GetFile
func (mmGetFile *mClientMockGetFile) ExpectFilePathParam3(filePath string) *mClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the Client.GetFile
func (mmGetFile *mClientMockGetFile) Inspect(f func(ctx context.Context, userUID uuid.UUID, filePath string)) *mClientMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for ClientMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by Client.GetFile
func (mmGetFile *mClientMockGetFile) Return(ba1 []byte, err error) *ClientMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ClientMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &ClientMockGetFileResults{ba1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the Client.GetFile method
func (mmGetFile *mClientMockGetFile) Set(f func(ctx context.Context, userUID uuid.UUID, filePath string) (ba1 []byte, err error)) *ClientMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the Client.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the Client.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the Client.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mClientMockGetFile) When(ctx context.Context, userUID uuid.UUID, filePath string) *ClientMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ClientMock.GetFile mock is already set by Set")
	}

	expectation := &ClientMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &ClientMockGetFileParams{ctx, userUID, filePath},
		expectationOrigins: ClientMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up Client.GetFile return parameters for the expectation previously defined by the When method
func (e *ClientMockGetFileExpectation) Then(ba1 []byte, err error) *ClientMock {
	e.results = &ClientMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times Client.GetFile should be invoked
func (mmGetFile *mClientMockGetFile) Times(n uint64) *mClientMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of ClientMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mClientMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_minio.Client
func (mmGetFile *ClientMock) GetFile(ctx context.Context, userUID uuid.UUID, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, userUID, filePath)
	}

	mm_params := ClientMockGetFileParams{ctx, userUID, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetFileParams{ctx, userUID, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("ClientMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetFile.t.Errorf("ClientMock.GetFile got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("ClientMock.GetFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("ClientMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the ClientMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, userUID, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to ClientMock.GetFile. %v %v %v", ctx, userUID, filePath)
	return
}

// GetFileAfterCounter returns a count of finished ClientMock.GetFile invocations
func (mmGetFile *ClientMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of ClientMock.GetFile invocations
func (mmGetFile *ClientMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mClientMockGetFile) Calls() []*ClientMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*ClientMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *ClientMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mClientMockGetFilesByPaths struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetFilesByPathsExpectation
	expectations       []*ClientMockGetFilesByPathsExpectation

	callArgs []*ClientMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetFilesByPathsExpectation specifies expectation struct of the Client.GetFilesByPaths
type ClientMockGetFilesByPathsExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetFilesByPathsParams
	paramPtrs          *ClientMockGetFilesByPathsParamPtrs
	expectationOrigins ClientMockGetFilesByPathsExpectationOrigins
	results            *ClientMockGetFilesByPathsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetFilesByPathsParams contains parameters of the Client.GetFilesByPaths
type ClientMockGetFilesByPathsParams struct {
	ctx       context.Context
	userUID   uuid.UUID
	filePaths []string
}

// ClientMockGetFilesByPathsParamPtrs contains pointers to parameters of the Client.GetFilesByPaths
type ClientMockGetFilesByPathsParamPtrs struct {
	ctx       *context.Context
	userUID   *uuid.UUID
	filePaths *[]string
}

// ClientMockGetFilesByPathsResults contains results of the Client.GetFilesByPaths
type ClientMockGetFilesByPathsResults struct {
	fa1 []mm_minio.FileContent
	err error
}

// ClientMockGetFilesByPathsOrigins contains origins of expectations of the Client.GetFilesByPaths
type ClientMockGetFilesByPathsExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserUID   string
	originFilePaths string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Optional() *mClientMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Expect(ctx context.Context, userUID uuid.UUID, filePaths []string) *mClientMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ClientMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &ClientMockGetFilesByPathsParams{ctx, userUID, filePaths}
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mClientMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ClientMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ClientMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectUserUIDParam2 sets up expected param userUID for Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) ExpectUserUIDParam2(userUID uuid.UUID) *mClientMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ClientMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ClientMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.userUID = &userUID
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectFilePathsParam3 sets up expected param filePaths for Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) ExpectFilePathsParam3(filePaths []string) *mClientMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ClientMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ClientMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.filePaths = &filePaths
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originFilePaths = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Inspect(f func(ctx context.Context, userUID uuid.UUID, filePaths []string)) *mClientMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for ClientMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by Client.GetFilesByPaths
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Return(fa1 []mm_minio.FileContent, err error) *ClientMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ClientMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &ClientMockGetFilesByPathsResults{fa1, err}
	mmGetFilesByPaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the Client.GetFilesByPaths method
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Set(f func(ctx context.Context, userUID uuid.UUID, filePaths []string) (fa1 []mm_minio.FileContent, err error)) *ClientMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the Client.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the Client.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	mmGetFilesByPaths.mock.funcGetFilesByPathsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// When sets expectation for the Client.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) When(ctx context.Context, userUID uuid.UUID, filePaths []string) *ClientMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ClientMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &ClientMockGetFilesByPathsExpectation{
		mock:               mmGetFilesByPaths.mock,
		params:             &ClientMockGetFilesByPathsParams{ctx, userUID, filePaths},
		expectationOrigins: ClientMockGetFilesByPathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up Client.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *ClientMockGetFilesByPathsExpectation) Then(fa1 []mm_minio.FileContent, err error) *ClientMock {
	e.results = &ClientMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times Client.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Times(n uint64) *mClientMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of ClientMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	mmGetFilesByPaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mClientMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements mm_minio.Client
func (mmGetFilesByPaths *ClientMock) GetFilesByPaths(ctx context.Context, userUID uuid.UUID, filePaths []string) (fa1 []mm_minio.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	mmGetFilesByPaths.t.Helper()

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, userUID, filePaths)
	}

	mm_params := ClientMockGetFilesByPathsParams{ctx, userUID, filePaths}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetFilesByPathsParams{ctx, userUID, filePaths}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("ClientMock.GetFilesByPaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetFilesByPaths.t.Errorf("ClientMock.GetFilesByPaths got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.filePaths != nil && !minimock.Equal(*mm_want_ptrs.filePaths, mm_got.filePaths) {
				mmGetFilesByPaths.t.Errorf("ClientMock.GetFilesByPaths got unexpected parameter filePaths, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originFilePaths, *mm_want_ptrs.filePaths, mm_got.filePaths, minimock.Diff(*mm_want_ptrs.filePaths, mm_got.filePaths))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("ClientMock.GetFilesByPaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the ClientMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, userUID, filePaths)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to ClientMock.GetFilesByPaths. %v %v %v", ctx, userUID, filePaths)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished ClientMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ClientMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of ClientMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ClientMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mClientMockGetFilesByPaths) Calls() []*ClientMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*ClientMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetFilesByPaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetFilesByPaths at\n%s", m.GetFilesByPathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetFilesByPaths at\n%s with params: %#v", m.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetFilesByPaths at\n%s", m.funcGetFilesByPathsOrigin)
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetFilesByPaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), m.GetFilesByPathsMock.expectedInvocationsOrigin, afterGetFilesByPathsCounter)
	}
}

type mClientMockUploadFile struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUploadFileExpectation
	expectations       []*ClientMockUploadFileExpectation

	callArgs []*ClientMockUploadFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUploadFileExpectation specifies expectation struct of the Client.UploadFile
type ClientMockUploadFileExpectation struct {
	mock               *ClientMock
	params             *ClientMockUploadFileParams
	paramPtrs          *ClientMockUploadFileParamPtrs
	expectationOrigins ClientMockUploadFileExpectationOrigins
	results            *ClientMockUploadFileResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUploadFileParams contains parameters of the Client.UploadFile
type ClientMockUploadFileParams struct {
	ctx context.Context
	up1 *mm_minio.UploadFileParam
}

// ClientMockUploadFileParamPtrs contains pointers to parameters of the Client.UploadFile
type ClientMockUploadFileParamPtrs struct {
	ctx *context.Context
	up1 **mm_minio.UploadFileParam
}

// ClientMockUploadFileResults contains results of the Client.UploadFile
type ClientMockUploadFileResults struct {
	url        string
	objectInfo *miniogo.ObjectInfo
	err        error
}

// ClientMockUploadFileOrigins contains origins of expectations of the Client.UploadFile
type ClientMockUploadFileExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadFile *mClientMockUploadFile) Optional() *mClientMockUploadFile {
	mmUploadFile.optional = true
	return mmUploadFile
}

// Expect sets up expected params for Client.UploadFile
func (mmUploadFile *mClientMockUploadFile) Expect(ctx context.Context, up1 *mm_minio.UploadFileParam) *mClientMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &ClientMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.paramPtrs != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by ExpectParams functions")
	}

	mmUploadFile.defaultExpectation.params = &ClientMockUploadFileParams{ctx, up1}
	mmUploadFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadFile.expectations {
		if minimock.Equal(e.params, mmUploadFile.defaultExpectation.params) {
			mmUploadFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadFile.defaultExpectation.params)
		}
	}

	return mmUploadFile
}

// ExpectCtxParam1 sets up expected param ctx for Client.UploadFile
func (mmUploadFile *mClientMockUploadFile) ExpectCtxParam1(ctx context.Context) *mClientMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &ClientMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &ClientMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadFile
}

// ExpectUp1Param2 sets up expected param up1 for Client.UploadFile
func (mmUploadFile *mClientMockUploadFile) ExpectUp1Param2(up1 *mm_minio.UploadFileParam) *mClientMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &ClientMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &ClientMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.up1 = &up1
	mmUploadFile.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUploadFile
}

// Inspect accepts an inspector function that has same arguments as the Client.UploadFile
func (mmUploadFile *mClientMockUploadFile) Inspect(f func(ctx context.Context, up1 *mm_minio.UploadFileParam)) *mClientMockUploadFile {
	if mmUploadFile.mock.inspectFuncUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("Inspect function is already set for ClientMock.UploadFile")
	}

	mmUploadFile.mock.inspectFuncUploadFile = f

	return mmUploadFile
}

// Return sets up results that will be returned by Client.UploadFile
func (mmUploadFile *mClientMockUploadFile) Return(url string, objectInfo *miniogo.ObjectInfo, err error) *ClientMock {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &ClientMockUploadFileExpectation{mock: mmUploadFile.mock}
	}
	mmUploadFile.defaultExpectation.results = &ClientMockUploadFileResults{url, objectInfo, err}
	mmUploadFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadFile.mock
}

// Set uses given function f to mock the Client.UploadFile method
func (mmUploadFile *mClientMockUploadFile) Set(f func(ctx context.Context, up1 *mm_minio.UploadFileParam) (url string, objectInfo *miniogo.ObjectInfo, err error)) *ClientMock {
	if mmUploadFile.defaultExpectation != nil {
		mmUploadFile.mock.t.Fatalf("Default expectation is already set for the Client.UploadFile method")
	}

	if len(mmUploadFile.expectations) > 0 {
		mmUploadFile.mock.t.Fatalf("Some expectations are already set for the Client.UploadFile method")
	}

	mmUploadFile.mock.funcUploadFile = f
	mmUploadFile.mock.funcUploadFileOrigin = minimock.CallerInfo(1)
	return mmUploadFile.mock
}

// When sets expectation for the Client.UploadFile which will trigger the result defined by the following
// Then helper
func (mmUploadFile *mClientMockUploadFile) When(ctx context.Context, up1 *mm_minio.UploadFileParam) *ClientMockUploadFileExpectation {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("ClientMock.UploadFile mock is already set by Set")
	}

	expectation := &ClientMockUploadFileExpectation{
		mock:               mmUploadFile.mock,
		params:             &ClientMockUploadFileParams{ctx, up1},
		expectationOrigins: ClientMockUploadFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadFile.expectations = append(mmUploadFile.expectations, expectation)
	return expectation
}

// Then sets up Client.UploadFile return parameters for the expectation previously defined by the When method
func (e *ClientMockUploadFileExpectation) Then(url string, objectInfo *miniogo.ObjectInfo, err error) *ClientMock {
	e.results = &ClientMockUploadFileResults{url, objectInfo, err}
	return e.mock
}

// Times sets number of times Client.UploadFile should be invoked
func (mmUploadFile *mClientMockUploadFile) Times(n uint64) *mClientMockUploadFile {
	if n == 0 {
		mmUploadFile.mock.t.Fatalf("Times of ClientMock.UploadFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadFile.expectedInvocations, n)
	mmUploadFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadFile
}

func (mmUploadFile *mClientMockUploadFile) invocationsDone() bool {
	if len(mmUploadFile.expectations) == 0 && mmUploadFile.defaultExpectation == nil && mmUploadFile.mock.funcUploadFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadFile.mock.afterUploadFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadFile implements mm_minio.Client
func (mmUploadFile *ClientMock) UploadFile(ctx context.Context, up1 *mm_minio.UploadFileParam) (url string, objectInfo *miniogo.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmUploadFile.beforeUploadFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadFile.afterUploadFileCounter, 1)

	mmUploadFile.t.Helper()

	if mmUploadFile.inspectFuncUploadFile != nil {
		mmUploadFile.inspectFuncUploadFile(ctx, up1)
	}

	mm_params := ClientMockUploadFileParams{ctx, up1}

	// Record call args
	mmUploadFile.UploadFileMock.mutex.Lock()
	mmUploadFile.UploadFileMock.callArgs = append(mmUploadFile.UploadFileMock.callArgs, &mm_params)
	mmUploadFile.UploadFileMock.mutex.Unlock()

	for _, e := range mmUploadFile.UploadFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.url, e.results.objectInfo, e.results.err
		}
	}

	if mmUploadFile.UploadFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadFile.UploadFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadFile.UploadFileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadFile.UploadFileMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUploadFileParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadFile.t.Errorf("ClientMock.UploadFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUploadFile.t.Errorf("ClientMock.UploadFile got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadFile.t.Errorf("ClientMock.UploadFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadFile.UploadFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadFile.t.Fatal("No results are set for the ClientMock.UploadFile")
		}
		return (*mm_results).url, (*mm_results).objectInfo, (*mm_results).err
	}
	if mmUploadFile.funcUploadFile != nil {
		return mmUploadFile.funcUploadFile(ctx, up1)
	}
	mmUploadFile.t.Fatalf("Unexpected call to ClientMock.UploadFile. %v %v", ctx, up1)
	return
}

// UploadFileAfterCounter returns a count of finished ClientMock.UploadFile invocations
func (mmUploadFile *ClientMock) UploadFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFile.afterUploadFileCounter)
}

// UploadFileBeforeCounter returns a count of ClientMock.UploadFile invocations
func (mmUploadFile *ClientMock) UploadFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFile.beforeUploadFileCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UploadFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadFile *mClientMockUploadFile) Calls() []*ClientMockUploadFileParams {
	mmUploadFile.mutex.RLock()

	argCopy := make([]*ClientMockUploadFileParams, len(mmUploadFile.callArgs))
	copy(argCopy, mmUploadFile.callArgs)

	mmUploadFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadFileDone returns true if the count of the UploadFile invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUploadFileDone() bool {
	if m.UploadFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadFileMock.invocationsDone()
}

// MinimockUploadFileInspect logs each unmet expectation
func (m *ClientMock) MinimockUploadFileInspect() {
	for _, e := range m.UploadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UploadFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadFileCounter := mm_atomic.LoadUint64(&m.afterUploadFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadFileMock.defaultExpectation != nil && afterUploadFileCounter < 1 {
		if m.UploadFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UploadFile at\n%s", m.UploadFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UploadFile at\n%s with params: %#v", m.UploadFileMock.defaultExpectation.expectationOrigins.origin, *m.UploadFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadFile != nil && afterUploadFileCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UploadFile at\n%s", m.funcUploadFileOrigin)
	}

	if !m.UploadFileMock.invocationsDone() && afterUploadFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UploadFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadFileMock.expectedInvocations), m.UploadFileMock.expectedInvocationsOrigin, afterUploadFileCounter)
	}
}

type mClientMockUploadFileBytes struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUploadFileBytesExpectation
	expectations       []*ClientMockUploadFileBytesExpectation

	callArgs []*ClientMockUploadFileBytesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUploadFileBytesExpectation specifies expectation struct of the Client.UploadFileBytes
type ClientMockUploadFileBytesExpectation struct {
	mock               *ClientMock
	params             *ClientMockUploadFileBytesParams
	paramPtrs          *ClientMockUploadFileBytesParamPtrs
	expectationOrigins ClientMockUploadFileBytesExpectationOrigins
	results            *ClientMockUploadFileBytesResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUploadFileBytesParams contains parameters of the Client.UploadFileBytes
type ClientMockUploadFileBytesParams struct {
	ctx context.Context
	up1 *mm_minio.UploadFileBytesParam
}

// ClientMockUploadFileBytesParamPtrs contains pointers to parameters of the Client.UploadFileBytes
type ClientMockUploadFileBytesParamPtrs struct {
	ctx *context.Context
	up1 **mm_minio.UploadFileBytesParam
}

// ClientMockUploadFileBytesResults contains results of the Client.UploadFileBytes
type ClientMockUploadFileBytesResults struct {
	url        string
	objectInfo *miniogo.ObjectInfo
	err        error
}

// ClientMockUploadFileBytesOrigins contains origins of expectations of the Client.UploadFileBytes
type ClientMockUploadFileBytesExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadFileBytes *mClientMockUploadFileBytes) Optional() *mClientMockUploadFileBytes {
	mmUploadFileBytes.optional = true
	return mmUploadFileBytes
}

// Expect sets up expected params for Client.UploadFileBytes
func (mmUploadFileBytes *mClientMockUploadFileBytes) Expect(ctx context.Context, up1 *mm_minio.UploadFileBytesParam) *mClientMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &ClientMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by ExpectParams functions")
	}

	mmUploadFileBytes.defaultExpectation.params = &ClientMockUploadFileBytesParams{ctx, up1}
	mmUploadFileBytes.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadFileBytes.expectations {
		if minimock.Equal(e.params, mmUploadFileBytes.defaultExpectation.params) {
			mmUploadFileBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadFileBytes.defaultExpectation.params)
		}
	}

	return mmUploadFileBytes
}

// ExpectCtxParam1 sets up expected param ctx for Client.UploadFileBytes
func (mmUploadFileBytes *mClientMockUploadFileBytes) ExpectCtxParam1(ctx context.Context) *mClientMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &ClientMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &ClientMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// ExpectUp1Param2 sets up expected param up1 for Client.UploadFileBytes
func (mmUploadFileBytes *mClientMockUploadFileBytes) ExpectUp1Param2(up1 *mm_minio.UploadFileBytesParam) *mClientMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &ClientMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &ClientMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.up1 = &up1
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// Inspect accepts an inspector function that has same arguments as the Client.UploadFileBytes
func (mmUploadFileBytes *mClientMockUploadFileBytes) Inspect(f func(ctx context.Context, up1 *mm_minio.UploadFileBytesParam)) *mClientMockUploadFileBytes {
	if mmUploadFileBytes.mock.inspectFuncUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("Inspect function is already set for ClientMock.UploadFileBytes")
	}

	mmUploadFileBytes.mock.inspectFuncUploadFileBytes = f

	return mmUploadFileBytes
}

// Return sets up results that will be returned by Client.UploadFileBytes
func (mmUploadFileBytes *mClientMockUploadFileBytes) Return(url string, objectInfo *miniogo.ObjectInfo, err error) *ClientMock {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &ClientMockUploadFileBytesExpectation{mock: mmUploadFileBytes.mock}
	}
	mmUploadFileBytes.defaultExpectation.results = &ClientMockUploadFileBytesResults{url, objectInfo, err}
	mmUploadFileBytes.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes.mock
}

// Set uses given function f to mock the Client.UploadFileBytes method
func (mmUploadFileBytes *mClientMockUploadFileBytes) Set(f func(ctx context.Context, up1 *mm_minio.UploadFileBytesParam) (url string, objectInfo *miniogo.ObjectInfo, err error)) *ClientMock {
	if mmUploadFileBytes.defaultExpectation != nil {
		mmUploadFileBytes.mock.t.Fatalf("Default expectation is already set for the Client.UploadFileBytes method")
	}

	if len(mmUploadFileBytes.expectations) > 0 {
		mmUploadFileBytes.mock.t.Fatalf("Some expectations are already set for the Client.UploadFileBytes method")
	}

	mmUploadFileBytes.mock.funcUploadFileBytes = f
	mmUploadFileBytes.mock.funcUploadFileBytesOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes.mock
}

// When sets expectation for the Client.UploadFileBytes which will trigger the result defined by the following
// Then helper
func (mmUploadFileBytes *mClientMockUploadFileBytes) When(ctx context.Context, up1 *mm_minio.UploadFileBytesParam) *ClientMockUploadFileBytesExpectation {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("ClientMock.UploadFileBytes mock is already set by Set")
	}

	expectation := &ClientMockUploadFileBytesExpectation{
		mock:               mmUploadFileBytes.mock,
		params:             &ClientMockUploadFileBytesParams{ctx, up1},
		expectationOrigins: ClientMockUploadFileBytesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadFileBytes.expectations = append(mmUploadFileBytes.expectations, expectation)
	return expectation
}

// Then sets up Client.UploadFileBytes return parameters for the expectation previously defined by the When method
func (e *ClientMockUploadFileBytesExpectation) Then(url string, objectInfo *miniogo.ObjectInfo, err error) *ClientMock {
	e.results = &ClientMockUploadFileBytesResults{url, objectInfo, err}
	return e.mock
}

// Times sets number of times Client.UploadFileBytes should be invoked
func (mmUploadFileBytes *mClientMockUploadFileBytes) Times(n uint64) *mClientMockUploadFileBytes {
	if n == 0 {
		mmUploadFileBytes.mock.t.Fatalf("Times of ClientMock.UploadFileBytes mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadFileBytes.expectedInvocations, n)
	mmUploadFileBytes.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes
}

func (mmUploadFileBytes *mClientMockUploadFileBytes) invocationsDone() bool {
	if len(mmUploadFileBytes.expectations) == 0 && mmUploadFileBytes.defaultExpectation == nil && mmUploadFileBytes.mock.funcUploadFileBytes == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadFileBytes.mock.afterUploadFileBytesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadFileBytes.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadFileBytes implements mm_minio.Client
func (mmUploadFileBytes *ClientMock) UploadFileBytes(ctx context.Context, up1 *mm_minio.UploadFileBytesParam) (url string, objectInfo *miniogo.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmUploadFileBytes.beforeUploadFileBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadFileBytes.afterUploadFileBytesCounter, 1)

	mmUploadFileBytes.t.Helper()

	if mmUploadFileBytes.inspectFuncUploadFileBytes != nil {
		mmUploadFileBytes.inspectFuncUploadFileBytes(ctx, up1)
	}

	mm_params := ClientMockUploadFileBytesParams{ctx, up1}

	// Record call args
	mmUploadFileBytes.UploadFileBytesMock.mutex.Lock()
	mmUploadFileBytes.UploadFileBytesMock.callArgs = append(mmUploadFileBytes.UploadFileBytesMock.callArgs, &mm_params)
	mmUploadFileBytes.UploadFileBytesMock.mutex.Unlock()

	for _, e := range mmUploadFileBytes.UploadFileBytesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.url, e.results.objectInfo, e.results.err
		}
	}

	if mmUploadFileBytes.UploadFileBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.params
		mm_want_ptrs := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUploadFileBytesParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadFileBytes.t.Errorf("ClientMock.UploadFileBytes got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUploadFileBytes.t.Errorf("ClientMock.UploadFileBytes got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadFileBytes.t.Errorf("ClientMock.UploadFileBytes got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadFileBytes.t.Fatal("No results are set for the ClientMock.UploadFileBytes")
		}
		return (*mm_results).url, (*mm_results).objectInfo, (*mm_results).err
	}
	if mmUploadFileBytes.funcUploadFileBytes != nil {
		return mmUploadFileBytes.funcUploadFileBytes(ctx, up1)
	}
	mmUploadFileBytes.t.Fatalf("Unexpected call to ClientMock.UploadFileBytes. %v %v", ctx, up1)
	return
}

// UploadFileBytesAfterCounter returns a count of finished ClientMock.UploadFileBytes invocations
func (mmUploadFileBytes *ClientMock) UploadFileBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFileBytes.afterUploadFileBytesCounter)
}

// UploadFileBytesBeforeCounter returns a count of ClientMock.UploadFileBytes invocations
func (mmUploadFileBytes *ClientMock) UploadFileBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFileBytes.beforeUploadFileBytesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UploadFileBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadFileBytes *mClientMockUploadFileBytes) Calls() []*ClientMockUploadFileBytesParams {
	mmUploadFileBytes.mutex.RLock()

	argCopy := make([]*ClientMockUploadFileBytesParams, len(mmUploadFileBytes.callArgs))
	copy(argCopy, mmUploadFileBytes.callArgs)

	mmUploadFileBytes.mutex.RUnlock()

	return argCopy
}

// MinimockUploadFileBytesDone returns true if the count of the UploadFileBytes invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUploadFileBytesDone() bool {
	if m.UploadFileBytesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadFileBytesMock.invocationsDone()
}

// MinimockUploadFileBytesInspect logs each unmet expectation
func (m *ClientMock) MinimockUploadFileBytesInspect() {
	for _, e := range m.UploadFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UploadFileBytes at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadFileBytesCounter := mm_atomic.LoadUint64(&m.afterUploadFileBytesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadFileBytesMock.defaultExpectation != nil && afterUploadFileBytesCounter < 1 {
		if m.UploadFileBytesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UploadFileBytes at\n%s", m.UploadFileBytesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UploadFileBytes at\n%s with params: %#v", m.UploadFileBytesMock.defaultExpectation.expectationOrigins.origin, *m.UploadFileBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadFileBytes != nil && afterUploadFileBytesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UploadFileBytes at\n%s", m.funcUploadFileBytesOrigin)
	}

	if !m.UploadFileBytesMock.invocationsDone() && afterUploadFileBytesCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UploadFileBytes at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadFileBytesMock.expectedInvocations), m.UploadFileBytesMock.expectedInvocationsOrigin, afterUploadFileBytesCounter)
	}
}

type mClientMockUploadPrivateFileBytes struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUploadPrivateFileBytesExpectation
	expectations       []*ClientMockUploadPrivateFileBytesExpectation

	callArgs []*ClientMockUploadPrivateFileBytesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUploadPrivateFileBytesExpectation specifies expectation struct of the Client.UploadPrivateFileBytes
type ClientMockUploadPrivateFileBytesExpectation struct {
	mock               *ClientMock
	params             *ClientMockUploadPrivateFileBytesParams
	paramPtrs          *ClientMockUploadPrivateFileBytesParamPtrs
	expectationOrigins ClientMockUploadPrivateFileBytesExpectationOrigins
	results            *ClientMockUploadPrivateFileBytesResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUploadPrivateFileBytesParams contains parameters of the Client.UploadPrivateFileBytes
type ClientMockUploadPrivateFileBytesParams struct {
	ctx context.Context
	u1  mm_minio.UploadFileBytesParam
}

// ClientMockUploadPrivateFileBytesParamPtrs contains pointers to parameters of the Client.UploadPrivateFileBytes
type ClientMockUploadPrivateFileBytesParamPtrs struct {
	ctx *context.Context
	u1  *mm_minio.UploadFileBytesParam
}

// ClientMockUploadPrivateFileBytesResults contains results of the Client.UploadPrivateFileBytes
type ClientMockUploadPrivateFileBytesResults struct {
	err error
}

// ClientMockUploadPrivateFileBytesOrigins contains origins of expectations of the Client.UploadPrivateFileBytes
type ClientMockUploadPrivateFileBytesExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Optional() *mClientMockUploadPrivateFileBytes {
	mmUploadPrivateFileBytes.optional = true
	return mmUploadPrivateFileBytes
}

// Expect sets up expected params for Client.UploadPrivateFileBytes
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Expect(ctx context.Context, u1 mm_minio.UploadFileBytesParam) *mClientMockUploadPrivateFileBytes {
	if mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Set")
	}

	if mmUploadPrivateFileBytes.defaultExpectation == nil {
		mmUploadPrivateFileBytes.defaultExpectation = &ClientMockUploadPrivateFileBytesExpectation{}
	}

	if mmUploadPrivateFileBytes.defaultExpectation.paramPtrs != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by ExpectParams functions")
	}

	mmUploadPrivateFileBytes.defaultExpectation.params = &ClientMockUploadPrivateFileBytesParams{ctx, u1}
	mmUploadPrivateFileBytes.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadPrivateFileBytes.expectations {
		if minimock.Equal(e.params, mmUploadPrivateFileBytes.defaultExpectation.params) {
			mmUploadPrivateFileBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadPrivateFileBytes.defaultExpectation.params)
		}
	}

	return mmUploadPrivateFileBytes
}

// ExpectCtxParam1 sets up expected param ctx for Client.UploadPrivateFileBytes
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) ExpectCtxParam1(ctx context.Context) *mClientMockUploadPrivateFileBytes {
	if mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Set")
	}

	if mmUploadPrivateFileBytes.defaultExpectation == nil {
		mmUploadPrivateFileBytes.defaultExpectation = &ClientMockUploadPrivateFileBytesExpectation{}
	}

	if mmUploadPrivateFileBytes.defaultExpectation.params != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Expect")
	}

	if mmUploadPrivateFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadPrivateFileBytes.defaultExpectation.paramPtrs = &ClientMockUploadPrivateFileBytesParamPtrs{}
	}
	mmUploadPrivateFileBytes.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadPrivateFileBytes.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadPrivateFileBytes
}

// ExpectU1Param2 sets up expected param u1 for Client.UploadPrivateFileBytes
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) ExpectU1Param2(u1 mm_minio.UploadFileBytesParam) *mClientMockUploadPrivateFileBytes {
	if mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Set")
	}

	if mmUploadPrivateFileBytes.defaultExpectation == nil {
		mmUploadPrivateFileBytes.defaultExpectation = &ClientMockUploadPrivateFileBytesExpectation{}
	}

	if mmUploadPrivateFileBytes.defaultExpectation.params != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Expect")
	}

	if mmUploadPrivateFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadPrivateFileBytes.defaultExpectation.paramPtrs = &ClientMockUploadPrivateFileBytesParamPtrs{}
	}
	mmUploadPrivateFileBytes.defaultExpectation.paramPtrs.u1 = &u1
	mmUploadPrivateFileBytes.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmUploadPrivateFileBytes
}

// Inspect accepts an inspector function that has same arguments as the Client.UploadPrivateFileBytes
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Inspect(f func(ctx context.Context, u1 mm_minio.UploadFileBytesParam)) *mClientMockUploadPrivateFileBytes {
	if mmUploadPrivateFileBytes.mock.inspectFuncUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("Inspect function is already set for ClientMock.UploadPrivateFileBytes")
	}

	mmUploadPrivateFileBytes.mock.inspectFuncUploadPrivateFileBytes = f

	return mmUploadPrivateFileBytes
}

// Return sets up results that will be returned by Client.UploadPrivateFileBytes
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Return(err error) *ClientMock {
	if mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Set")
	}

	if mmUploadPrivateFileBytes.defaultExpectation == nil {
		mmUploadPrivateFileBytes.defaultExpectation = &ClientMockUploadPrivateFileBytesExpectation{mock: mmUploadPrivateFileBytes.mock}
	}
	mmUploadPrivateFileBytes.defaultExpectation.results = &ClientMockUploadPrivateFileBytesResults{err}
	mmUploadPrivateFileBytes.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadPrivateFileBytes.mock
}

// Set uses given function f to mock the Client.UploadPrivateFileBytes method
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Set(f func(ctx context.Context, u1 mm_minio.UploadFileBytesParam) (err error)) *ClientMock {
	if mmUploadPrivateFileBytes.defaultExpectation != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("Default expectation is already set for the Client.UploadPrivateFileBytes method")
	}

	if len(mmUploadPrivateFileBytes.expectations) > 0 {
		mmUploadPrivateFileBytes.mock.t.Fatalf("Some expectations are already set for the Client.UploadPrivateFileBytes method")
	}

	mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes = f
	mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytesOrigin = minimock.CallerInfo(1)
	return mmUploadPrivateFileBytes.mock
}

// When sets expectation for the Client.UploadPrivateFileBytes which will trigger the result defined by the following
// Then helper
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) When(ctx context.Context, u1 mm_minio.UploadFileBytesParam) *ClientMockUploadPrivateFileBytesExpectation {
	if mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.mock.t.Fatalf("ClientMock.UploadPrivateFileBytes mock is already set by Set")
	}

	expectation := &ClientMockUploadPrivateFileBytesExpectation{
		mock:               mmUploadPrivateFileBytes.mock,
		params:             &ClientMockUploadPrivateFileBytesParams{ctx, u1},
		expectationOrigins: ClientMockUploadPrivateFileBytesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadPrivateFileBytes.expectations = append(mmUploadPrivateFileBytes.expectations, expectation)
	return expectation
}

// Then sets up Client.UploadPrivateFileBytes return parameters for the expectation previously defined by the When method
func (e *ClientMockUploadPrivateFileBytesExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockUploadPrivateFileBytesResults{err}
	return e.mock
}

// Times sets number of times Client.UploadPrivateFileBytes should be invoked
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Times(n uint64) *mClientMockUploadPrivateFileBytes {
	if n == 0 {
		mmUploadPrivateFileBytes.mock.t.Fatalf("Times of ClientMock.UploadPrivateFileBytes mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadPrivateFileBytes.expectedInvocations, n)
	mmUploadPrivateFileBytes.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadPrivateFileBytes
}

func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) invocationsDone() bool {
	if len(mmUploadPrivateFileBytes.expectations) == 0 && mmUploadPrivateFileBytes.defaultExpectation == nil && mmUploadPrivateFileBytes.mock.funcUploadPrivateFileBytes == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadPrivateFileBytes.mock.afterUploadPrivateFileBytesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadPrivateFileBytes.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadPrivateFileBytes implements mm_minio.Client
func (mmUploadPrivateFileBytes *ClientMock) UploadPrivateFileBytes(ctx context.Context, u1 mm_minio.UploadFileBytesParam) (err error) {
	mm_atomic.AddUint64(&mmUploadPrivateFileBytes.beforeUploadPrivateFileBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadPrivateFileBytes.afterUploadPrivateFileBytesCounter, 1)

	mmUploadPrivateFileBytes.t.Helper()

	if mmUploadPrivateFileBytes.inspectFuncUploadPrivateFileBytes != nil {
		mmUploadPrivateFileBytes.inspectFuncUploadPrivateFileBytes(ctx, u1)
	}

	mm_params := ClientMockUploadPrivateFileBytesParams{ctx, u1}

	// Record call args
	mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.mutex.Lock()
	mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.callArgs = append(mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.callArgs, &mm_params)
	mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.mutex.Unlock()

	for _, e := range mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.params
		mm_want_ptrs := mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUploadPrivateFileBytesParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadPrivateFileBytes.t.Errorf("ClientMock.UploadPrivateFileBytes got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmUploadPrivateFileBytes.t.Errorf("ClientMock.UploadPrivateFileBytes got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadPrivateFileBytes.t.Errorf("ClientMock.UploadPrivateFileBytes got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadPrivateFileBytes.UploadPrivateFileBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadPrivateFileBytes.t.Fatal("No results are set for the ClientMock.UploadPrivateFileBytes")
		}
		return (*mm_results).err
	}
	if mmUploadPrivateFileBytes.funcUploadPrivateFileBytes != nil {
		return mmUploadPrivateFileBytes.funcUploadPrivateFileBytes(ctx, u1)
	}
	mmUploadPrivateFileBytes.t.Fatalf("Unexpected call to ClientMock.UploadPrivateFileBytes. %v %v", ctx, u1)
	return
}

// UploadPrivateFileBytesAfterCounter returns a count of finished ClientMock.UploadPrivateFileBytes invocations
func (mmUploadPrivateFileBytes *ClientMock) UploadPrivateFileBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadPrivateFileBytes.afterUploadPrivateFileBytesCounter)
}

// UploadPrivateFileBytesBeforeCounter returns a count of ClientMock.UploadPrivateFileBytes invocations
func (mmUploadPrivateFileBytes *ClientMock) UploadPrivateFileBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadPrivateFileBytes.beforeUploadPrivateFileBytesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UploadPrivateFileBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadPrivateFileBytes *mClientMockUploadPrivateFileBytes) Calls() []*ClientMockUploadPrivateFileBytesParams {
	mmUploadPrivateFileBytes.mutex.RLock()

	argCopy := make([]*ClientMockUploadPrivateFileBytesParams, len(mmUploadPrivateFileBytes.callArgs))
	copy(argCopy, mmUploadPrivateFileBytes.callArgs)

	mmUploadPrivateFileBytes.mutex.RUnlock()

	return argCopy
}

// MinimockUploadPrivateFileBytesDone returns true if the count of the UploadPrivateFileBytes invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUploadPrivateFileBytesDone() bool {
	if m.UploadPrivateFileBytesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadPrivateFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadPrivateFileBytesMock.invocationsDone()
}

// MinimockUploadPrivateFileBytesInspect logs each unmet expectation
func (m *ClientMock) MinimockUploadPrivateFileBytesInspect() {
	for _, e := range m.UploadPrivateFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UploadPrivateFileBytes at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadPrivateFileBytesCounter := mm_atomic.LoadUint64(&m.afterUploadPrivateFileBytesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadPrivateFileBytesMock.defaultExpectation != nil && afterUploadPrivateFileBytesCounter < 1 {
		if m.UploadPrivateFileBytesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UploadPrivateFileBytes at\n%s", m.UploadPrivateFileBytesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UploadPrivateFileBytes at\n%s with params: %#v", m.UploadPrivateFileBytesMock.defaultExpectation.expectationOrigins.origin, *m.UploadPrivateFileBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadPrivateFileBytes != nil && afterUploadPrivateFileBytesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UploadPrivateFileBytes at\n%s", m.funcUploadPrivateFileBytesOrigin)
	}

	if !m.UploadPrivateFileBytesMock.invocationsDone() && afterUploadPrivateFileBytesCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UploadPrivateFileBytes at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadPrivateFileBytesMock.expectedInvocations), m.UploadPrivateFileBytesMock.expectedInvocationsOrigin, afterUploadPrivateFileBytesCounter)
	}
}

type mClientMockWithLogger struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockWithLoggerExpectation
	expectations       []*ClientMockWithLoggerExpectation

	callArgs []*ClientMockWithLoggerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockWithLoggerExpectation specifies expectation struct of the Client.WithLogger
type ClientMockWithLoggerExpectation struct {
	mock               *ClientMock
	params             *ClientMockWithLoggerParams
	paramPtrs          *ClientMockWithLoggerParamPtrs
	expectationOrigins ClientMockWithLoggerExpectationOrigins
	results            *ClientMockWithLoggerResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockWithLoggerParams contains parameters of the Client.WithLogger
type ClientMockWithLoggerParams struct {
	lp1 *zap.Logger
}

// ClientMockWithLoggerParamPtrs contains pointers to parameters of the Client.WithLogger
type ClientMockWithLoggerParamPtrs struct {
	lp1 **zap.Logger
}

// ClientMockWithLoggerResults contains results of the Client.WithLogger
type ClientMockWithLoggerResults struct {
	c1 mm_minio.Client
}

// ClientMockWithLoggerOrigins contains origins of expectations of the Client.WithLogger
type ClientMockWithLoggerExpectationOrigins struct {
	origin    string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithLogger *mClientMockWithLogger) Optional() *mClientMockWithLogger {
	mmWithLogger.optional = true
	return mmWithLogger
}

// Expect sets up expected params for Client.WithLogger
func (mmWithLogger *mClientMockWithLogger) Expect(lp1 *zap.Logger) *mClientMockWithLogger {
	if mmWithLogger.mock.funcWithLogger != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by Set")
	}

	if mmWithLogger.defaultExpectation == nil {
		mmWithLogger.defaultExpectation = &ClientMockWithLoggerExpectation{}
	}

	if mmWithLogger.defaultExpectation.paramPtrs != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by ExpectParams functions")
	}

	mmWithLogger.defaultExpectation.params = &ClientMockWithLoggerParams{lp1}
	mmWithLogger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithLogger.expectations {
		if minimock.Equal(e.params, mmWithLogger.defaultExpectation.params) {
			mmWithLogger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithLogger.defaultExpectation.params)
		}
	}

	return mmWithLogger
}

// ExpectLp1Param1 sets up expected param lp1 for Client.WithLogger
func (mmWithLogger *mClientMockWithLogger) ExpectLp1Param1(lp1 *zap.Logger) *mClientMockWithLogger {
	if mmWithLogger.mock.funcWithLogger != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by Set")
	}

	if mmWithLogger.defaultExpectation == nil {
		mmWithLogger.defaultExpectation = &ClientMockWithLoggerExpectation{}
	}

	if mmWithLogger.defaultExpectation.params != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by Expect")
	}

	if mmWithLogger.defaultExpectation.paramPtrs == nil {
		mmWithLogger.defaultExpectation.paramPtrs = &ClientMockWithLoggerParamPtrs{}
	}
	mmWithLogger.defaultExpectation.paramPtrs.lp1 = &lp1
	mmWithLogger.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmWithLogger
}

// Inspect accepts an inspector function that has same arguments as the Client.WithLogger
func (mmWithLogger *mClientMockWithLogger) Inspect(f func(lp1 *zap.Logger)) *mClientMockWithLogger {
	if mmWithLogger.mock.inspectFuncWithLogger != nil {
		mmWithLogger.mock.t.Fatalf("Inspect function is already set for ClientMock.WithLogger")
	}

	mmWithLogger.mock.inspectFuncWithLogger = f

	return mmWithLogger
}

// Return sets up results that will be returned by Client.WithLogger
func (mmWithLogger *mClientMockWithLogger) Return(c1 mm_minio.Client) *ClientMock {
	if mmWithLogger.mock.funcWithLogger != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by Set")
	}

	if mmWithLogger.defaultExpectation == nil {
		mmWithLogger.defaultExpectation = &ClientMockWithLoggerExpectation{mock: mmWithLogger.mock}
	}
	mmWithLogger.defaultExpectation.results = &ClientMockWithLoggerResults{c1}
	mmWithLogger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithLogger.mock
}

// Set uses given function f to mock the Client.WithLogger method
func (mmWithLogger *mClientMockWithLogger) Set(f func(lp1 *zap.Logger) (c1 mm_minio.Client)) *ClientMock {
	if mmWithLogger.defaultExpectation != nil {
		mmWithLogger.mock.t.Fatalf("Default expectation is already set for the Client.WithLogger method")
	}

	if len(mmWithLogger.expectations) > 0 {
		mmWithLogger.mock.t.Fatalf("Some expectations are already set for the Client.WithLogger method")
	}

	mmWithLogger.mock.funcWithLogger = f
	mmWithLogger.mock.funcWithLoggerOrigin = minimock.CallerInfo(1)
	return mmWithLogger.mock
}

// When sets expectation for the Client.WithLogger which will trigger the result defined by the following
// Then helper
func (mmWithLogger *mClientMockWithLogger) When(lp1 *zap.Logger) *ClientMockWithLoggerExpectation {
	if mmWithLogger.mock.funcWithLogger != nil {
		mmWithLogger.mock.t.Fatalf("ClientMock.WithLogger mock is already set by Set")
	}

	expectation := &ClientMockWithLoggerExpectation{
		mock:               mmWithLogger.mock,
		params:             &ClientMockWithLoggerParams{lp1},
		expectationOrigins: ClientMockWithLoggerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithLogger.expectations = append(mmWithLogger.expectations, expectation)
	return expectation
}

// Then sets up Client.WithLogger return parameters for the expectation previously defined by the When method
func (e *ClientMockWithLoggerExpectation) Then(c1 mm_minio.Client) *ClientMock {
	e.results = &ClientMockWithLoggerResults{c1}
	return e.mock
}

// Times sets number of times Client.WithLogger should be invoked
func (mmWithLogger *mClientMockWithLogger) Times(n uint64) *mClientMockWithLogger {
	if n == 0 {
		mmWithLogger.mock.t.Fatalf("Times of ClientMock.WithLogger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithLogger.expectedInvocations, n)
	mmWithLogger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithLogger
}

func (mmWithLogger *mClientMockWithLogger) invocationsDone() bool {
	if len(mmWithLogger.expectations) == 0 && mmWithLogger.defaultExpectation == nil && mmWithLogger.mock.funcWithLogger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithLogger.mock.afterWithLoggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithLogger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithLogger implements mm_minio.Client
func (mmWithLogger *ClientMock) WithLogger(lp1 *zap.Logger) (c1 mm_minio.Client) {
	mm_atomic.AddUint64(&mmWithLogger.beforeWithLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmWithLogger.afterWithLoggerCounter, 1)

	mmWithLogger.t.Helper()

	if mmWithLogger.inspectFuncWithLogger != nil {
		mmWithLogger.inspectFuncWithLogger(lp1)
	}

	mm_params := ClientMockWithLoggerParams{lp1}

	// Record call args
	mmWithLogger.WithLoggerMock.mutex.Lock()
	mmWithLogger.WithLoggerMock.callArgs = append(mmWithLogger.WithLoggerMock.callArgs, &mm_params)
	mmWithLogger.WithLoggerMock.mutex.Unlock()

	for _, e := range mmWithLogger.WithLoggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmWithLogger.WithLoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithLogger.WithLoggerMock.defaultExpectation.Counter, 1)
		mm_want := mmWithLogger.WithLoggerMock.defaultExpectation.params
		mm_want_ptrs := mmWithLogger.WithLoggerMock.defaultExpectation.paramPtrs

		mm_got := ClientMockWithLoggerParams{lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmWithLogger.t.Errorf("ClientMock.WithLogger got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithLogger.WithLoggerMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithLogger.t.Errorf("ClientMock.WithLogger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithLogger.WithLoggerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithLogger.WithLoggerMock.defaultExpectation.results
		if mm_results == nil {
			mmWithLogger.t.Fatal("No results are set for the ClientMock.WithLogger")
		}
		return (*mm_results).c1
	}
	if mmWithLogger.funcWithLogger != nil {
		return mmWithLogger.funcWithLogger(lp1)
	}
	mmWithLogger.t.Fatalf("Unexpected call to ClientMock.WithLogger. %v", lp1)
	return
}

// WithLoggerAfterCounter returns a count of finished ClientMock.WithLogger invocations
func (mmWithLogger *ClientMock) WithLoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLogger.afterWithLoggerCounter)
}

// WithLoggerBeforeCounter returns a count of ClientMock.WithLogger invocations
func (mmWithLogger *ClientMock) WithLoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLogger.beforeWithLoggerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.WithLogger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithLogger *mClientMockWithLogger) Calls() []*ClientMockWithLoggerParams {
	mmWithLogger.mutex.RLock()

	argCopy := make([]*ClientMockWithLoggerParams, len(mmWithLogger.callArgs))
	copy(argCopy, mmWithLogger.callArgs)

	mmWithLogger.mutex.RUnlock()

	return argCopy
}

// MinimockWithLoggerDone returns true if the count of the WithLogger invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWithLoggerDone() bool {
	if m.WithLoggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithLoggerMock.invocationsDone()
}

// MinimockWithLoggerInspect logs each unmet expectation
func (m *ClientMock) MinimockWithLoggerInspect() {
	for _, e := range m.WithLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.WithLogger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithLoggerCounter := mm_atomic.LoadUint64(&m.afterWithLoggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithLoggerMock.defaultExpectation != nil && afterWithLoggerCounter < 1 {
		if m.WithLoggerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.WithLogger at\n%s", m.WithLoggerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.WithLogger at\n%s with params: %#v", m.WithLoggerMock.defaultExpectation.expectationOrigins.origin, *m.WithLoggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLogger != nil && afterWithLoggerCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.WithLogger at\n%s", m.funcWithLoggerOrigin)
	}

	if !m.WithLoggerMock.invocationsDone() && afterWithLoggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.WithLogger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithLoggerMock.expectedInvocations), m.WithLoggerMock.expectedInvocationsOrigin, afterWithLoggerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClientInspect()

			m.MinimockDeleteFileInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockUploadFileInspect()

			m.MinimockUploadFileBytesInspect()

			m.MinimockUploadPrivateFileBytesInspect()

			m.MinimockWithLoggerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClientDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockUploadFileDone() &&
		m.MinimockUploadFileBytesDone() &&
		m.MinimockUploadPrivateFileBytesDone() &&
		m.MinimockWithLoggerDone()
}
