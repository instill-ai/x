// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package client

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/x/client"
	"google.golang.org/grpc"
)

// ConnectionManagerMock implements ConnectionManager
type ConnectionManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcNewClientOptionsAndCreds          func(options ...Option) (da1 []grpc.DialOption, err error)
	funcNewClientOptionsAndCredsOrigin    string
	inspectFuncNewClientOptionsAndCreds   func(options ...Option)
	afterNewClientOptionsAndCredsCounter  uint64
	beforeNewClientOptionsAndCredsCounter uint64
	NewClientOptionsAndCredsMock          mConnectionManagerMockNewClientOptionsAndCreds

	funcNewConnection          func(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool) (cp1 *grpc.ClientConn, err error)
	funcNewConnectionOrigin    string
	inspectFuncNewConnection   func(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool)
	afterNewConnectionCounter  uint64
	beforeNewConnectionCounter uint64
	NewConnectionMock          mConnectionManagerMockNewConnection
}

// NewConnectionManagerMock returns a mock for ConnectionManager
func NewConnectionManagerMock(t minimock.Tester) *ConnectionManagerMock {
	m := &ConnectionManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NewClientOptionsAndCredsMock = mConnectionManagerMockNewClientOptionsAndCreds{mock: m}
	m.NewClientOptionsAndCredsMock.callArgs = []*ConnectionManagerMockNewClientOptionsAndCredsParams{}

	m.NewConnectionMock = mConnectionManagerMockNewConnection{mock: m}
	m.NewConnectionMock.callArgs = []*ConnectionManagerMockNewConnectionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConnectionManagerMockNewClientOptionsAndCreds struct {
	optional           bool
	mock               *ConnectionManagerMock
	defaultExpectation *ConnectionManagerMockNewClientOptionsAndCredsExpectation
	expectations       []*ConnectionManagerMockNewClientOptionsAndCredsExpectation

	callArgs []*ConnectionManagerMockNewClientOptionsAndCredsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionManagerMockNewClientOptionsAndCredsExpectation specifies expectation struct of the ConnectionManager.NewClientOptionsAndCreds
type ConnectionManagerMockNewClientOptionsAndCredsExpectation struct {
	mock               *ConnectionManagerMock
	params             *ConnectionManagerMockNewClientOptionsAndCredsParams
	paramPtrs          *ConnectionManagerMockNewClientOptionsAndCredsParamPtrs
	expectationOrigins ConnectionManagerMockNewClientOptionsAndCredsExpectationOrigins
	results            *ConnectionManagerMockNewClientOptionsAndCredsResults
	returnOrigin       string
	Counter            uint64
}

// ConnectionManagerMockNewClientOptionsAndCredsParams contains parameters of the ConnectionManager.NewClientOptionsAndCreds
type ConnectionManagerMockNewClientOptionsAndCredsParams struct {
	options []Option
}

// ConnectionManagerMockNewClientOptionsAndCredsParamPtrs contains pointers to parameters of the ConnectionManager.NewClientOptionsAndCreds
type ConnectionManagerMockNewClientOptionsAndCredsParamPtrs struct {
	options *[]Option
}

// ConnectionManagerMockNewClientOptionsAndCredsResults contains results of the ConnectionManager.NewClientOptionsAndCreds
type ConnectionManagerMockNewClientOptionsAndCredsResults struct {
	da1 []grpc.DialOption
	err error
}

// ConnectionManagerMockNewClientOptionsAndCredsOrigins contains origins of expectations of the ConnectionManager.NewClientOptionsAndCreds
type ConnectionManagerMockNewClientOptionsAndCredsExpectationOrigins struct {
	origin        string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Optional() *mConnectionManagerMockNewClientOptionsAndCreds {
	mmNewClientOptionsAndCreds.optional = true
	return mmNewClientOptionsAndCreds
}

// Expect sets up expected params for ConnectionManager.NewClientOptionsAndCreds
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Expect(options ...Option) *mConnectionManagerMockNewClientOptionsAndCreds {
	if mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by Set")
	}

	if mmNewClientOptionsAndCreds.defaultExpectation == nil {
		mmNewClientOptionsAndCreds.defaultExpectation = &ConnectionManagerMockNewClientOptionsAndCredsExpectation{}
	}

	if mmNewClientOptionsAndCreds.defaultExpectation.paramPtrs != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by ExpectParams functions")
	}

	mmNewClientOptionsAndCreds.defaultExpectation.params = &ConnectionManagerMockNewClientOptionsAndCredsParams{options}
	mmNewClientOptionsAndCreds.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewClientOptionsAndCreds.expectations {
		if minimock.Equal(e.params, mmNewClientOptionsAndCreds.defaultExpectation.params) {
			mmNewClientOptionsAndCreds.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewClientOptionsAndCreds.defaultExpectation.params)
		}
	}

	return mmNewClientOptionsAndCreds
}

// ExpectOptionsParam1 sets up expected param options for ConnectionManager.NewClientOptionsAndCreds
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) ExpectOptionsParam1(options ...Option) *mConnectionManagerMockNewClientOptionsAndCreds {
	if mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by Set")
	}

	if mmNewClientOptionsAndCreds.defaultExpectation == nil {
		mmNewClientOptionsAndCreds.defaultExpectation = &ConnectionManagerMockNewClientOptionsAndCredsExpectation{}
	}

	if mmNewClientOptionsAndCreds.defaultExpectation.params != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by Expect")
	}

	if mmNewClientOptionsAndCreds.defaultExpectation.paramPtrs == nil {
		mmNewClientOptionsAndCreds.defaultExpectation.paramPtrs = &ConnectionManagerMockNewClientOptionsAndCredsParamPtrs{}
	}
	mmNewClientOptionsAndCreds.defaultExpectation.paramPtrs.options = &options
	mmNewClientOptionsAndCreds.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmNewClientOptionsAndCreds
}

// Inspect accepts an inspector function that has same arguments as the ConnectionManager.NewClientOptionsAndCreds
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Inspect(f func(options ...Option)) *mConnectionManagerMockNewClientOptionsAndCreds {
	if mmNewClientOptionsAndCreds.mock.inspectFuncNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("Inspect function is already set for ConnectionManagerMock.NewClientOptionsAndCreds")
	}

	mmNewClientOptionsAndCreds.mock.inspectFuncNewClientOptionsAndCreds = f

	return mmNewClientOptionsAndCreds
}

// Return sets up results that will be returned by ConnectionManager.NewClientOptionsAndCreds
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Return(da1 []grpc.DialOption, err error) *ConnectionManagerMock {
	if mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by Set")
	}

	if mmNewClientOptionsAndCreds.defaultExpectation == nil {
		mmNewClientOptionsAndCreds.defaultExpectation = &ConnectionManagerMockNewClientOptionsAndCredsExpectation{mock: mmNewClientOptionsAndCreds.mock}
	}
	mmNewClientOptionsAndCreds.defaultExpectation.results = &ConnectionManagerMockNewClientOptionsAndCredsResults{da1, err}
	mmNewClientOptionsAndCreds.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewClientOptionsAndCreds.mock
}

// Set uses given function f to mock the ConnectionManager.NewClientOptionsAndCreds method
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Set(f func(options ...Option) (da1 []grpc.DialOption, err error)) *ConnectionManagerMock {
	if mmNewClientOptionsAndCreds.defaultExpectation != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("Default expectation is already set for the ConnectionManager.NewClientOptionsAndCreds method")
	}

	if len(mmNewClientOptionsAndCreds.expectations) > 0 {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("Some expectations are already set for the ConnectionManager.NewClientOptionsAndCreds method")
	}

	mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds = f
	mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCredsOrigin = minimock.CallerInfo(1)
	return mmNewClientOptionsAndCreds.mock
}

// When sets expectation for the ConnectionManager.NewClientOptionsAndCreds which will trigger the result defined by the following
// Then helper
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) When(options ...Option) *ConnectionManagerMockNewClientOptionsAndCredsExpectation {
	if mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("ConnectionManagerMock.NewClientOptionsAndCreds mock is already set by Set")
	}

	expectation := &ConnectionManagerMockNewClientOptionsAndCredsExpectation{
		mock:               mmNewClientOptionsAndCreds.mock,
		params:             &ConnectionManagerMockNewClientOptionsAndCredsParams{options},
		expectationOrigins: ConnectionManagerMockNewClientOptionsAndCredsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewClientOptionsAndCreds.expectations = append(mmNewClientOptionsAndCreds.expectations, expectation)
	return expectation
}

// Then sets up ConnectionManager.NewClientOptionsAndCreds return parameters for the expectation previously defined by the When method
func (e *ConnectionManagerMockNewClientOptionsAndCredsExpectation) Then(da1 []grpc.DialOption, err error) *ConnectionManagerMock {
	e.results = &ConnectionManagerMockNewClientOptionsAndCredsResults{da1, err}
	return e.mock
}

// Times sets number of times ConnectionManager.NewClientOptionsAndCreds should be invoked
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Times(n uint64) *mConnectionManagerMockNewClientOptionsAndCreds {
	if n == 0 {
		mmNewClientOptionsAndCreds.mock.t.Fatalf("Times of ConnectionManagerMock.NewClientOptionsAndCreds mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewClientOptionsAndCreds.expectedInvocations, n)
	mmNewClientOptionsAndCreds.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewClientOptionsAndCreds
}

func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) invocationsDone() bool {
	if len(mmNewClientOptionsAndCreds.expectations) == 0 && mmNewClientOptionsAndCreds.defaultExpectation == nil && mmNewClientOptionsAndCreds.mock.funcNewClientOptionsAndCreds == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewClientOptionsAndCreds.mock.afterNewClientOptionsAndCredsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewClientOptionsAndCreds.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewClientOptionsAndCreds implements ConnectionManager
func (mmNewClientOptionsAndCreds *ConnectionManagerMock) NewClientOptionsAndCreds(options ...Option) (da1 []grpc.DialOption, err error) {
	mm_atomic.AddUint64(&mmNewClientOptionsAndCreds.beforeNewClientOptionsAndCredsCounter, 1)
	defer mm_atomic.AddUint64(&mmNewClientOptionsAndCreds.afterNewClientOptionsAndCredsCounter, 1)

	mmNewClientOptionsAndCreds.t.Helper()

	if mmNewClientOptionsAndCreds.inspectFuncNewClientOptionsAndCreds != nil {
		mmNewClientOptionsAndCreds.inspectFuncNewClientOptionsAndCreds(options...)
	}

	mm_params := ConnectionManagerMockNewClientOptionsAndCredsParams{options}

	// Record call args
	mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.mutex.Lock()
	mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.callArgs = append(mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.callArgs, &mm_params)
	mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.mutex.Unlock()

	for _, e := range mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.da1, e.results.err
		}
	}

	if mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.Counter, 1)
		mm_want := mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.params
		mm_want_ptrs := mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.paramPtrs

		mm_got := ConnectionManagerMockNewClientOptionsAndCredsParams{options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmNewClientOptionsAndCreds.t.Errorf("ConnectionManagerMock.NewClientOptionsAndCreds got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewClientOptionsAndCreds.t.Errorf("ConnectionManagerMock.NewClientOptionsAndCreds got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewClientOptionsAndCreds.NewClientOptionsAndCredsMock.defaultExpectation.results
		if mm_results == nil {
			mmNewClientOptionsAndCreds.t.Fatal("No results are set for the ConnectionManagerMock.NewClientOptionsAndCreds")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmNewClientOptionsAndCreds.funcNewClientOptionsAndCreds != nil {
		return mmNewClientOptionsAndCreds.funcNewClientOptionsAndCreds(options...)
	}
	mmNewClientOptionsAndCreds.t.Fatalf("Unexpected call to ConnectionManagerMock.NewClientOptionsAndCreds. %v", options)
	return
}

// NewClientOptionsAndCredsAfterCounter returns a count of finished ConnectionManagerMock.NewClientOptionsAndCreds invocations
func (mmNewClientOptionsAndCreds *ConnectionManagerMock) NewClientOptionsAndCredsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewClientOptionsAndCreds.afterNewClientOptionsAndCredsCounter)
}

// NewClientOptionsAndCredsBeforeCounter returns a count of ConnectionManagerMock.NewClientOptionsAndCreds invocations
func (mmNewClientOptionsAndCreds *ConnectionManagerMock) NewClientOptionsAndCredsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewClientOptionsAndCreds.beforeNewClientOptionsAndCredsCounter)
}

// Calls returns a list of arguments used in each call to ConnectionManagerMock.NewClientOptionsAndCreds.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewClientOptionsAndCreds *mConnectionManagerMockNewClientOptionsAndCreds) Calls() []*ConnectionManagerMockNewClientOptionsAndCredsParams {
	mmNewClientOptionsAndCreds.mutex.RLock()

	argCopy := make([]*ConnectionManagerMockNewClientOptionsAndCredsParams, len(mmNewClientOptionsAndCreds.callArgs))
	copy(argCopy, mmNewClientOptionsAndCreds.callArgs)

	mmNewClientOptionsAndCreds.mutex.RUnlock()

	return argCopy
}

// MinimockNewClientOptionsAndCredsDone returns true if the count of the NewClientOptionsAndCreds invocations corresponds
// the number of defined expectations
func (m *ConnectionManagerMock) MinimockNewClientOptionsAndCredsDone() bool {
	if m.NewClientOptionsAndCredsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewClientOptionsAndCredsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewClientOptionsAndCredsMock.invocationsDone()
}

// MinimockNewClientOptionsAndCredsInspect logs each unmet expectation
func (m *ConnectionManagerMock) MinimockNewClientOptionsAndCredsInspect() {
	for _, e := range m.NewClientOptionsAndCredsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewClientOptionsAndCreds at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewClientOptionsAndCredsCounter := mm_atomic.LoadUint64(&m.afterNewClientOptionsAndCredsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewClientOptionsAndCredsMock.defaultExpectation != nil && afterNewClientOptionsAndCredsCounter < 1 {
		if m.NewClientOptionsAndCredsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewClientOptionsAndCreds at\n%s", m.NewClientOptionsAndCredsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewClientOptionsAndCreds at\n%s with params: %#v", m.NewClientOptionsAndCredsMock.defaultExpectation.expectationOrigins.origin, *m.NewClientOptionsAndCredsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewClientOptionsAndCreds != nil && afterNewClientOptionsAndCredsCounter < 1 {
		m.t.Errorf("Expected call to ConnectionManagerMock.NewClientOptionsAndCreds at\n%s", m.funcNewClientOptionsAndCredsOrigin)
	}

	if !m.NewClientOptionsAndCredsMock.invocationsDone() && afterNewClientOptionsAndCredsCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionManagerMock.NewClientOptionsAndCreds at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewClientOptionsAndCredsMock.expectedInvocations), m.NewClientOptionsAndCredsMock.expectedInvocationsOrigin, afterNewClientOptionsAndCredsCounter)
	}
}

type mConnectionManagerMockNewConnection struct {
	optional           bool
	mock               *ConnectionManagerMock
	defaultExpectation *ConnectionManagerMockNewConnectionExpectation
	expectations       []*ConnectionManagerMockNewConnectionExpectation

	callArgs []*ConnectionManagerMockNewConnectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionManagerMockNewConnectionExpectation specifies expectation struct of the ConnectionManager.NewConnection
type ConnectionManagerMockNewConnectionExpectation struct {
	mock               *ConnectionManagerMock
	params             *ConnectionManagerMockNewConnectionParams
	paramPtrs          *ConnectionManagerMockNewConnectionParamPtrs
	expectationOrigins ConnectionManagerMockNewConnectionExpectationOrigins
	results            *ConnectionManagerMockNewConnectionResults
	returnOrigin       string
	Counter            uint64
}

// ConnectionManagerMockNewConnectionParams contains parameters of the ConnectionManager.NewConnection
type ConnectionManagerMockNewConnectionParams struct {
	host                 string
	port                 int
	https                client.HTTPSConfig
	setOTELClientHandler bool
}

// ConnectionManagerMockNewConnectionParamPtrs contains pointers to parameters of the ConnectionManager.NewConnection
type ConnectionManagerMockNewConnectionParamPtrs struct {
	host                 *string
	port                 *int
	https                *client.HTTPSConfig
	setOTELClientHandler *bool
}

// ConnectionManagerMockNewConnectionResults contains results of the ConnectionManager.NewConnection
type ConnectionManagerMockNewConnectionResults struct {
	cp1 *grpc.ClientConn
	err error
}

// ConnectionManagerMockNewConnectionOrigins contains origins of expectations of the ConnectionManager.NewConnection
type ConnectionManagerMockNewConnectionExpectationOrigins struct {
	origin                     string
	originHost                 string
	originPort                 string
	originHttps                string
	originSetOTELClientHandler string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewConnection *mConnectionManagerMockNewConnection) Optional() *mConnectionManagerMockNewConnection {
	mmNewConnection.optional = true
	return mmNewConnection
}

// Expect sets up expected params for ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) Expect(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{}
	}

	if mmNewConnection.defaultExpectation.paramPtrs != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by ExpectParams functions")
	}

	mmNewConnection.defaultExpectation.params = &ConnectionManagerMockNewConnectionParams{host, port, https, setOTELClientHandler}
	mmNewConnection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewConnection.expectations {
		if minimock.Equal(e.params, mmNewConnection.defaultExpectation.params) {
			mmNewConnection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewConnection.defaultExpectation.params)
		}
	}

	return mmNewConnection
}

// ExpectHostParam1 sets up expected param host for ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) ExpectHostParam1(host string) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{}
	}

	if mmNewConnection.defaultExpectation.params != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Expect")
	}

	if mmNewConnection.defaultExpectation.paramPtrs == nil {
		mmNewConnection.defaultExpectation.paramPtrs = &ConnectionManagerMockNewConnectionParamPtrs{}
	}
	mmNewConnection.defaultExpectation.paramPtrs.host = &host
	mmNewConnection.defaultExpectation.expectationOrigins.originHost = minimock.CallerInfo(1)

	return mmNewConnection
}

// ExpectPortParam2 sets up expected param port for ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) ExpectPortParam2(port int) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{}
	}

	if mmNewConnection.defaultExpectation.params != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Expect")
	}

	if mmNewConnection.defaultExpectation.paramPtrs == nil {
		mmNewConnection.defaultExpectation.paramPtrs = &ConnectionManagerMockNewConnectionParamPtrs{}
	}
	mmNewConnection.defaultExpectation.paramPtrs.port = &port
	mmNewConnection.defaultExpectation.expectationOrigins.originPort = minimock.CallerInfo(1)

	return mmNewConnection
}

// ExpectHttpsParam3 sets up expected param https for ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) ExpectHttpsParam3(https client.HTTPSConfig) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{}
	}

	if mmNewConnection.defaultExpectation.params != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Expect")
	}

	if mmNewConnection.defaultExpectation.paramPtrs == nil {
		mmNewConnection.defaultExpectation.paramPtrs = &ConnectionManagerMockNewConnectionParamPtrs{}
	}
	mmNewConnection.defaultExpectation.paramPtrs.https = &https
	mmNewConnection.defaultExpectation.expectationOrigins.originHttps = minimock.CallerInfo(1)

	return mmNewConnection
}

// ExpectSetOTELClientHandlerParam4 sets up expected param setOTELClientHandler for ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) ExpectSetOTELClientHandlerParam4(setOTELClientHandler bool) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{}
	}

	if mmNewConnection.defaultExpectation.params != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Expect")
	}

	if mmNewConnection.defaultExpectation.paramPtrs == nil {
		mmNewConnection.defaultExpectation.paramPtrs = &ConnectionManagerMockNewConnectionParamPtrs{}
	}
	mmNewConnection.defaultExpectation.paramPtrs.setOTELClientHandler = &setOTELClientHandler
	mmNewConnection.defaultExpectation.expectationOrigins.originSetOTELClientHandler = minimock.CallerInfo(1)

	return mmNewConnection
}

// Inspect accepts an inspector function that has same arguments as the ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) Inspect(f func(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool)) *mConnectionManagerMockNewConnection {
	if mmNewConnection.mock.inspectFuncNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("Inspect function is already set for ConnectionManagerMock.NewConnection")
	}

	mmNewConnection.mock.inspectFuncNewConnection = f

	return mmNewConnection
}

// Return sets up results that will be returned by ConnectionManager.NewConnection
func (mmNewConnection *mConnectionManagerMockNewConnection) Return(cp1 *grpc.ClientConn, err error) *ConnectionManagerMock {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	if mmNewConnection.defaultExpectation == nil {
		mmNewConnection.defaultExpectation = &ConnectionManagerMockNewConnectionExpectation{mock: mmNewConnection.mock}
	}
	mmNewConnection.defaultExpectation.results = &ConnectionManagerMockNewConnectionResults{cp1, err}
	mmNewConnection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewConnection.mock
}

// Set uses given function f to mock the ConnectionManager.NewConnection method
func (mmNewConnection *mConnectionManagerMockNewConnection) Set(f func(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool) (cp1 *grpc.ClientConn, err error)) *ConnectionManagerMock {
	if mmNewConnection.defaultExpectation != nil {
		mmNewConnection.mock.t.Fatalf("Default expectation is already set for the ConnectionManager.NewConnection method")
	}

	if len(mmNewConnection.expectations) > 0 {
		mmNewConnection.mock.t.Fatalf("Some expectations are already set for the ConnectionManager.NewConnection method")
	}

	mmNewConnection.mock.funcNewConnection = f
	mmNewConnection.mock.funcNewConnectionOrigin = minimock.CallerInfo(1)
	return mmNewConnection.mock
}

// When sets expectation for the ConnectionManager.NewConnection which will trigger the result defined by the following
// Then helper
func (mmNewConnection *mConnectionManagerMockNewConnection) When(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool) *ConnectionManagerMockNewConnectionExpectation {
	if mmNewConnection.mock.funcNewConnection != nil {
		mmNewConnection.mock.t.Fatalf("ConnectionManagerMock.NewConnection mock is already set by Set")
	}

	expectation := &ConnectionManagerMockNewConnectionExpectation{
		mock:               mmNewConnection.mock,
		params:             &ConnectionManagerMockNewConnectionParams{host, port, https, setOTELClientHandler},
		expectationOrigins: ConnectionManagerMockNewConnectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewConnection.expectations = append(mmNewConnection.expectations, expectation)
	return expectation
}

// Then sets up ConnectionManager.NewConnection return parameters for the expectation previously defined by the When method
func (e *ConnectionManagerMockNewConnectionExpectation) Then(cp1 *grpc.ClientConn, err error) *ConnectionManagerMock {
	e.results = &ConnectionManagerMockNewConnectionResults{cp1, err}
	return e.mock
}

// Times sets number of times ConnectionManager.NewConnection should be invoked
func (mmNewConnection *mConnectionManagerMockNewConnection) Times(n uint64) *mConnectionManagerMockNewConnection {
	if n == 0 {
		mmNewConnection.mock.t.Fatalf("Times of ConnectionManagerMock.NewConnection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewConnection.expectedInvocations, n)
	mmNewConnection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewConnection
}

func (mmNewConnection *mConnectionManagerMockNewConnection) invocationsDone() bool {
	if len(mmNewConnection.expectations) == 0 && mmNewConnection.defaultExpectation == nil && mmNewConnection.mock.funcNewConnection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewConnection.mock.afterNewConnectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewConnection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewConnection implements ConnectionManager
func (mmNewConnection *ConnectionManagerMock) NewConnection(host string, port int, https client.HTTPSConfig, setOTELClientHandler bool) (cp1 *grpc.ClientConn, err error) {
	mm_atomic.AddUint64(&mmNewConnection.beforeNewConnectionCounter, 1)
	defer mm_atomic.AddUint64(&mmNewConnection.afterNewConnectionCounter, 1)

	mmNewConnection.t.Helper()

	if mmNewConnection.inspectFuncNewConnection != nil {
		mmNewConnection.inspectFuncNewConnection(host, port, https, setOTELClientHandler)
	}

	mm_params := ConnectionManagerMockNewConnectionParams{host, port, https, setOTELClientHandler}

	// Record call args
	mmNewConnection.NewConnectionMock.mutex.Lock()
	mmNewConnection.NewConnectionMock.callArgs = append(mmNewConnection.NewConnectionMock.callArgs, &mm_params)
	mmNewConnection.NewConnectionMock.mutex.Unlock()

	for _, e := range mmNewConnection.NewConnectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmNewConnection.NewConnectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewConnection.NewConnectionMock.defaultExpectation.Counter, 1)
		mm_want := mmNewConnection.NewConnectionMock.defaultExpectation.params
		mm_want_ptrs := mmNewConnection.NewConnectionMock.defaultExpectation.paramPtrs

		mm_got := ConnectionManagerMockNewConnectionParams{host, port, https, setOTELClientHandler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.host != nil && !minimock.Equal(*mm_want_ptrs.host, mm_got.host) {
				mmNewConnection.t.Errorf("ConnectionManagerMock.NewConnection got unexpected parameter host, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewConnection.NewConnectionMock.defaultExpectation.expectationOrigins.originHost, *mm_want_ptrs.host, mm_got.host, minimock.Diff(*mm_want_ptrs.host, mm_got.host))
			}

			if mm_want_ptrs.port != nil && !minimock.Equal(*mm_want_ptrs.port, mm_got.port) {
				mmNewConnection.t.Errorf("ConnectionManagerMock.NewConnection got unexpected parameter port, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewConnection.NewConnectionMock.defaultExpectation.expectationOrigins.originPort, *mm_want_ptrs.port, mm_got.port, minimock.Diff(*mm_want_ptrs.port, mm_got.port))
			}

			if mm_want_ptrs.https != nil && !minimock.Equal(*mm_want_ptrs.https, mm_got.https) {
				mmNewConnection.t.Errorf("ConnectionManagerMock.NewConnection got unexpected parameter https, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewConnection.NewConnectionMock.defaultExpectation.expectationOrigins.originHttps, *mm_want_ptrs.https, mm_got.https, minimock.Diff(*mm_want_ptrs.https, mm_got.https))
			}

			if mm_want_ptrs.setOTELClientHandler != nil && !minimock.Equal(*mm_want_ptrs.setOTELClientHandler, mm_got.setOTELClientHandler) {
				mmNewConnection.t.Errorf("ConnectionManagerMock.NewConnection got unexpected parameter setOTELClientHandler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewConnection.NewConnectionMock.defaultExpectation.expectationOrigins.originSetOTELClientHandler, *mm_want_ptrs.setOTELClientHandler, mm_got.setOTELClientHandler, minimock.Diff(*mm_want_ptrs.setOTELClientHandler, mm_got.setOTELClientHandler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewConnection.t.Errorf("ConnectionManagerMock.NewConnection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewConnection.NewConnectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewConnection.NewConnectionMock.defaultExpectation.results
		if mm_results == nil {
			mmNewConnection.t.Fatal("No results are set for the ConnectionManagerMock.NewConnection")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmNewConnection.funcNewConnection != nil {
		return mmNewConnection.funcNewConnection(host, port, https, setOTELClientHandler)
	}
	mmNewConnection.t.Fatalf("Unexpected call to ConnectionManagerMock.NewConnection. %v %v %v %v", host, port, https, setOTELClientHandler)
	return
}

// NewConnectionAfterCounter returns a count of finished ConnectionManagerMock.NewConnection invocations
func (mmNewConnection *ConnectionManagerMock) NewConnectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewConnection.afterNewConnectionCounter)
}

// NewConnectionBeforeCounter returns a count of ConnectionManagerMock.NewConnection invocations
func (mmNewConnection *ConnectionManagerMock) NewConnectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewConnection.beforeNewConnectionCounter)
}

// Calls returns a list of arguments used in each call to ConnectionManagerMock.NewConnection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewConnection *mConnectionManagerMockNewConnection) Calls() []*ConnectionManagerMockNewConnectionParams {
	mmNewConnection.mutex.RLock()

	argCopy := make([]*ConnectionManagerMockNewConnectionParams, len(mmNewConnection.callArgs))
	copy(argCopy, mmNewConnection.callArgs)

	mmNewConnection.mutex.RUnlock()

	return argCopy
}

// MinimockNewConnectionDone returns true if the count of the NewConnection invocations corresponds
// the number of defined expectations
func (m *ConnectionManagerMock) MinimockNewConnectionDone() bool {
	if m.NewConnectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewConnectionMock.invocationsDone()
}

// MinimockNewConnectionInspect logs each unmet expectation
func (m *ConnectionManagerMock) MinimockNewConnectionInspect() {
	for _, e := range m.NewConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewConnection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewConnectionCounter := mm_atomic.LoadUint64(&m.afterNewConnectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewConnectionMock.defaultExpectation != nil && afterNewConnectionCounter < 1 {
		if m.NewConnectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewConnection at\n%s", m.NewConnectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnectionManagerMock.NewConnection at\n%s with params: %#v", m.NewConnectionMock.defaultExpectation.expectationOrigins.origin, *m.NewConnectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewConnection != nil && afterNewConnectionCounter < 1 {
		m.t.Errorf("Expected call to ConnectionManagerMock.NewConnection at\n%s", m.funcNewConnectionOrigin)
	}

	if !m.NewConnectionMock.invocationsDone() && afterNewConnectionCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionManagerMock.NewConnection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewConnectionMock.expectedInvocations), m.NewConnectionMock.expectedInvocationsOrigin, afterNewConnectionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnectionManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockNewClientOptionsAndCredsInspect()

			m.MinimockNewConnectionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnectionManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConnectionManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNewClientOptionsAndCredsDone() &&
		m.MinimockNewConnectionDone()
}
