// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package client

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientFactoryMock implements ClientFactory
type ClientFactoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcNewClient          func(options ...Option) (a1 any, f1 func() error, err error)
	funcNewClientOrigin    string
	inspectFuncNewClient   func(options ...Option)
	afterNewClientCounter  uint64
	beforeNewClientCounter uint64
	NewClientMock          mClientFactoryMockNewClient
}

// NewClientFactoryMock returns a mock for ClientFactory
func NewClientFactoryMock(t minimock.Tester) *ClientFactoryMock {
	m := &ClientFactoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NewClientMock = mClientFactoryMockNewClient{mock: m}
	m.NewClientMock.callArgs = []*ClientFactoryMockNewClientParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientFactoryMockNewClient struct {
	optional           bool
	mock               *ClientFactoryMock
	defaultExpectation *ClientFactoryMockNewClientExpectation
	expectations       []*ClientFactoryMockNewClientExpectation

	callArgs []*ClientFactoryMockNewClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientFactoryMockNewClientExpectation specifies expectation struct of the ClientFactory.NewClient
type ClientFactoryMockNewClientExpectation struct {
	mock               *ClientFactoryMock
	params             *ClientFactoryMockNewClientParams
	paramPtrs          *ClientFactoryMockNewClientParamPtrs
	expectationOrigins ClientFactoryMockNewClientExpectationOrigins
	results            *ClientFactoryMockNewClientResults
	returnOrigin       string
	Counter            uint64
}

// ClientFactoryMockNewClientParams contains parameters of the ClientFactory.NewClient
type ClientFactoryMockNewClientParams struct {
	options []Option
}

// ClientFactoryMockNewClientParamPtrs contains pointers to parameters of the ClientFactory.NewClient
type ClientFactoryMockNewClientParamPtrs struct {
	options *[]Option
}

// ClientFactoryMockNewClientResults contains results of the ClientFactory.NewClient
type ClientFactoryMockNewClientResults struct {
	a1  any
	f1  func() error
	err error
}

// ClientFactoryMockNewClientOrigins contains origins of expectations of the ClientFactory.NewClient
type ClientFactoryMockNewClientExpectationOrigins struct {
	origin        string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewClient *mClientFactoryMockNewClient) Optional() *mClientFactoryMockNewClient {
	mmNewClient.optional = true
	return mmNewClient
}

// Expect sets up expected params for ClientFactory.NewClient
func (mmNewClient *mClientFactoryMockNewClient) Expect(options ...Option) *mClientFactoryMockNewClient {
	if mmNewClient.mock.funcNewClient != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by Set")
	}

	if mmNewClient.defaultExpectation == nil {
		mmNewClient.defaultExpectation = &ClientFactoryMockNewClientExpectation{}
	}

	if mmNewClient.defaultExpectation.paramPtrs != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by ExpectParams functions")
	}

	mmNewClient.defaultExpectation.params = &ClientFactoryMockNewClientParams{options}
	mmNewClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewClient.expectations {
		if minimock.Equal(e.params, mmNewClient.defaultExpectation.params) {
			mmNewClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewClient.defaultExpectation.params)
		}
	}

	return mmNewClient
}

// ExpectOptionsParam1 sets up expected param options for ClientFactory.NewClient
func (mmNewClient *mClientFactoryMockNewClient) ExpectOptionsParam1(options ...Option) *mClientFactoryMockNewClient {
	if mmNewClient.mock.funcNewClient != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by Set")
	}

	if mmNewClient.defaultExpectation == nil {
		mmNewClient.defaultExpectation = &ClientFactoryMockNewClientExpectation{}
	}

	if mmNewClient.defaultExpectation.params != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by Expect")
	}

	if mmNewClient.defaultExpectation.paramPtrs == nil {
		mmNewClient.defaultExpectation.paramPtrs = &ClientFactoryMockNewClientParamPtrs{}
	}
	mmNewClient.defaultExpectation.paramPtrs.options = &options
	mmNewClient.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmNewClient
}

// Inspect accepts an inspector function that has same arguments as the ClientFactory.NewClient
func (mmNewClient *mClientFactoryMockNewClient) Inspect(f func(options ...Option)) *mClientFactoryMockNewClient {
	if mmNewClient.mock.inspectFuncNewClient != nil {
		mmNewClient.mock.t.Fatalf("Inspect function is already set for ClientFactoryMock.NewClient")
	}

	mmNewClient.mock.inspectFuncNewClient = f

	return mmNewClient
}

// Return sets up results that will be returned by ClientFactory.NewClient
func (mmNewClient *mClientFactoryMockNewClient) Return(a1 any, f1 func() error, err error) *ClientFactoryMock {
	if mmNewClient.mock.funcNewClient != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by Set")
	}

	if mmNewClient.defaultExpectation == nil {
		mmNewClient.defaultExpectation = &ClientFactoryMockNewClientExpectation{mock: mmNewClient.mock}
	}
	mmNewClient.defaultExpectation.results = &ClientFactoryMockNewClientResults{a1, f1, err}
	mmNewClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewClient.mock
}

// Set uses given function f to mock the ClientFactory.NewClient method
func (mmNewClient *mClientFactoryMockNewClient) Set(f func(options ...Option) (a1 any, f1 func() error, err error)) *ClientFactoryMock {
	if mmNewClient.defaultExpectation != nil {
		mmNewClient.mock.t.Fatalf("Default expectation is already set for the ClientFactory.NewClient method")
	}

	if len(mmNewClient.expectations) > 0 {
		mmNewClient.mock.t.Fatalf("Some expectations are already set for the ClientFactory.NewClient method")
	}

	mmNewClient.mock.funcNewClient = f
	mmNewClient.mock.funcNewClientOrigin = minimock.CallerInfo(1)
	return mmNewClient.mock
}

// When sets expectation for the ClientFactory.NewClient which will trigger the result defined by the following
// Then helper
func (mmNewClient *mClientFactoryMockNewClient) When(options ...Option) *ClientFactoryMockNewClientExpectation {
	if mmNewClient.mock.funcNewClient != nil {
		mmNewClient.mock.t.Fatalf("ClientFactoryMock.NewClient mock is already set by Set")
	}

	expectation := &ClientFactoryMockNewClientExpectation{
		mock:               mmNewClient.mock,
		params:             &ClientFactoryMockNewClientParams{options},
		expectationOrigins: ClientFactoryMockNewClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewClient.expectations = append(mmNewClient.expectations, expectation)
	return expectation
}

// Then sets up ClientFactory.NewClient return parameters for the expectation previously defined by the When method
func (e *ClientFactoryMockNewClientExpectation) Then(a1 any, f1 func() error, err error) *ClientFactoryMock {
	e.results = &ClientFactoryMockNewClientResults{a1, f1, err}
	return e.mock
}

// Times sets number of times ClientFactory.NewClient should be invoked
func (mmNewClient *mClientFactoryMockNewClient) Times(n uint64) *mClientFactoryMockNewClient {
	if n == 0 {
		mmNewClient.mock.t.Fatalf("Times of ClientFactoryMock.NewClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewClient.expectedInvocations, n)
	mmNewClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewClient
}

func (mmNewClient *mClientFactoryMockNewClient) invocationsDone() bool {
	if len(mmNewClient.expectations) == 0 && mmNewClient.defaultExpectation == nil && mmNewClient.mock.funcNewClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewClient.mock.afterNewClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewClient implements ClientFactory
func (mmNewClient *ClientFactoryMock) NewClient(options ...Option) (a1 any, f1 func() error, err error) {
	mm_atomic.AddUint64(&mmNewClient.beforeNewClientCounter, 1)
	defer mm_atomic.AddUint64(&mmNewClient.afterNewClientCounter, 1)

	mmNewClient.t.Helper()

	if mmNewClient.inspectFuncNewClient != nil {
		mmNewClient.inspectFuncNewClient(options...)
	}

	mm_params := ClientFactoryMockNewClientParams{options}

	// Record call args
	mmNewClient.NewClientMock.mutex.Lock()
	mmNewClient.NewClientMock.callArgs = append(mmNewClient.NewClientMock.callArgs, &mm_params)
	mmNewClient.NewClientMock.mutex.Unlock()

	for _, e := range mmNewClient.NewClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.f1, e.results.err
		}
	}

	if mmNewClient.NewClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewClient.NewClientMock.defaultExpectation.Counter, 1)
		mm_want := mmNewClient.NewClientMock.defaultExpectation.params
		mm_want_ptrs := mmNewClient.NewClientMock.defaultExpectation.paramPtrs

		mm_got := ClientFactoryMockNewClientParams{options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmNewClient.t.Errorf("ClientFactoryMock.NewClient got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewClient.NewClientMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewClient.t.Errorf("ClientFactoryMock.NewClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewClient.NewClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewClient.NewClientMock.defaultExpectation.results
		if mm_results == nil {
			mmNewClient.t.Fatal("No results are set for the ClientFactoryMock.NewClient")
		}
		return (*mm_results).a1, (*mm_results).f1, (*mm_results).err
	}
	if mmNewClient.funcNewClient != nil {
		return mmNewClient.funcNewClient(options...)
	}
	mmNewClient.t.Fatalf("Unexpected call to ClientFactoryMock.NewClient. %v", options)
	return
}

// NewClientAfterCounter returns a count of finished ClientFactoryMock.NewClient invocations
func (mmNewClient *ClientFactoryMock) NewClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewClient.afterNewClientCounter)
}

// NewClientBeforeCounter returns a count of ClientFactoryMock.NewClient invocations
func (mmNewClient *ClientFactoryMock) NewClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewClient.beforeNewClientCounter)
}

// Calls returns a list of arguments used in each call to ClientFactoryMock.NewClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewClient *mClientFactoryMockNewClient) Calls() []*ClientFactoryMockNewClientParams {
	mmNewClient.mutex.RLock()

	argCopy := make([]*ClientFactoryMockNewClientParams, len(mmNewClient.callArgs))
	copy(argCopy, mmNewClient.callArgs)

	mmNewClient.mutex.RUnlock()

	return argCopy
}

// MinimockNewClientDone returns true if the count of the NewClient invocations corresponds
// the number of defined expectations
func (m *ClientFactoryMock) MinimockNewClientDone() bool {
	if m.NewClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewClientMock.invocationsDone()
}

// MinimockNewClientInspect logs each unmet expectation
func (m *ClientFactoryMock) MinimockNewClientInspect() {
	for _, e := range m.NewClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientFactoryMock.NewClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewClientCounter := mm_atomic.LoadUint64(&m.afterNewClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewClientMock.defaultExpectation != nil && afterNewClientCounter < 1 {
		if m.NewClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientFactoryMock.NewClient at\n%s", m.NewClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientFactoryMock.NewClient at\n%s with params: %#v", m.NewClientMock.defaultExpectation.expectationOrigins.origin, *m.NewClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewClient != nil && afterNewClientCounter < 1 {
		m.t.Errorf("Expected call to ClientFactoryMock.NewClient at\n%s", m.funcNewClientOrigin)
	}

	if !m.NewClientMock.invocationsDone() && afterNewClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientFactoryMock.NewClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewClientMock.expectedInvocations), m.NewClientMock.expectedInvocationsOrigin, afterNewClientCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientFactoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockNewClientInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientFactoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientFactoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNewClientDone()
}
